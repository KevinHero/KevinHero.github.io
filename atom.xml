<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[熊凯的个人博客]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2016-02-22T05:35:13.902Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[熊凯]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Webview上传文件的那些坑]]></title>
    <link href="http://yoursite.com/2016/02/22/Webview%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9D%91/"/>
    <id>http://yoursite.com/2016/02/22/Webview上传文件的那些坑/</id>
    <published>2016-02-22T13:01:14.000Z</published>
    <updated>2016-02-22T05:35:13.902Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>要说Android中最厉害的组件莫过于Webview 了，夸张点说把这个组件放在屏幕上就可以算作一个简单地浏览器应用了。但你若认为这就万事大吉了，可太小看Webview这个磨人的妖精了，下面单就上传文件的这个坑来做展开。</p>
</blockquote>
<a id="more"></a>
<h3 id="u652F_u6301_u4E0A_u4F20_u6587_u4EF6"><a href="#u652F_u6301_u4E0A_u4F20_u6587_u4EF6" class="headerlink" title="支持上传文件"></a>支持上传文件</h3><p>Webview执行上传操作的逻辑是这样的：首先准备上传时会回调WebChromeClient类下的<code>openFileChooser</code>方法，在这个方法中给我们机会发起Intent来打开支持提供文件的第三方应用，最后在<code>onActivityResult</code>回调中将第三方应用提供的内容通过一个叫做<code>ValueCallback</code>的参数返回给<code>Webview</code>（详细点来说：ValueCallback是在openFileChooser 方法里由webview提供给我们的，里面包裹一个Uri，我们在<code>onActivityResult</code> 里将选中的Uri反馈给<code>ValueCallback</code>，这时候相当于Webview就知道我们选择了什么文件），因此，我们需要为<code>Webview</code>设置一个提供<code>openFileChooser</code>方法的<code>WebChromeClient</code>，这个方法在不同版本的<code>Android</code>中参数是不同的，为此我们一般需要写三个重载函数，大致像这个样子：</p>
<pre><code>private ValueCallback&lt;Uri&gt; mUploadMessage;
    //设置`WebChromeClient`:
webview.setWebChromeClient(new WebChromeClient(){
     public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg) {
            Log.d(TAG, &quot;openFileChoose(ValueCallback&lt;Uri&gt; uploadMsg)&quot;);
            mUploadMessage = uploadMsg;
            Intent i = new Intent(Intent.ACTION_GET_CONTENT);
            i.addCategory(Intent.CATEGORY_OPENABLE);
            i.setType(&quot;*/*&quot;);
            MainActivity.this.startActivityForResult(Intent.createChooser(i, &quot;File Chooser&quot;), FILECHOOSER_RESULTCODE);
      }
      public void openFileChooser( ValueCallback uploadMsg, String acceptType ) {
            Log.d(TAG, &quot;openFileChoose( ValueCallback uploadMsg, String acceptType )&quot;);
            mUploadMessage = uploadMsg;
            Intent i = new Intent(Intent.ACTION_GET_CONTENT);
            i.addCategory(Intent.CATEGORY_OPENABLE);
            i.setType(&quot;*/*&quot;);
            MainActivity.this.startActivityForResult(
                    Intent.createChooser(i, &quot;File Browser&quot;),
                    FILECHOOSER_RESULTCODE);
      }
      public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg, String acceptType, String capture){
            Log.d(TAG, &quot;openFileChoose(ValueCallback&lt;Uri&gt; uploadMsg, String acceptType, String capture)&quot;);
            mUploadMessage = uploadMsg;
            Intent i = new Intent(Intent.ACTION_GET_CONTENT);
            i.addCategory(Intent.CATEGORY_OPENABLE);
            i.setType(&quot;*/*&quot;);
            MainActivity.this.startActivityForResult( Intent.createChooser( i, &quot;File Browser&quot; ), MainActivity.FILECHOOSER_RESULTCODE );
        }
});

//onActivityResult回调   
@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        if(requestCode==FILECHOOSER_RESULTCODE)
         {
                if (null == mUploadMessage &amp;&amp; null == mUploadCallbackAboveL) return;
                 Uri result = data == null || resultCode != RESULT_OK ? null : data.getData();
                 if (mUploadMessage != null) {
                    mUploadMessage.onReceiveValue(result);
                    mUploadMessage = null;
               }
          }
       }
</code></pre><p>还有重要的一点：如果这个上传操作涉及到JS操作，别忘记对Webview开启对JS的支持：</p>
<pre><code>WebSettings settings = webview.getSettings();
settings.setJavaScriptEnabled(true);
</code></pre><h3 id="u4EE3_u7801_u6DF7_u6DC6"><a href="#u4EE3_u7801_u6DF7_u6DC6" class="headerlink" title="代码混淆"></a>代码混淆</h3><pre><code>-keepclassmembers class * extends android.webkit.WebChromeClient{
    public void openFileChooser(...);
}
</code></pre><h3 id="u517C_u5BB95-0"><a href="#u517C_u5BB95-0" class="headerlink" title="兼容5.0"></a>兼容5.0</h3><pre><code>webview.setWebChromeClient(new WebChromeClient(){
public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg) {
     ...
}
public void openFileChooser( ValueCallback uploadMsg, String acceptType ) {
       ...
}
public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg, String acceptType, String capture){
                ...
}

// For Android 5.0+
public boolean onShowFileChooser (WebView webView, ValueCallback&lt;Uri[]&gt; filePathCallback, WebChromeClient.FileChooserParams fileChooserParams) {
         mUploadCallbackAboveL = filePathCallback;
         Intent i = new Intent(Intent.ACTION_GET_CONTENT);
         i.addCategory(Intent.CATEGORY_OPENABLE);
         i.setType(&quot;*/*&quot;);
         MainActivity.this.startActivityForResult(
                    Intent.createChooser(i, &quot;File Browser&quot;),
                    FILECHOOSER_RESULTCODE);
         return true;
        }
});

@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {
    super.onActivityResult(requestCode, resultCode, data);
    if(requestCode==FILECHOOSER_RESULTCODE)
    {
        if (null == mUploadMessage &amp;&amp; null == mUploadCallbackAboveL) return;
        Uri result = data == null || resultCode != RESULT_OK ? null : data.getData();
        if (mUploadCallbackAboveL != null) {
            onActivityResultAboveL(requestCode, resultCode, data);
        }
        else  if (mUploadMessage != null) {
            mUploadMessage.onReceiveValue(result);
            mUploadMessage = null;
        }
    }
}
@TargetApi(Build.VERSION_CODES.LOLLIPOP)
private void onActivityResultAboveL(int requestCode, int resultCode, Intent data) {
    if (requestCode != FILECHOOSER_RESULTCODE
            || mUploadCallbackAboveL == null) {
        return;
    }
    Uri[] results = null;
    if (resultCode == Activity.RESULT_OK) {
        if (data == null) {
        } else {
            String dataString = data.getDataString();
            ClipData clipData = data.getClipData();
            if (clipData != null) {
                results = new Uri[clipData.getItemCount()];
                for (int i = 0; i &lt; clipData.getItemCount(); i++) {
                    ClipData.Item item = clipData.getItemAt(i);
                    results[i] = item.getUri();
                }
            }
            if (dataString != null)
                results = new Uri[]{Uri.parse(dataString)};
        }
    }
    mUploadCallbackAboveL.onReceiveValue(results);
    mUploadCallbackAboveL = null;
    return;
}
</code></pre><blockquote>
<p>代码转自: <a href="http://blog.saymagic.cn/2015/11/08/webview-upload.html" target="_blank" rel="external">http://blog.saymagic.cn/2015/11/08/webview-upload.html</a></p>
<p>源码地址: <a href="https://gitcafe.com/saymagic/Webviewdemo" target="_blank" rel="external">https://gitcafe.com/saymagic/Webviewdemo</a></p>
</blockquote>
<pre><code>* 说明:实际上我使用了该段代码只能够 完成5.0+的支持,对于5.0以下的机器支持的并不完美,比如说上传完成之后,并不能显示图片到目标位置.
</code></pre><ul>
<li>没办法继续爬文 终于发现了</li>
</ul>
<pre><code>package com.fuiou.webviewupload;
import java.io.File;
import android.app.Activity;
import android.app.AlertDialog;
import android.content.ContentValues;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.database.Cursor;
import android.graphics.Bitmap;
import android.net.Uri;
import android.os.Bundle;
import android.os.Environment;
import android.provider.MediaStore;
import android.util.Log;
import android.view.KeyEvent;
import android.webkit.ValueCallback;
import android.webkit.WebChromeClient;
import android.webkit.WebView;
import android.webkit.WebViewClient;
import android.widget.Toast;

public class MainActivity extends Activity {
    public static final String TAG = &quot;MainActivity&quot;;
    ValueCallback&lt;Uri&gt; mUploadMessage;
    private WebView mWebView;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        initView();
    }

    private void initView() {
        mWebView = (WebView) findViewById(R.id.web_view);
        mWebView.setWebChromeClient(new MyWebChromeClient());

        mWebView.setWebViewClient(new MyWebViewClient(this));
//        webView.loadUrl(&quot;file:///android_asset/upload_image.html&quot;);
        mWebView.loadUrl(&quot;http://192.168.72.62:8080/fileUpload&quot;);
    }


    private class MyWebViewClient extends WebViewClient{
        private Context mContext;
        public MyWebViewClient(Context context){
            super();
            mContext = context;
        }

        @Override
        public void onPageStarted(WebView view, String url, Bitmap favicon) {
            Log.d(TAG,&quot;URL地址:&quot; + url);
            super.onPageStarted(view, url, favicon);
        }

        @Override
        public void onPageFinished(WebView view, String url) {
            Log.i(TAG, &quot;onPageFinished&quot;);
            super.onPageFinished(view, url);
        }
    }

    public static final int FILECHOOSER_RESULTCODE = 1;
    private static final int REQ_CAMERA = FILECHOOSER_RESULTCODE+1;
    private static final int REQ_CHOOSE = REQ_CAMERA+1;

    private class MyWebChromeClient extends WebChromeClient {

        // For Android 3.0+
           public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg, String acceptType) {  
               if (mUploadMessage != null) return;
               mUploadMessage = uploadMsg;   
               selectImage();
//               Intent i = new Intent(Intent.ACTION_GET_CONTENT);
//               i.addCategory(Intent.CATEGORY_OPENABLE);
//               i.setType(&quot;*/*&quot;);
//                   startActivityForResult( Intent.createChooser( i, &quot;File Chooser&quot; ), FILECHOOSER_RESULTCODE );
           }
            // For Android &lt; 3.0
            public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg) {
                   openFileChooser( uploadMsg, &quot;&quot; );
            }
            // For Android  &gt; 4.1.1
          public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg, String acceptType, String capture) {
                  openFileChooser(uploadMsg, acceptType);
          }

    }

    /**
     * 检查SD卡是否存在
     *
     * @return
     */
    public final boolean checkSDcard() {
        boolean flag = Environment.getExternalStorageState().equals(
                Environment.MEDIA_MOUNTED);
        if (!flag) {
            Toast.makeText(this, &quot;请插入手机存储卡再使用本功能&quot;,Toast.LENGTH_SHORT).show();
        }
        return flag;
    }
    String compressPath = &quot;&quot;;

    protected final void selectImage() {
        if (!checkSDcard())
            return;
        String[] selectPicTypeStr = { &quot;camera&quot;,&quot;photo&quot; };
        new AlertDialog.Builder(this)
                .setItems(selectPicTypeStr,
                        new DialogInterface.OnClickListener() {
                            @Override
                            public void onClick(DialogInterface dialog,
                                    int which) {
                                switch (which) {
                                // 相机拍摄
                                case 0:
                                    openCarcme();
                                    break;
                                // 手机相册
                                case 1:
                                    chosePic();
                                    break;
                                default:
                                    break;
                                }
                                compressPath = Environment
                                        .getExternalStorageDirectory()
                                        .getPath()
                                        + &quot;/fuiou_wmp/temp&quot;;
                                new File(compressPath).mkdirs();
                                compressPath = compressPath + File.separator
                                        + &quot;compress.jpg&quot;;
                            }
                        }).show();
    }

    String imagePaths;
    Uri  cameraUri;
    /**
     * 打开照相机
     */
    private void openCarcme() {
        Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);

        imagePaths = Environment.getExternalStorageDirectory().getPath()
                + &quot;/fuiou_wmp/temp/&quot;
                + (System.currentTimeMillis() + &quot;.jpg&quot;);
        // 必须确保文件夹路径存在，否则拍照后无法完成回调
        File vFile = new File(imagePaths);
        if (!vFile.exists()) {
            File vDirPath = vFile.getParentFile();
            vDirPath.mkdirs();
        } else {
            if (vFile.exists()) {
                vFile.delete();
            }
        }
        cameraUri = Uri.fromFile(vFile);
        intent.putExtra(MediaStore.EXTRA_OUTPUT, cameraUri);
        startActivityForResult(intent, REQ_CAMERA);
    }

    /**
     * 拍照结束后
     */
    private void afterOpenCamera() {
        File f = new File(imagePaths);
        addImageGallery(f);
        File newFile = FileUtils.compressFile(f.getPath(), compressPath);
    }

    /** 解决拍照后在相册中找不到的问题 */
    private void addImageGallery(File file) {
        ContentValues values = new ContentValues();
        values.put(MediaStore.Images.Media.DATA, file.getAbsolutePath());
        values.put(MediaStore.Images.Media.MIME_TYPE, &quot;image/jpeg&quot;);
        getContentResolver().insert(
                MediaStore.Images.Media.EXTERNAL_CONTENT_URI, values);
    }

    /**
     * 本地相册选择图片
     */
    private void chosePic() {
        FileUtils.delFile(compressPath);
        Intent innerIntent = new Intent(Intent.ACTION_GET_CONTENT); // &quot;android.intent.action.GET_CONTENT&quot;
        String IMAGE_UNSPECIFIED = &quot;image/*&quot;;
        innerIntent.setType(IMAGE_UNSPECIFIED); // 查看类型
        Intent wrapperIntent = Intent.createChooser(innerIntent, null);
        startActivityForResult(wrapperIntent, REQ_CHOOSE);
    }

    /**
     * 选择照片后结束
     *
     * @param data
     */
    private Uri afterChosePic(Intent data) {

        // 获取图片的路径：
        String[] proj = { MediaStore.Images.Media.DATA };
        // 好像是android多媒体数据库的封装接口，具体的看Android文档
        Cursor cursor = managedQuery(data.getData(), proj, null, null, null);
        if(cursor == null ){
            Toast.makeText(this, &quot;上传的图片仅支持png或jpg格式&quot;,Toast.LENGTH_SHORT).show();
            return null;
        }
        // 按我个人理解 这个是获得用户选择的图片的索引值
        int column_index = cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DATA);
        // 将光标移至开头 ，这个很重要，不小心很容易引起越界
        cursor.moveToFirst();
        // 最后根据索引值获取图片路径
        String path = cursor.getString(column_index);
        if(path != null &amp;&amp; (path.endsWith(&quot;.png&quot;)||path.endsWith(&quot;.PNG&quot;)||path.endsWith(&quot;.jpg&quot;)||path.endsWith(&quot;.JPG&quot;))){
            File newFile = FileUtils.compressFile(path, compressPath);
            return Uri.fromFile(newFile);
        }else{
            Toast.makeText(this, &quot;上传的图片仅支持png或jpg格式&quot;,Toast.LENGTH_SHORT).show();
        }
        return null;
    }



    /**
     * 返回文件选择
     */
    @Override
    protected void onActivityResult(int requestCode, int resultCode,
            Intent intent) {
    //        if (requestCode == FILECHOOSER_RESULTCODE) {
    //            if (null == mUploadMessage)
    //                return;
    //            Uri result = intent == null || resultCode != RESULT_OK ? null
    //                    : intent.getData();
    //            mUploadMessage.onReceiveValue(result);
    //            mUploadMessage = null;
    //        }

        if (null == mUploadMessage)
            return;
        Uri uri = null;
        if(requestCode == REQ_CAMERA ){
            afterOpenCamera();
            uri = cameraUri;
        }else if(requestCode == REQ_CHOOSE){
            uri = afterChosePic(intent);
        }
        mUploadMessage.onReceiveValue(uri);
        mUploadMessage = null;
        super.onActivityResult(requestCode, resultCode, intent);
    }

    public boolean onKeyDown(int keyCode, KeyEvent event) {
        if ((keyCode == KeyEvent.KEYCODE_BACK) &amp;&amp; mWebView.canGoBack()) {  
            mWebView.goBack();  
            return true;  
        }else{
                finish();
        }
        return super.onKeyDown(keyCode, event);  
        }
}
</code></pre><p>根据这个哥们的代码进行精简,符合自己的需求,而且发现了这个代码的一个问题,没有能够进行判空操作,如果没有选择图片,直接返回APP会奔溃!</p>
<p>下面是我的开发源码:</p>
<pre><code>private class MyWebChromeClient extends WebChromeClient {


        // For Android 5.0+
        public boolean onShowFileChooser(WebView webView, ValueCallback&lt;Uri[]&gt; filePathCallback, WebChromeClient.FileChooserParams fileChooserParams) {
            mUploadCallbackAboveL = filePathCallback;
//            Intent i = new Intent(Intent.ACTION_GET_CONTENT);
//            i.addCategory(Intent.CATEGORY_OPENABLE);
//            i.setType(&quot;*/*&quot;);
//            HomePageViewActivity.this.startActivityForResult(
//                    Intent.createChooser(i, &quot;File Browser&quot;),
//                    FILECHOOSER_RESULTCODE);
            selectImage();
            return true;
        }


        //For Android 3.0+
        public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg, String acceptType) {
            if (mUploadMessage != null) return;
            mUploadMessage = uploadMsg;
            selectImage();
        }

        // For Android &lt; 3.0
        public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg) {
            if (mUploadMessage != null) return;
            mUploadMessage = uploadMsg;
            selectImage();
        }

        // For Android  &gt; 4.1.1
        public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg, String acceptType, String capture) {
            if (mUploadMessage != null) return;
            mUploadMessage = uploadMsg;
            selectImage();
        }


    }


    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        if (requestCode == FILECHOOSER_RESULTCODE) {
            if (null == mUploadMessage &amp;&amp; null == mUploadCallbackAboveL) return;
            Uri result = data == null || resultCode != RESULT_OK ? null : data.getData();
            if (mUploadCallbackAboveL != null) {
                onActivityResultAboveL(requestCode, resultCode, data);
            } else if (mUploadMessage != null) {
                mUploadMessage.onReceiveValue(result);
                mUploadMessage = null;
            }
        }


        if (null == mUploadMessage)
            return;
        Uri uri = null;
        if (requestCode == REQ_CHOOSE) {
            uri = afterChosePic(data);
        }
        mUploadMessage.onReceiveValue(uri);
        mUploadMessage = null;
        super.onActivityResult(requestCode, resultCode, data);
    }


    @TargetApi(Build.VERSION_CODES.LOLLIPOP)
    private void onActivityResultAboveL(int requestCode, int resultCode, Intent data) {
        if (requestCode != FILECHOOSER_RESULTCODE
                || mUploadCallbackAboveL == null) {
            return;
        }

        Uri[] results = null;
        if (resultCode == Activity.RESULT_OK) {
            if (data == null) {

            } else {
                String dataString = data.getDataString();
                ClipData clipData = data.getClipData();

                if (clipData != null) {
                    results = new Uri[clipData.getItemCount()];
                    for (int i = 0; i &lt; clipData.getItemCount(); i++) {
                        ClipData.Item item = clipData.getItemAt(i);
                        results[i] = item.getUri();
                    }
                }

                if (dataString != null)
                    results = new Uri[]{Uri.parse(dataString)};
            }
        }
        mUploadCallbackAboveL.onReceiveValue(results);
        mUploadCallbackAboveL = null;
        return;
    }


    /**
     * 检查SD卡是否存在
     *
     * @return
     */
    public final boolean checkSDcard() {
        boolean flag = Environment.getExternalStorageState().equals(
                Environment.MEDIA_MOUNTED);
        if (!flag) {
            Toast.makeText(this, &quot;请插入手机存储卡再使用本功能&quot;, Toast.LENGTH_SHORT).show();
        }
        return flag;
    }

    String compressPath = &quot;&quot;;

    protected final void selectImage() {
        if (!checkSDcard())
            return;

        chosePic();
        compressPath = Environment
                .getExternalStorageDirectory()
                .getPath()
                + &quot;/fuiou_wmp/temp&quot;;
        new File(compressPath).mkdirs();
        compressPath = compressPath + File.separator
                + &quot;compress.jpg&quot;;
    }


    /**
     * 本地相册选择图片
     */
    private void chosePic() {
        FileUtils.delFile(compressPath);
        Intent innerIntent = new Intent(Intent.ACTION_GET_CONTENT); // &quot;android.intent.action.GET_CONTENT&quot;
        String IMAGE_UNSPECIFIED = &quot;image/*&quot;;
        innerIntent.setType(IMAGE_UNSPECIFIED); // 查看类型
        Intent wrapperIntent = Intent.createChooser(innerIntent, null);
        startActivityForResult(wrapperIntent, REQ_CHOOSE);
    }

    /**
     * 选择照片后结束
     *
     * @param data
     */
    private Uri afterChosePic(Intent data) {

        if (data != null) {
            // 获取图片的路径：
            String[] proj = {MediaStore.Images.Media.DATA};
            // 好像是android多媒体数据库的封装接口，具体的看Android文档
            Cursor cursor = managedQuery(data.getData(), proj, null, null, null);
//        if (cursor == null) {
//            Toast.makeText(this, &quot;上传的图片仅支持png或jpg格式&quot;, Toast.LENGTH_SHORT).show();
//            return null;
//        }
            // 按我个人理解 这个是获得用户选择的图片的索引值
            int column_index = cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DATA);
            // 将光标移至开头 ，这个很重要，不小心很容易引起越界
            cursor.moveToFirst();
            // 最后根据索引值获取图片路径
            String path = cursor.getString(column_index);
//            if (path != null &amp;&amp; (path.endsWith(&quot;.png&quot;) || path.endsWith(&quot;.PNG&quot;) || path.endsWith(&quot;.jpg&quot;) || path.endsWith(&quot;.JPG&quot;))) {
//            } else {
//                Toast.makeText(this, &quot;上传的图片仅支持png或jpg格式&quot;, Toast.LENGTH_SHORT).show();
//            }
            File newFile = FileUtils.compressFile(path, compressPath);
            return Uri.fromFile(newFile);
        }
        return null;
    }
</code></pre><p>都目前位置 问题得到完美的解决!!</p>
<p>参考:<a href="http://blog.isming.me/2015/12/21/android-webview-upload-file/" target="_blank" rel="external">http://blog.isming.me/2015/12/21/android-webview-upload-file/</a><br><a href="http://www.huochai.mobi/p/d/900504/?share_tid=846ea82e2685&amp;fmid=0" target="_blank" rel="external">http://www.huochai.mobi/p/d/900504/?share_tid=846ea82e2685&amp;fmid=0</a><br><a href="http://www.lai18.com/content/1191983.html" target="_blank" rel="external">http://www.lai18.com/content/1191983.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>要说Android中最厉害的组件莫过于Webview 了，夸张点说把这个组件放在屏幕上就可以算作一个简单地浏览器应用了。但你若认为这就万事大吉了，可太小看Webview这个磨人的妖精了，下面单就上传文件的这个坑来做展开。</p>
</blockquote>]]>
    
    </summary>
    
      <category term="Webview" scheme="http://yoursite.com/tags/Webview/"/>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android源码编译和内核编译]]></title>
    <link href="http://yoursite.com/2016/02/21/Android%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/"/>
    <id>http://yoursite.com/2016/02/21/Android源码编译/</id>
    <published>2016-02-21T06:33:45.000Z</published>
    <updated>2016-02-26T07:27:49.473Z</updated>
    <content type="html"><![CDATA[<h2 id="u6E90_u7801_u7F16_u8BD1"><a href="#u6E90_u7801_u7F16_u8BD1" class="headerlink" title="源码编译"></a>源码编译</h2><h4 id="1_u3001_u7CFB_u7EDF_uFF1A_Ubuntu14-04_u4EE5_u4E0A__u6216_u8005_Mac"><a href="#1_u3001_u7CFB_u7EDF_uFF1A_Ubuntu14-04_u4EE5_u4E0A__u6216_u8005_Mac" class="headerlink" title="1、系统： Ubuntu14.04以上 或者 Mac"></a>1、系统： Ubuntu14.04以上 或者 Mac</h4><blockquote>
<p>下面的介绍都是在ubuntu下进行的</p>
</blockquote>
<h4 id="2_u3001JdK_u5B89_u88C5"><a href="#2_u3001JdK_u5B89_u88C5" class="headerlink" title="2、JdK安装"></a>2、JdK安装</h4><pre><code>$ sudo add-apt-repository &quot;deb http://archive.canonical.com/ lucid partner&quot;
$ sudo apt-get update
$ sudo apt-get install sun-java8-jdk
</code></pre><a id="more"></a> 
<h4 id="3_u3001_u5FC5_u5907_u8F6F_u4EF6_u5305_u5B89_u88C5"><a href="#3_u3001_u5FC5_u5907_u8F6F_u4EF6_u5305_u5B89_u88C5" class="headerlink" title="3、必备软件包安装"></a>3、必备软件包安装</h4><pre><code>$ sudo apt-get install git-core gnupg flex bison gperf build-essential \
  zip curl zlib1g-dev libc6-dev lib32ncurses5-dev ia32-libs \
  x11proto-core-dev libx11-dev lib32readline5-dev lib32z-dev \
  libgl1-mesa-dev g++-multilib mingw32 tofrodos python-markdown \
  libxml2-utils
</code></pre><h4 id="uFF14__u4E0B_u8F7Drepo_u5DE5_u5177"><a href="#uFF14__u4E0B_u8F7Drepo_u5DE5_u5177" class="headerlink" title="４　下载repo工具"></a>４　下载repo工具</h4><pre><code>$ cd ~
$ mkdir ~/bin
$ PATH=~/bin:$PATH
$ curl https://dl-ssl.google.com/dl/googlesource/git-repo/repo &gt; ~/bin/repo
$ chmod a+x ~/bin/repo
</code></pre><h4 id="uFF15__u4E0B_u8F7D_u6E90_u7801"><a href="#uFF15__u4E0B_u8F7D_u6E90_u7801" class="headerlink" title="５　下载源码"></a>５　下载源码</h4><blockquote>
<p>注意，下面最后一条命令，-b 后面的 Gingerbread 可以替换成 IceCreamSandwich 或者是 Froyo 中的任何一个。当然，还有其它选择，这个名字，就是 Android 版本的英文名，<a href="http://source.android.com/source/build-numbers.html" target="_blank" rel="external">http://source.android.com/source/build-numbers.html</a> 里面有所有的名字</p>
</blockquote>
<pre><code>$ mkdir CMROM
$ cd CMROM
$ repo init -u git://github.com/CyanogenMod/android.git
</code></pre><blockquote>
<p>如果是使用Google官方的源码编译</p>
</blockquote>
<pre><code>$ repo init -u https://android.googlesource.com/platform/manifest -b [Gingerbread]

[?]部分是Android的版本名称--详见http://source.android.com/source/build-numbers.html
</code></pre><ul>
<li>注意事项</li>
</ul>
<blockquote>
<p>默认情况下，访问Android源码是匿名的，为了防止下载服务器压力过大，下载服务器对每个ip都有下载限制。如果和别人共享一个公网IP(和别人共享路由器时，便是如此),Android源码服务器便会阻止多人同时下载，容易报错。为了解决该问题，需要使用带授权的访问，源码服务器此时对用户进行限制，而不是对ip进行限制。方法如下：<br>先创建密码：<a href="https://android.googlesource.com/new-password" target="_blank" rel="external">https://android.googlesource.com/new-password</a><br>该地址也经常无法访问，需多次尝试(可相隔几分钟)，若使用代理，就没法获得有用的密钥<br>再将密码保存在~/.netrc里<br>然后强制使用带授权的访问：<br> $repo init -u <a href="https://android.googlesource.com/a/platform/manifest" target="_blank" rel="external">https://android.googlesource.com/a/platform/manifest</a><br>在国内用repo初始化时，会经常遇到101的错误，因为有墙的原因，重试多次，运气好时便可以完成，设置代理的话会更顺利一点</p>
</blockquote>
<ul>
<li><p>源代码的目录结构</p>
<p>  在讲述Android源码编译的三个步骤之前，将先介绍Android源码目录结构，以便读者理清Android编译系统核心代码在Android源代码的位置。<br>Android源代码顶层目录结构如下所示：</p>
<p>../CyanogenMod/</p>
<pre><code>├──abi#应用二进制接口，不同的操作系统，应用二进制接口不同，因此linux上的二进制可执行文件在windows上无法执行
├──android#存放了一些xml文件，用于描述工程路径及其对应的远程仓库地址，repo工具将使用这些信息同步代码
├──bionic#bionic C库,Android没有使用标准的glibc库，而是自己重新实现了一套c/C++库，包括libc libdl libm libstdc++ libthread_db
├──bootable# 包含两个工程，recovery和diskinstaller，刷机或者系统升级都是由recovery完成的，
├──build#Android编译系统核心代码都存放在该目录，我们也将对该目录下的文件做详细分析
├──cts#Android兼容性测试套件标准
├──dalvik#dalvik JAVA虚拟机，Android用的java虚拟机和pc上用的jvm不一样
├──development#应用程序开发工具 有eclipse开发用的formatter配置
├──device#设备相关配置文件，存放规则 device/$vendor/$product
├──docs#网站文档
├──external#用到的第三方库 象busybox bash openssl等工具都存放在该目录
├──filelist#使用godir命令生成的索引文件
├──frameworks#核心框架——java及C++语言，可生成framework.jar
├──gdk#glass开发Sdk
├──hardware#部分厂家开源的硬件适配层HAL代码
├──kernel#内核源码目录 存放规则kernel/$vendor/$product
├──libcore#一些有用的库 像xml Jason luni
├──libnativehelper#Support functions for Android’s class libraries
├──Makefile#在顶层目录编译，利用的默认Makefile，它只是简单包含了build/core/main.mk
├──ndk#ndk开发工具
├──packages#Android apk程序所在目录,象settings，gallery等程序
├──pdk#Platform Development Kit The goal of the PDK release is to help chipset vendors and OEMs to migrate to a new relelase
├──prebuilt#x86和arm架构下预编译的一些资源
├──prebuilts#有clang eclipse gcc misc ndk qemu-kernel sdk tools等子目录，交叉编译工具链所在目录
├──sdk#sdk及模拟器
├──system#核心代码，包含了最小化可启动的环境，还有底层调试及检查工具，adbd也在system/core目录
├──tools#有子目录build和motodev，可能跟摩托罗拉有关
├──vendor#设备制造商专用的配置存放目录，存放规则vendor/$vendor/$product，cm编写的apk也放在该目录
</code></pre><p>build子目录存放编译系统的核心代码，包含着138个makefile，15个shell脚本，19个python脚本，7个C文件，7个C++文件，16个头文件，因此如果想分析编译系统核心代码，使用的IDE需支持这些编程语言，推荐使用eclipse，安装一些插件就可以很方便地查看这些代码<br>build子文件夹的目录结构如下所示：<br>build/</p>
<pre><code>├── buildspec.mk.default#buildspec的模版文件，可定义一些变量比如TARGET_BUILD_VARIANT:=user，TARGET_BUILD_TYPE:=release
├── CleanSpec.mk#增量编译时，会执行该文件里的命令，这些命令一般用于清除中间文件
├── core#编译系统的核心文件放在该目录，主要是一些makefile
├── envsetup.sh#编译时需先用source envsetup.sh设置好环境变量，该脚本提供了许多有用的命令，比如cout,croot,cgrep,在详细介绍Android编译步骤时会列出来
├── libs#是一个C++模块，编译后可生成libhost.a静态库，里面的函数主要用于与编译主机交互
├── target#包含编译目标相关的makefile，它有两个子文件夹 board和product，产品都在该目录下定义，比如generic,full产品，定义设备产品时，会从这里继承产品
└── tools#各种工具，多数使用python编写，工具有用于签名的signpak, 用于下载device配置的roomservice.py等，后续将详细介绍
</code></pre><p>我们在阅读build核心代码时，可能最头疼的就是变量，编译系统里有成百上千的变量，我们常常不知道其含义，容易一头雾水，为此我做了一个编译系统的参考手册供大家查阅， 可以很方便地检索变量，查看变量的意义，并有示例值。链接：<a href="http://android.cloudchou.com/" target="_blank" rel="external">http://android.cloudchou.com/</a></p>
</li>
</ul>
<h4 id="uFF16__u540C_u6B65_u6E90_u7801"><a href="#uFF16__u540C_u6B65_u6E90_u7801" class="headerlink" title="６　同步源码"></a>６　同步源码</h4><blockquote>
<p>别看只有一条命令，但是，下载的时间，很长的，推荐这条命令，晚上的时候，挂机执行，第二天早上，差不多能下载完。毕竟是 3GB 多的东西呢。</p>
</blockquote>
<pre><code>$ repo sync -j 10
</code></pre><ul>
<li>注意事项<blockquote>
<p>在工作目录里使用repo sync同步代码，期间可能会多次卡死，需要ctrl+z，然后杀掉进程，然后再次使用repo sync，因为其支持断点续传，不需要担心会从头开始下载 还可以开启多个进程同时下载，使用repo sync -j4<br>j4代表开启4个线程,建议i5以上的开4,i7开8</p>
</blockquote>
</li>
</ul>
<h4 id="4-_u7F16_u8BD1_u6E90_u4EE3_u7801"><a href="#4-_u7F16_u8BD1_u6E90_u4EE3_u7801" class="headerlink" title="4.编译源代码"></a>4.编译源代码</h4><ul>
<li><p>初始化编译环境</p>
<pre><code>$source build/envsetup.sh
</code></pre></li>
</ul>
<ul>
<li><p>选择一个目标设备，以cm下编译htc one为例</p>
<pre><code>$lunch cm_m7ul-eng
</code></pre></li>
<li><p>此时会从网站下载m7ul的device配置以及内核源代码<br>所有目标设备的格式为BUILD-BUILDTYPE， BUILD是选择的目标设备，比如cm_m7,而BUILD_TYPE是eng，user或者userdebug</p>
<pre><code>user: 适合发布产品时使用，访问受限
userdebug: 和user类型类似，有root权限和调试能力，适合调试
eng: 开发配置，有额外的调试工具
</code></pre></li>
<li><p>编译源代码：</p>
<pre><code>$mka
</code></pre></li>
</ul>
<h2 id="u5185_u6838_u7F16_u8BD1"><a href="#u5185_u6838_u7F16_u8BD1" class="headerlink" title="内核编译"></a>内核编译</h2><h4 id="uFF11__u4E0B_u8F7D_u5185_u6838_u6E90_u7801"><a href="#uFF11__u4E0B_u8F7D_u5185_u6838_u6E90_u7801" class="headerlink" title="１　下载内核源码"></a>１　下载内核源码</h4><p>　　每一个 Android 手机厂商，都会在自己的网站上公布已经生产的手机的内核源码，大家去小米手机的官方网站下载即可。</p>
<h4 id="uFF12__u89E3_u538B_u5185_u6838_u6E90_u7801_u5305"><a href="#uFF12__u89E3_u538B_u5185_u6838_u6E90_u7801_u5305" class="headerlink" title="２　解压内核源码包"></a>２　解压内核源码包</h4><p>　　内核源码，一般是以压缩包的形式提供下载的。大家下载之后，在 Ubuntu 中解压即可，因为命令非常简单，这里不提供。</p>
<h4 id="uFF13__u914D_u7F6E_u4EA4_u53C9_u5DE5_u5177_u94FE_uFF08_u7F16_u8BD1_u5668_uFF09_u8DEF_u5F84"><a href="#uFF13__u914D_u7F6E_u4EA4_u53C9_u5DE5_u5177_u94FE_uFF08_u7F16_u8BD1_u5668_uFF09_u8DEF_u5F84" class="headerlink" title="３　配置交叉工具链（编译器）路径"></a>３　配置交叉工具链（编译器）路径</h4><p>　　学过编程的人都知道，源码要编译成程序，必须要用编译器编译。而且手机的 CPU 不同于 PC 机，所以，得用专用的工具，即“交叉工具链”。<br>　　打开内核源码目录下的 Makefile 文件，找到“CROSS_COMPILE”定义的地方，确保和下面一模一样。</p>
<pre><code>CROSS_COMPILE := $(shell if [ -f .cross_compile ]; then \
    cat .cross_compile; \
    fi)
</code></pre><p>　　接着，在内核源码目录下面，新建一个叫“.cross_compile”的文件，在文件中，输入以下分隔线中间的一行内容</p>
<pre><code>/（这前面，是 Android 源码的绝对路径，要求您有一点 Ubuntu 使用经验，否则不能完成）/ANDROID_SRC/prebuilt/linux-x86/toolchain/arm-eabi-4.4.0/bin/arm-eabi-
</code></pre><p>　　打开已经下载的 Android 源码（前面有提到如何下载）目录，在 ANDROID_SRC/prebuilt/linux-x86/toolchain 下面，你会发现有几个工具链文件夹，名字为别是 arm-eabi-4.2.1（4.3.1，4.4.0，4.4.3），如果，你是用 64位 系统，用哪个都可以。如果是 32位 系统，貌似用 4.4.3 会出错。建议用 4.4.0。<br>　注：ANDROID_SRC 是指您电脑上，Android 源码存储的目录，请根据实际情况，进行替换。</p>
<h4 id="uFF14__u201C-config_u201D_u914D_u7F6E_u6587_u4EF6"><a href="#uFF14__u201C-config_u201D_u914D_u7F6E_u6587_u4EF6" class="headerlink" title="４　“.config”配置文件"></a>４　“.config”配置文件</h4><p>　　在内核源码的目录下面，一定要有一个名字为“.config”的文件，这个文件，是小米手机的内核配置。如果内核源码的根目录下，没有发现这个文件，或者，发现的文件不是针对小米手机配置的，在 LINUX_SRC/arch/arm/configs 下面，找到针对小米手机的配置文件，复制到内核源码根目录，即可。<br>　注：LINUX_SRC 是指您电脑上，内核源码存储的目录，请根据实际情况，进行替换。</p>
<h4 id="uFF15__u9009_u62E9_u5185_u6838_u914D_u7F6E_u9009_u9879"><a href="#uFF15__u9009_u62E9_u5185_u6838_u914D_u7F6E_u9009_u9879" class="headerlink" title="５　选择内核配置选项"></a>５　选择内核配置选项</h4><pre><code>$ cd LINUX_SRC
$ make config
</code></pre><p>这里的config文件,是在内核源码根目录下的 config文件,如果没有直接名称为config文件的,看看是否有前缀,例如:menuconfig<br>　　输入上面的命令后，会出现一个怪怪的列表，通过按“空格键”，进行“选择”或“取消”某些选项。完成后，记得保存。<br>　注：在手机使用中，有的用户总抱怨不能使用“Wifi Tether”，不能“使用笔记本共享出来的宽带上网”，都是因为这一步，内核的选项没有被正确设置。读完这篇文章之后，大家可以自己动手了。</p>
<h4 id="uFF16__u201C_u6700_u540E_u4E00_u6B65_u201D"><a href="#uFF16__u201C_u6700_u540E_u4E00_u6B65_u201D" class="headerlink" title="６　“最后一步”"></a>６　“最后一步”</h4><pre><code>$ cd LINUX_SRC
$ make
</code></pre><p>　编译完成之后，会在“kernel/goldfish/arch/arm/boot/”目录下生成名为zImage的文件。 </p>
<h2 id="u7528_u5230_u7684_u547D_u4EE4"><a href="#u7528_u5230_u7684_u547D_u4EE4" class="headerlink" title="用到的命令"></a>用到的命令</h2><h4 id="u4E0B_u8F7DAndroid_u6E90_u7801_u7B80_u8981_u6D41_u7A0B"><a href="#u4E0B_u8F7DAndroid_u6E90_u7801_u7B80_u8981_u6D41_u7A0B" class="headerlink" title="下载Android源码简要流程"></a>下载Android源码简要流程</h4><pre><code>a. 获取repo文件: curl http://commondatastorage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo .注意执行该文件需要python2.5以上版本,如果是2.4.3的python版本就无法执行这个文件脚本;
b. 修改repo权限 : chmod a+x ~/bin/repo , 如果repo没有执行权限, 该脚本也无法执行;
c. 初始化repo文件 : repo init -u https://android.googlesource.com/platform/manifest -b android-2.3.3_r1 , 这里要下载2.3.3版本的源码;
d. 开始下载 :repo sync , 执行该命令就可以开始下载Android源码;
</code></pre><h4 id="u4E0B_u8F7DAndroid_u5185_u6838_u6E90_u7801_u7B80_u8981_u6D41_u7A0B"><a href="#u4E0B_u8F7DAndroid_u5185_u6838_u6E90_u7801_u7B80_u8981_u6D41_u7A0B" class="headerlink" title="下载Android内核源码简要流程"></a>下载Android内核源码简要流程</h4><pre><code>a. 使用git下载 : git clone https://android.googlesource.com/kernel/goldfish.git ;
b. 查看分支 : git branch -a ;
c. 检出版本 : git checkout remotes/origin/android-goldfish-2.6.29 ;
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u6E90_u7801_u7F16_u8BD1"><a href="#u6E90_u7801_u7F16_u8BD1" class="headerlink" title="源码编译"></a>源码编译</h2><h4 id="1_u3001_u7CFB_u7EDF_uFF1A_Ubuntu14-04_u4EE5_u4E0A__u6216_u8005_Mac"><a href="#1_u3001_u7CFB_u7EDF_uFF1A_Ubuntu14-04_u4EE5_u4E0A__u6216_u8005_Mac" class="headerlink" title="1、系统： Ubuntu14.04以上 或者 Mac"></a>1、系统： Ubuntu14.04以上 或者 Mac</h4><blockquote>
<p>下面的介绍都是在ubuntu下进行的</p>
</blockquote>
<h4 id="2_u3001JdK_u5B89_u88C5"><a href="#2_u3001JdK_u5B89_u88C5" class="headerlink" title="2、JdK安装"></a>2、JdK安装</h4><pre><code>$ sudo add-apt-repository &quot;deb http://archive.canonical.com/ lucid partner&quot;
$ sudo apt-get update
$ sudo apt-get install sun-java8-jdk
</code></pre>]]>
    
    </summary>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Kotlin 1.0 正式版发布啦]]></title>
    <link href="http://yoursite.com/2016/02/18/Kotlin1.0%E6%AD%A3%E5%BC%8F%E7%89%88%E5%8F%91%E5%B8%83/"/>
    <id>http://yoursite.com/2016/02/18/Kotlin1.0正式版发布/</id>
    <published>2016-02-18T15:01:14.000Z</published>
    <updated>2016-02-19T09:12:40.579Z</updated>
    <content type="html"><![CDATA[<p><code>就在昨天，Android领域的Swift--Kotlin 1.0发布了，详细的新版本发布介绍请「阅读原文」查看官方发行说明。</code></p>
<h3 id="u4F55_u4E3AKotlin_uFF1F"><a href="#u4F55_u4E3AKotlin_uFF1F" class="headerlink" title="何为Kotlin？"></a>何为Kotlin？</h3><p><code>Kotlin 是一门实用的编程语言，可用于 JVM 和 Android 程序开发，Kotlin 结合了面向对象和函数式特性，致力于互操作性，安全，简洁和工具支持。</code><br><a id="more"></a><br><code>Kotlin 是一门通用的语言，只要能用 Java 的地方就能用 Kotlin，包含：服务器程序开发，移动应用开发（Android），桌面客户端程序开发。 Kotlin 支持所有主要的开发工具以及服务，比如：</code></p>
<pre><code>IntelliJ IDEA，Android Studio 和 Eclipse
Maven, Gradle 和Ant
Spring Boot（Kotlin 支持今天正式发布！）
GitHub，Slack，甚至 Minecraft
</code></pre><p><code>Kotlin 的主要特点之一是Java+Kotlin 混合工程的互操作性以及无缝兼容，使引入Kotlin的过程简单容易，并达成更少的重复性代码(boilerplate code)和更佳的类型安全(type-safety)。</code><br><code>Kotlin 还有一个扩展标准库(extensive standard library)能让日常工作变得简单顺畅，它能帮助保持低内存占用 (bytecode footprint)。当然，Kotlin 中自然可以使用 Java 库，反之亦然。</code></p>
<h3 id="u4E3A_u4F55_u8BF4Kotlin_u975E_u5E38_u9002_u5408_u4E8EAndroid_uFF1F"><a href="#u4E3A_u4F55_u8BF4Kotlin_u975E_u5E38_u9002_u5408_u4E8EAndroid_uFF1F" class="headerlink" title="为何说Kotlin非常适合于Android？"></a>为何说Kotlin非常适合于Android？</h3><p><code>基本上，这是因为Kotlin的所有特性都非常适合于Android生态圈。Kotlin的库非常小，我们在开发过程中不会引入额外的成本。其大小 相当于support-v4库，我们在很多项目中所使用的库都比Kotlin大。除此之外，Android Studio（官方的Android IDE）是基于IntelliJ构建的。这意味着我们的IDE对该语言提供了非常棒的支持。我们可以很快就配置好项目，并且使用熟悉的IDE进行开发。我 们可以继续使用Gradle以及IDE所提供的各种运行与调试特性。这与使用Java开发应用别无二致。归功于互操作性，我们可以在Kotlin代码中使 用Android SDK而不会遇到任何问题。实际上，部分SDK使用起来会变得更加简单，这是因为互操作性是非常智能的，比如说它可以将getters与setters映 射到Kotlin属性上，我们也可以以闭包的形式编写监听器。</code></p>
<h3 id="u5982_u4F55_u5728Android_u5F00_u53D1_u4E2D_u4F7F_u7528Kotlin_uFF1F"><a href="#u5982_u4F55_u5728Android_u5F00_u53D1_u4E2D_u4F7F_u7528Kotlin_uFF1F" class="headerlink" title="如何在Android开发中使用Kotlin？"></a>如何在Android开发中使用Kotlin？</h3><p><code>过程非常简单，只需按照下面的步骤来即可：</code></p>
<blockquote>
<p>从IDE plugins中下载Kotlin插件<br>在模块中创建Kotlin类<br>使用“Configure Kotlin in Project…”<br>开始编码</p>
</blockquote>
<h3 id="Kotlin_u7684_u4E00_u4E9B_u7279_u6027"><a href="#Kotlin_u7684_u4E00_u4E9B_u7279_u6027" class="headerlink" title="Kotlin的一些特性"></a>Kotlin的一些特性</h3><p><code>Kotlin拥有大量非常打动人心的特性，这里无法一一进行介绍，不过我们来看一下其中最为重要的一些。</code></p>
<h4 id="Null_u5B89_u5168"><a href="#Null_u5B89_u5168" class="headerlink" title="Null安全"></a>Null安全</h4><p><code>如前所述，Kotlin是null安全的。如果一个类型可能为null，那么我们就需要在类型后面加上一个?。这样，每次在使用该类型的变量时，我们都需要进行null检查。比如说，如下代码将无法编译通过：</code></p>
<pre><code>var artist: Artist? = null?
artist.print()
</code></pre><p><code>第2行会显示一个错误，因为没有对变量进行null检查。我们可以这样做：</code></p>
<pre><code>if (artist != null) {
?    artist.print()?
}
</code></pre><p><code>这展示了Kotlin另一个出色的特性：智能类型转换。如果检查了变量的类型，那就无需在检查作用域中对其进行类型转换。这样，我们现在就可以在 if中将artist作为Artist类型的变量了。这对于其他检查也是适用的。还有一种更简单的方式来检查null，即在调用对象的函数前使用?。甚至 还可以通过Elvis运算符?提供另外一种做法：</code></p>
<pre><code>val name = artist?.name ?: &quot;&quot;
</code></pre><h4 id="u6570_u636E_u7C7B"><a href="#u6570_u636E_u7C7B" class="headerlink" title="数据类"></a>数据类</h4><p><code>在Java中，如果想要创建数据类或是POJO类（只保存了一些状态的类），我们需要创建一个拥有大量字段、getters与setters的类，也许还要提供toString与equals方法：</code></p>
<pre><code>public class Artist {
    private long id;
    private String name;
    private String url;
    private String mbid;

    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getUrl() {
        return url;
    }

    public void setUrl(String url) {
        this.url = url;
    }

    public String getMbid() {
        return mbid;
    }

    public void setMbid(String mbid) {
        this.mbid = mbid;
    }

    @Override
    public String toString() {
        return &quot;Artist{&quot; +
                &quot;id=&quot; + id +
                &quot;, name=&apos;&quot; + name + &apos;\&apos;&apos; +
                &quot;, url=&apos;&quot; + url + &apos;\&apos;&apos; +
                &quot;, mbid=&apos;&quot; + mbid + &apos;\&apos;&apos; +
                &apos;}&apos;;
    }
}
</code></pre><p><code>在Kotlin中，上述代码可以写成下面这样：</code></p>
<pre><code>data class Artist (?
    var id: Long,
    var name: String,
    var url: String,
    var mbid: String)
</code></pre><p><code>Kotlin使用属性而非字段。基本上，属性就是字段加上其getter与setter。</code></p>
<h4 id="u4E92_u64CD_u4F5C"><a href="#u4E92_u64CD_u4F5C" class="headerlink" title="互操作"></a>互操作</h4><p><code>Kotlin提供了一些非常棒的互操作特性，这对于Android开发帮助非常大。其中之一就是拥有单个方法的接口与lambda表达式之间的映射。这样，下面这个单击监听器：</code></p>
<pre><code>view.setOnClickListener(object : View.OnClickListener {
    override fun onClick(v: View) {
        toast(&quot;Click&quot;)?
    }
?})
</code></pre><p><code>可以写成这样：</code></p>
<pre><code>view.setOnClickListener { toast(&quot;Click&quot;) }
</code></pre><p><code>此外，getters与setters都会自动映射到属性上。这并不会造成性能上的损失，因为字节码实际上只是调用原来的getters与setters。如下代码所示：</code></p>
<pre><code>supportActionBar.title = title
textView.text = title
contactsList.adapter = ContactsAdapter()
</code></pre><p>####Lambda表达式</p>
<p><code>Lambda表达式会在极大程度上精简代码，不过重要的是借助于Lambda表达式，我们可以做到之前无法实现或是实现起来非常麻烦的事情。借助于 Lambda表达式，我们可以以一种更加函数式的方式来思考问题。Lambda表达式其实就是一种指定类型，并且该类型定义了一个函数的方式。比如说，我 们可以像下面这样定义一个变量：</code></p>
<pre><code>val listener: (View) -&gt; Boolean
</code></pre><p><code>该变量可以声明一个函数，它接收一个view并返回这个函数。我们需要通过闭包的方式来定义函数的行为：</code></p>
<pre><code>val listener = { view: View -&gt; view is TextView }
</code></pre><p><code>上面这个函数会接收一个View，如果该view是TextView的实例，那么它就会返回true。由于编译器可以推断出类型，因此我们无需指定。还可以更加明确一些：</code></p>
<pre><code>val listener: (View) -&gt; Boolean = { view -&gt; view is TextView }
</code></pre><p><code>借助于Lambda表达式，我们可以抛弃回调接口的使用。只需设置希望后面会被调用的函数即可：</code></p>
<pre><code>fun asyncOperation(value: Int, callback: (Boolean) -&gt; Unit) {
    ...
    callback(true)?
}

asyncOperation(5) { result -&gt; println(&quot;result: $result&quot;) }
</code></pre><p><code>还有一种更加简洁的方式，如果函数只接收一个参数，那就可以使用保留字it：</code></p>
<pre><code>asyncOperation(5) { println(&quot;result: $it&quot;) }
</code></pre><h4 id="Anko"><a href="#Anko" class="headerlink" title="Anko"></a>Anko</h4><p><code>Anko是Kotlin团队开发的一个库，旨在简化Android开发。其主要目标在于提供一个DSL，使用Kotlin代码来声明视图：</code></p>
<pre><code>verticalLayout {
    val name = editText()
    button(&quot;Say Hello&quot;) {
        onClick { toast(&quot;Hello, ${name.text}!&quot;) }
    }
}
</code></pre><p><code>它还提供了其他一些很有用的特性。比如说，导航到其他Activity：</code></p>
<pre><code>startActivity(&quot;id&quot; to res.id, &quot;name&quot; to res.name)
</code></pre><h3 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h3><p><code>如你所见，Kotlin在很多方面都简化了Android的开发工作。它会提升你的生产力，并且可以通过非常不同且更加简单的方式来解决一些常见的问题，你开始学习了么？</code></p>
<h3 id="u53C2_u8003_u8D44_u6599_uFF1A"><a href="#u53C2_u8003_u8D44_u6599_uFF1A" class="headerlink" title="参考资料："></a>参考资料：</h3><pre><code>1. http://www.infoq.com/cn/news/2016/01/kotlin-android?utm_campaign=infoq_content&amp;utm_source=infoq&amp;utm_medium=feed&amp;utm_term=global

2. http://www.oschina.net/news/70734/kotlin-1-0-final
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><code>就在昨天，Android领域的Swift--Kotlin 1.0发布了，详细的新版本发布介绍请「阅读原文」查看官方发行说明。</code></p>
<h3 id="u4F55_u4E3AKotlin_uFF1F"><a href="#u4F55_u4E3AKotlin_uFF1F" class="headerlink" title="何为Kotlin？"></a>何为Kotlin？</h3><p><code>Kotlin 是一门实用的编程语言，可用于 JVM 和 Android 程序开发，Kotlin 结合了面向对象和函数式特性，致力于互操作性，安全，简洁和工具支持。</code><br>]]>
    
    </summary>
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Ibeacon]]></title>
    <link href="http://yoursite.com/2016/01/25/Ibeacon/"/>
    <id>http://yoursite.com/2016/01/25/Ibeacon/</id>
    <published>2016-01-25T04:01:14.000Z</published>
    <updated>2016-02-19T09:12:16.473Z</updated>
    <content type="html"><![CDATA[<h3 id="u662F_u4EC0_u4E48_uFF1F"><a href="#u662F_u4EC0_u4E48_uFF1F" class="headerlink" title="是什么？"></a>是什么？</h3><p>iBeacon是apple公司提出的“一种可以让附近手持电子设备检测到的一种新的低功耗、低成本信号传送器”的一套可用于室内定位系统的协议。 这种技术可以使一个智能手机或其他装置在一个iBeacon基站的感应范围内执行相应的命令。</p>
<p>这是帮助智能手机确定他们大概位置或环境的一个应用程序。在一个iBeacon基站的帮助下，智能手机的软件能大概找到它和这个iBeacon基站的相对位置。iBeacon能让手机收到附近售卖商品的通知，也可以让消费者不用拿出钱包或信用卡就能在销售点的POS机上完成支付。iBeacon技术通过低功耗蓝牙（BLE），也就是我们所说的智能蓝牙来实现。</p>
<p>iBeacon为利用低功耗蓝牙可以近距离感测的功能来传输通用唯一识别码的一个app或操作系统。 这个识别码可以在网上被查找到用以确定设备的物理位置或者可以在设备上触发一个动作比如在社交媒体签到或者推送通知。</p>
<p>各种供应商创造了不同形式的iBeacon硬件设备，包括小硬币电池设备，随身碟和蓝牙4.0通用加密狗。<br><a id="more"></a></p>
<h3 id="u529F_u80FD"><a href="#u529F_u80FD" class="headerlink" title="功能"></a>功能</h3><p>一套iBeacon的部署由一个或多个在一定范围内发射传输他们唯一的识别码iBeacon信标设备组成。接收设备上的软件可以查找iBeacon并实现多种功能，比如通知用户，接收设备也可以通过链接iBeacons从iBeacon的通用属性配置服务来恢复价值。iBeacons不推送通知给接收设备（除了他们自己的ID），然而，手机软件可以使用从iBeacons接收到的信号来自己推送通知。</p>
<h3 id="u533A_u57DF_u76D1_u6D4B"><a href="#u533A_u57DF_u76D1_u6D4B" class="headerlink" title="区域监测"></a>区域监测</h3><p>区域监测仅限20个区域，可以在后台运行，即使app在后台运行或者手机锁屏，依然有不同的应用通知监听app（用户）进入/退出该区。区域监测也给了关闭的app一个反应的机会，在进入相关区域时允许弹出小窗口。</p>
<h3 id="u5206_u7C7B"><a href="#u5206_u7C7B" class="headerlink" title="分类"></a>分类</h3><p>分类工作仅应用在前端，但是将返回数组iBeacons的所有属性（UUID等）。</p>
<p>一个iOS设备接收一个iBeacon的传输可以近乎于iBeacon的距离，iBeacon的传输距离分为3个不同的范围：</p>
<p>最近：几厘米<br>中距：几米<br>远距：大于10米<br>当用户进入、退出或者在区域内徘徊时，iBeacon的广播有能力进行传播，根据用户和Beacon的距离，这三个距离范围可以相互交互。</p>
<p>iBeacon传输的最大射程将取决于位置、现场布置、障碍物(例如在一个皮革手袋或厚情况下)。标准信号有近似的70米，远程信号可达450米。</p>
<h3 id="u7535_u529B_u6D88_u8017"><a href="#u7535_u529B_u6D88_u8017" class="headerlink" title="电力消耗"></a>电力消耗</h3><p>Comparison of 16 major beacon hardware of battery life in months (higher is better) by Aislelabs’ The Hitchickers Guide to iBeacon Hardware[15]<br>低功耗蓝牙相比于传统蓝牙在功耗和效率方面有显著提高，在16个不同的iBeacon厂商的一项研究报告称，电池的寿命在1到24个月的范围之内。苹果公司，用一枚纽扣电池提供了1-3个月的生活，设置了100ms的广告频率，这样如果电池提供时间增加到2~3年就相当于广告频率增到到900ms。</p>
<p>在部署beacon启用手机app时，手机电池的消耗是一个必须要考虑的因素。最新的报告显示附近有ibeacon时，旧的手机会消耗更多的电量，然而新一点的手机在同样的环境下则更加高效。除了浏览手机消耗的时间，扫描附近的浏览量和信标数依然是电池消耗很重要的因素，正如Aislelabs指出的报告一样。在后续的报告中，Aislelabs发现了苹果5s，苹果5c和旧版的苹果4s在电池消耗方面的一个大幅的改善。在10个ibeacons的周围，苹果4s每小时消耗了11%的电量而苹果5s则每小时比它少消耗5%的电量。一个高效节能的ibeacon应用程序需要考虑这些方面去保持应用的响应性和电池消耗之间的平衡。</p>
<h3 id="u6700_u65B0_u8FDB_u5C55"><a href="#u6700_u65B0_u8FDB_u5C55" class="headerlink" title="最新进展"></a>最新进展</h3><p>2013年中苹果公司介绍了iBeacons，专家撰写了文章表示iBeacons怎样通过简化支付提供现场支持来帮助零售业。随着IOS7的推出，零售商和其他中小型企业将能够使用蓝牙4.0技术。据报道，2013年12月6日苹果在其254个零售店中使用了iBeacons。</p>
<p>2014年5月，花费最低5美金到30美金以上就可购买不同的iBeacons硬件设备。每一个不同的设备对自己的默认发射功率和广告频率都有不同的默认设置。一些硬件的广告频率可以快到每100毫秒一次而还有一些的可以低至1赫兹。 iBeacon技术还在襁褓期，有报道指出一个软件存在的异样，最新安卓系统的蓝牙堆栈在面对许多iBeacons时会崩溃。</p>
<h3 id="u517C_u5BB9_u8BBE_u5907"><a href="#u517C_u5BB9_u8BBE_u5907" class="headerlink" title="兼容设备"></a>兼容设备</h3><p>支持蓝牙4.0的IOS设备（iPhone4s及以上，iPad第三代及以上，iPad mini第一代及以上，iPod Touch第五代）。<br>支持OS X Mavericks 10.9操作系统和蓝牙4.0的苹果计算机。<br>安卓4.3及以上（如三星 Galaxy S3/S4/S4 Mini, 三星 Galaxy Note 2/3, HTC One, Google/LG Nexus 7 2013 version/Nexus 4/Nexus 5, HTC Butterfly, OnePlus One）<br>支持Lumia Cyan及以上更新服务Windows Phone设备（报告显示，不包含Windows Phone 8.1）</p>
<h3 id="u7F3A_u70B9"><a href="#u7F3A_u70B9" class="headerlink" title="缺点"></a>缺点</h3><p>iBeacon协议是开放的，且易于伪造，部署的节点可能被其他人恶意使用，甚至伪造一个ID完全相同的 Beacon，支付安全很难保证。该应用可以搜集用户的位置信息、行为信息，这些隐私信息的安全要如何保障尚待规范。</p>
<p>iBeacon太麻烦，对于用户来说手机上需要下载不同的 App 才能在不同的商场、地段体验，对于商户来说也没有一个通用、快捷的后台。</p>
<p>手机必须支持蓝牙4.0以上并保持蓝牙开启状态</p>
<p>iBeacons由于依赖于蓝牙技术，传输距离较大，而且通过基站传输数据，那么，如果基站被攻击，连接到基站的设备就很危险了。iBeacons是通过蓝牙实现的，一般来说两个设备建立连接都需要几秒甚至十几秒吧，操作也比较繁琐，这个对于用户来说体验就相对较差了。</p>
<p>在再室外环境 Beacon的信号特别不稳定，尤其是一大风，本来已经搜索到的Beacon瞬间就“风逝”了。<br>测距技术主要有三种：AoA（角测距）、RSSI（基于接收信号强度）和ToA（时间测距）。<br>低功耗蓝牙（即BLE）的测距主要是通过RSSI。虽然从一定程度上说RSSI只需较少的通信开销和较低的实现复杂度,这在能量有限的网络节点中是非常重要的。<br>同时它也有一个致命的缺点——过渡依赖环境。RSSI易受环境变化影响，从而只能是大致测距，想要提高精确度，需要至少三个Beacon，利用圆覆盖区重叠区域得到比较精确的距离。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u662F_u4EC0_u4E48_uFF1F"><a href="#u662F_u4EC0_u4E48_uFF1F" class="headerlink" title="是什么？"></a>是什么？</h3><p>iBeacon是apple公司提出的“一种可以让附近手持电子设备检测到的一种新的低功耗、低成本信号传送器”的一套可用于室内定位系统的协议。 这种技术可以使一个智能手机或其他装置在一个iBeacon基站的感应范围内执行相应的命令。</p>
<p>这是帮助智能手机确定他们大概位置或环境的一个应用程序。在一个iBeacon基站的帮助下，智能手机的软件能大概找到它和这个iBeacon基站的相对位置。iBeacon能让手机收到附近售卖商品的通知，也可以让消费者不用拿出钱包或信用卡就能在销售点的POS机上完成支付。iBeacon技术通过低功耗蓝牙（BLE），也就是我们所说的智能蓝牙来实现。</p>
<p>iBeacon为利用低功耗蓝牙可以近距离感测的功能来传输通用唯一识别码的一个app或操作系统。 这个识别码可以在网上被查找到用以确定设备的物理位置或者可以在设备上触发一个动作比如在社交媒体签到或者推送通知。</p>
<p>各种供应商创造了不同形式的iBeacon硬件设备，包括小硬币电池设备，随身碟和蓝牙4.0通用加密狗。<br>]]>
    
    </summary>
    
      <category term="Ibeacon" scheme="http://yoursite.com/tags/Ibeacon/"/>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[React-Native学习指南]]></title>
    <link href="http://yoursite.com/2015/12/19/React-Native%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2015/12/19/React-Native学习指南/</id>
    <published>2015-12-19T15:32:17.000Z</published>
    <updated>2016-02-19T09:13:18.282Z</updated>
    <content type="html"><![CDATA[<p>本指南汇集React-Native各类学习资源，给大家提供便利。指南正在不断的更新，大家有好的资源欢迎Pull Requests！</p>
<p>同时还有Awesome React-Native系列</p>
<p><a href="https://github.com/jondot/awesome-react-native" target="_blank" rel="external">https://github.com/jondot/awesome-react-native</a></p>
<h1 id="u76EE_u5F55"><a href="#u76EE_u5F55" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="/#教程">教程</a><ul>
<li><a href="/#react-native">React Native</a></li>
<li><a href="/#reactjs">React.js</a></li>
<li><a href="/#es6">ES6</a></li>
<li><a href="/#系列教程">系列教程</a></li>
</ul>
</li>
<li><a href="/#开源app">开源APP</a></li>
<li><a href="/#组件">组件</a></li>
<li><a href="/#工具">工具</a></li>
<li><a href="/#资源网站">资源网站</a></li>
<li><a href="/#业界讨论">业界讨论</a></li>
</ul>
<h2 id="u6559_u7A0B"><a href="#u6559_u7A0B" class="headerlink" title="教程"></a>教程</h2><a id="more"></a>
<h3 id="React_Native"><a href="#React_Native" class="headerlink" title="React Native"></a>React Native</h3><ul>
<li><p><strong>React-Native入门指南</strong><br><a href="https://github.com/vczero/react-native-lession" target="_blank" rel="external">https://github.com/vczero/react-native-lession</a></p>
</li>
<li><p><strong>React-Native视频教程(部分免费)</strong><br><a href="https://egghead.io/technologies/react" target="_blank" rel="external">https://egghead.io/technologies/react</a></p>
</li>
<li><p>react-native 官方api文档<br><a href="http://facebook.github.io/react-native/docs/getting-started.html" target="_blank" rel="external">http://facebook.github.io/react-native/docs/getting-started.html</a></p>
</li>
<li><p>react-native中文文档(极客学院)<br><a href="http://wiki.jikexueyuan.com/project/react-native/" target="_blank" rel="external">http://wiki.jikexueyuan.com/project/react-native/</a></p>
</li>
<li><p>react-native中文文档(react native中文网，人工翻译，官网完全同步)<br><a href="http://react-native.cn/docs/getting-started.html" target="_blank" rel="external">http://react-native.cn/docs/getting-started.html</a></p>
</li>
<li><p>react-native第一课<br><a href="http://html-js.com/article/2783" target="_blank" rel="external">http://html-js.com/article/2783</a></p>
</li>
<li><p>深入浅出 React Native：使用 JavaScript 构建原生应用<br><a href="http://zhuanlan.zhihu.com/FrontendMagazine/19996445" target="_blank" rel="external">http://zhuanlan.zhihu.com/FrontendMagazine/19996445</a></p>
</li>
<li><p>React Native通信机制详解<br><a href="http://blog.cnbang.net/tech/2698/" target="_blank" rel="external">http://blog.cnbang.net/tech/2698/</a></p>
</li>
<li><p>React Native布局篇<br><a href="http://segmentfault.com/a/1190000002658374" target="_blank" rel="external">http://segmentfault.com/a/1190000002658374</a></p>
</li>
<li><p>React Native 基础练习指北（一）<br><a href="http://segmentfault.com/a/1190000002645929" target="_blank" rel="external">http://segmentfault.com/a/1190000002645929</a></p>
</li>
<li><p>React Native 基础练习指北（二）<br><a href="http://segmentfault.com/a/1190000002647733" target="_blank" rel="external">http://segmentfault.com/a/1190000002647733</a></p>
</li>
<li><p>Diary of Building an iOS App with React Native<br><a href="http://herman.asia/building-a-flashcard-app-with-react-native" target="_blank" rel="external">http://herman.asia/building-a-flashcard-app-with-react-native</a></p>
</li>
<li><p>Use React Native in Existing iOS App<br><a href="http://blog-en.leapoahead.com/post/use-react-native-in-existing-ios-app" target="_blank" rel="external">http://blog-en.leapoahead.com/post/use-react-native-in-existing-ios-app</a></p>
</li>
<li><p>React Native For Beginners – The Next Big Thing?<br><a href="http://devdactic.com/react-native-for-beginners/" target="_blank" rel="external">http://devdactic.com/react-native-for-beginners/</a></p>
</li>
<li><p>How To Implement A Tab Bar With React Native<br><a href="http://devdactic.com/react-native-tab-bar/" target="_blank" rel="external">http://devdactic.com/react-native-tab-bar/</a></p>
</li>
<li><p>tcomb-form-native使用视频教程(需翻墙)<br><a href="http://react.rocks/example/tcomb-form-native" target="_blank" rel="external">http://react.rocks/example/tcomb-form-native</a></p>
</li>
<li><p>React Native分享记录<br><a href="http://segmentfault.com/a/1190000002678782" target="_blank" rel="external">http://segmentfault.com/a/1190000002678782</a></p>
</li>
<li><p>React Native构建本地视图组件<br><a href="https://www.dobest.me/article/11" target="_blank" rel="external">https://www.dobest.me/article/11</a></p>
</li>
<li><p>react-native-android-lession(安卓系列教程)<br><a href="https://github.com/yipengmu/react-native-android-lession" target="_blank" rel="external">https://github.com/yipengmu/react-native-android-lession</a></p>
</li>
<li><p>React Native模块桥接详解<br><a href="https://www.dobest.me/article/14" target="_blank" rel="external">https://www.dobest.me/article/14</a></p>
</li>
<li><p>React Native: 配置和起步<br><a href="http://www.liaohuqiu.net/cn/posts/react-native-1/" target="_blank" rel="external">http://www.liaohuqiu.net/cn/posts/react-native-1/</a></p>
</li>
<li><p>React Native: Android 的打包<br><a href="http://www.liaohuqiu.net/cn/posts/react-native-android-package/" target="_blank" rel="external">http://www.liaohuqiu.net/cn/posts/react-native-android-package/</a></p>
</li>
<li><p>react-native的第一课<br><a href="https://github.com/coderyi/blog/blob/master/articles/2016/0122_react-native_first_lesson.md" target="_blank" rel="external">https://github.com/coderyi/blog/blob/master/articles/2016/0122_react-native_first_lesson.md</a></p>
</li>
</ul>
<h3 id="React-js"><a href="#React-js" class="headerlink" title="React.js"></a>React.js</h3><ul>
<li><p>react.js中文文档<br><a href="http://reactjs.cn/" target="_blank" rel="external">http://reactjs.cn/</a></p>
</li>
<li><p>react.js入门教程(gitbook)<br><a href="https://hulufei.gitbooks.io/react-tutorial/content/introduction.html" target="_blank" rel="external">https://hulufei.gitbooks.io/react-tutorial/content/introduction.html</a></p>
</li>
<li><p><strong>react.js快速入门教程 - 阮一峰</strong><br><a href="http://www.ruanyifeng.com/blog/2015/03/react.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2015/03/react.html</a></p>
</li>
<li><p>react.js视频教程<br><a href="http://react.nodejs-china.org/t/reactjs/584" target="_blank" rel="external">http://react.nodejs-china.org/t/reactjs/584</a></p>
</li>
</ul>
<h3 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h3><ul>
<li><p>深入浅出ES6（一）：ES6是什么<br><a href="http://www.infoq.com/cn/articles/es6-in-depth-an-introduction" target="_blank" rel="external">http://www.infoq.com/cn/articles/es6-in-depth-an-introduction</a></p>
</li>
<li><p>深入浅出ES6（二）：迭代器和for-of循环<br><a href="http://www.infoq.com/cn/articles/es6-in-depth-iterators-and-the-for-of-loop" target="_blank" rel="external">http://www.infoq.com/cn/articles/es6-in-depth-iterators-and-the-for-of-loop</a></p>
</li>
<li><p>深入浅出ES6（三）：生成器 Generators<br><a href="http://www.infoq.com/cn/articles/es6-in-depth-generators" target="_blank" rel="external">http://www.infoq.com/cn/articles/es6-in-depth-generators</a></p>
</li>
<li><p>深入浅出ES6（四）：模板字符串<br><a href="http://www.infoq.com/cn/articles/es6-in-depth-template-string" target="_blank" rel="external">http://www.infoq.com/cn/articles/es6-in-depth-template-string</a></p>
</li>
<li><p>深入浅出ES6（五）：不定参数和默认参数<br><a href="http://www.infoq.com/cn/articles/es6-in-depth-rest-parameters-and-defaults" target="_blank" rel="external">http://www.infoq.com/cn/articles/es6-in-depth-rest-parameters-and-defaults</a></p>
</li>
</ul>
<h3 id="u7CFB_u5217_u6559_u7A0B"><a href="#u7CFB_u5217_u6559_u7A0B" class="headerlink" title="系列教程"></a>系列教程</h3><ul>
<li><p>深入浅出React（一）：React的设计哲学 - 简单之美<br><a href="http://www.infoq.com/cn/articles/react-art-of-simplity" target="_blank" rel="external">http://www.infoq.com/cn/articles/react-art-of-simplity</a></p>
</li>
<li><p>深入浅出React（二）：React开发神器Webpack<br><a href="http://www.infoq.com/cn/articles/react-and-webpack" target="_blank" rel="external">http://www.infoq.com/cn/articles/react-and-webpack</a></p>
</li>
<li><p>深入浅出React（三）：理解JSX和组件<br><a href="http://www.infoq.com/cn/articles/react-jsx-and-component" target="_blank" rel="external">http://www.infoq.com/cn/articles/react-jsx-and-component</a></p>
</li>
<li><p>深入浅出React（四）：虚拟DOM Diff算法解析<br><a href="http://www.infoq.com/cn/articles/react-dom-diff" target="_blank" rel="external">http://www.infoq.com/cn/articles/react-dom-diff</a></p>
</li>
<li><p>深入浅出React（五）：使用Flux搭建React应用程序架构<br><a href="http://www.infoq.com/cn/articles/react-flux" target="_blank" rel="external">http://www.infoq.com/cn/articles/react-flux</a></p>
</li>
<li><p>react-webpack-cookbook中文版<br><a href="http://fakefish.github.io/react-webpack-cookbook/" target="_blank" rel="external">http://fakefish.github.io/react-webpack-cookbook/</a></p>
</li>
<li><p>Flex 布局语法教程<br><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a></p>
</li>
<li><p>React 初探<br><a href="http://www.alloyteam.com/2015/04/react-explore/" target="_blank" rel="external">http://www.alloyteam.com/2015/04/react-explore/</a></p>
</li>
<li><p>React虚拟DOM浅析<br><a href="http://www.alloyteam.com/2015/10/react-virtual-analysis-of-the-dom/" target="_blank" rel="external">http://www.alloyteam.com/2015/10/react-virtual-analysis-of-the-dom/</a></p>
</li>
<li><p>react组件间通信<br><a href="http://www.alloyteam.com/2015/07/react-zu-jian-jian-tong-xin/" target="_blank" rel="external">http://www.alloyteam.com/2015/07/react-zu-jian-jian-tong-xin/</a></p>
</li>
<li><p>React 数据流管理架构之 Redux 介绍<br><a href="http://www.alloyteam.com/2015/09/react-redux/" target="_blank" rel="external">http://www.alloyteam.com/2015/09/react-redux/</a></p>
</li>
<li><p>React服务器端渲染实践小结<br><a href="http://www.alloyteam.com/2015/10/8783/" target="_blank" rel="external">http://www.alloyteam.com/2015/10/8783/</a></p>
</li>
<li><p>React Native Android 踩坑之旅<br><a href="http://www.alloyteam.com/2015/10/react-native-android-steps-on-tour/" target="_blank" rel="external">http://www.alloyteam.com/2015/10/react-native-android-steps-on-tour/</a></p>
</li>
<li><p>React Native 之 JSBridge<br><a href="http://www.alloyteam.com/2015/05/react-native-zhi-jsbridge/" target="_blank" rel="external">http://www.alloyteam.com/2015/05/react-native-zhi-jsbridge/</a></p>
</li>
</ul>
<h3 id="React_Native_u63A2_u7D22_u7CFB_u5217_u6559_u7A0B"><a href="#React_Native_u63A2_u7D22_u7CFB_u5217_u6559_u7A0B" class="headerlink" title="React Native探索系列教程"></a>React Native探索系列教程</h3><ul>
<li><p>React Native探索（一）：背景、规划和风险<br><a href="http://www.infoq.com/cn/articles/react-native-overview" target="_blank" rel="external">http://www.infoq.com/cn/articles/react-native-overview</a></p>
</li>
<li><p>React Native探索（二）：布局篇<br><a href="http://www.infoq.com/cn/articles/react-native-layout" target="_blank" rel="external">http://www.infoq.com/cn/articles/react-native-layout</a></p>
</li>
<li><p>React Native探索（三）：与 react-web 的融合<br><a href="http://www.infoq.com/cn/articles/react-native-web" target="_blank" rel="external">http://www.infoq.com/cn/articles/react-native-web</a></p>
</li>
</ul>
<h2 id="u5F00_u6E90APP"><a href="#u5F00_u6E90APP" class="headerlink" title="开源APP"></a>开源APP</h2><blockquote>
<p>研究源码也是一个很好的学习方式</p>
</blockquote>
<ul>
<li><p>官方演示App<br><a href="https://github.com/facebook/react-native/tree/master/Examples" target="_blank" rel="external">https://github.com/facebook/react-native/tree/master/Examples</a></p>
</li>
<li><p>react-native-dribbble-app<br><a href="https://github.com/catalinmiron/react-native-dribbble-app" target="_blank" rel="external">https://github.com/catalinmiron/react-native-dribbble-app</a></p>
</li>
<li><p><strong>Leanote for iOS(云笔记)</strong><br><a href="https://github.com/leanote/leanote-ios-rn" target="_blank" rel="external">https://github.com/leanote/leanote-ios-rn</a></p>
</li>
<li><p><strong>ReactNativeRubyChina</strong><br><a href="https://github.com/henter/ReactNativeRubyChina" target="_blank" rel="external">https://github.com/henter/ReactNativeRubyChina</a></p>
</li>
<li><p>HackerNews-React-Native<br><a href="https://github.com/iSimar/HackerNews-React-Native" target="_blank" rel="external">https://github.com/iSimar/HackerNews-React-Native</a></p>
</li>
<li><p>React-Native新闻客户端<br><a href="https://github.com/tabalt/ReactNativeNews" target="_blank" rel="external">https://github.com/tabalt/ReactNativeNews</a></p>
</li>
<li><p><strong>newswatch(新闻客户端)</strong><br><a href="https://github.com/bradoyler/newswatch-react-native" target="_blank" rel="external">https://github.com/bradoyler/newswatch-react-native</a></p>
</li>
<li><p><strong>buyscreen(购买页面)</strong><br><a href="https://github.com/appintheair/react-native-buyscreen" target="_blank" rel="external">https://github.com/appintheair/react-native-buyscreen</a></p>
</li>
<li><p><strong>V2EX客户端</strong><br><a href="https://github.com/samuel1112/v2er" target="_blank" rel="external">https://github.com/samuel1112/v2er</a></p>
</li>
<li><p>react-native-todo<br><a href="https://github.com/joemaddalone/react-native-todo" target="_blank" rel="external">https://github.com/joemaddalone/react-native-todo</a></p>
</li>
<li><p>react-native-beer<br><a href="https://github.com/muratsu/react-native-beer" target="_blank" rel="external">https://github.com/muratsu/react-native-beer</a></p>
</li>
<li><p>react-native-stars<br><a href="https://github.com/86/react-native-stars" target="_blank" rel="external">https://github.com/86/react-native-stars</a></p>
</li>
<li><p><strong>模仿天猫首页的app</strong><br><a href="https://github.com/hugohua/react-native-demo" target="_blank" rel="external">https://github.com/hugohua/react-native-demo</a></p>
</li>
<li><p>ReactNativeChess<br><a href="https://github.com/csarsam/ReactNativeChess" target="_blank" rel="external">https://github.com/csarsam/ReactNativeChess</a></p>
</li>
<li><p>react native 编写的音乐软件<br><a href="https://github.com/Johnqing/miumiu" target="_blank" rel="external">https://github.com/Johnqing/miumiu</a></p>
</li>
<li><p>react-native-pokedex<br><a href="https://github.com/ababol/react-native-pokedex" target="_blank" rel="external">https://github.com/ababol/react-native-pokedex</a></p>
</li>
<li><p>CNode-React-Native<br><a href="https://github.com/SFantasy/CNode-React-Native" target="_blank" rel="external">https://github.com/SFantasy/CNode-React-Native</a></p>
</li>
<li><p>8tracks电台客户端<br><a href="https://github.com/voronianski/EightTracksReactNative" target="_blank" rel="external">https://github.com/voronianski/EightTracksReactNative</a></p>
</li>
<li><p>React-Native实现的计算器<br><a href="https://github.com/yoxisem544/Calculator-using-React-Native" target="_blank" rel="external">https://github.com/yoxisem544/Calculator-using-React-Native</a></p>
</li>
<li><p><strong>房产搜索app</strong><br><a href="https://github.com/jawee/react-native-PropertyFinder" target="_blank" rel="external">https://github.com/jawee/react-native-PropertyFinder</a></p>
</li>
<li><p>知乎专栏app<br><a href="https://github.com/LeezQ/react-native-zhihu-app" target="_blank" rel="external">https://github.com/LeezQ/react-native-zhihu-app</a></p>
</li>
<li><p>ForeignExchangeApp<br><a href="https://github.com/peralmq/ForeignExchangeApp" target="_blank" rel="external">https://github.com/peralmq/ForeignExchangeApp</a></p>
</li>
<li><p>Segmentfault 客户端<br><a href="https://github.com/fakefish/sf-react-native" target="_blank" rel="external">https://github.com/fakefish/sf-react-native</a></p>
</li>
<li><p>糗事百科app<br><a href="https://github.com/stormhouse/QiuShiReactNative" target="_blank" rel="external">https://github.com/stormhouse/QiuShiReactNative</a></p>
</li>
<li><p>孢子社区app<br><a href="https://github.com/Hi-Rube/baoz-ReactNative" target="_blank" rel="external">https://github.com/Hi-Rube/baoz-ReactNative</a></p>
</li>
<li><p><strong>深JS app</strong><br><a href="https://github.com/fraserxu/shenjs" target="_blank" rel="external">https://github.com/fraserxu/shenjs</a></p>
</li>
<li><p>Den - 房屋销售app*<br><a href="https://github.com/asamiller/den" target="_blank" rel="external">https://github.com/asamiller/den</a></p>
</li>
<li><p><strong>Noder-cnodejs客户端</strong><br><a href="https://github.com/soliury/noder-react-native" target="_blank" rel="external">https://github.com/soliury/noder-react-native</a></p>
</li>
<li><p>知乎日报Android版<br><a href="https://github.com/race604/ZhiHuDaily-React-Native" target="_blank" rel="external">https://github.com/race604/ZhiHuDaily-React-Native</a></p>
</li>
<li><p>ziliun-react-native<br><a href="https://github.com/sonnylazuardi/ziliun-react-native" target="_blank" rel="external">https://github.com/sonnylazuardi/ziliun-react-native</a></p>
</li>
<li><p>react-native-weather-app<br><a href="https://github.com/shevawen/react-native-weather-app" target="_blank" rel="external">https://github.com/shevawen/react-native-weather-app</a></p>
</li>
<li><p>React Native Sample App(Navigation,Flux)<br><a href="https://github.com/taskrabbit/ReactNativeSampleApp" target="_blank" rel="external">https://github.com/taskrabbit/ReactNativeSampleApp</a></p>
</li>
<li><p>TesterHome社区app<br><a href="https://github.com/qddegtya/A-ReactNative-TesterHome" target="_blank" rel="external">https://github.com/qddegtya/A-ReactNative-TesterHome</a></p>
</li>
<li><p>Finance - 股票报价app<br><a href="https://github.com/7kfpun/FinanceReactNative" target="_blank" rel="external">https://github.com/7kfpun/FinanceReactNative</a></p>
</li>
<li><p>shopping - 购物app<br><a href="https://github.com/bigsui/shopping-react-native" target="_blank" rel="external">https://github.com/bigsui/shopping-react-native</a></p>
</li>
<li><p>zhuiyuan - 追源cms app<br><a href="https://github.com/kazaff/ZhuiYuanDemo" target="_blank" rel="external">https://github.com/kazaff/ZhuiYuanDemo</a></p>
</li>
<li><p>uestc-bbs-react-native - UESTC清水河畔RN客户端(with Redux)<br><a href="https://github.com/just4fun/uestc-bbs-react-native" target="_blank" rel="external">https://github.com/just4fun/uestc-bbs-react-native</a></p>
</li>
<li><p><strong>react-native-nw-react-calculator</strong>(iOS/Android、Web、桌面多端)<br><a href="https://github.com/benoitvallon/react-native-nw-react-calculator" target="_blank" rel="external">https://github.com/benoitvallon/react-native-nw-react-calculator</a></p>
</li>
<li><p>react-native-nba-app<br><a href="https://github.com/wwayne/react-native-nba-app" target="_blank" rel="external">https://github.com/wwayne/react-native-nba-app</a></p>
</li>
</ul>
<h2 id="u7EC4_u4EF6"><a href="#u7EC4_u4EF6" class="headerlink" title="组件"></a>组件</h2><blockquote>
<p>由于已经有较好的组件库网站，这里就不做总结。可以直接查看如下网站，过后可能精选一部分优质组件出来 :P</p>
</blockquote>
<ul>
<li><p><strong>React-native组件库</strong>（比较全的组件库）<br><a href="http://react.parts/" target="_blank" rel="external">http://react.parts/</a></p>
</li>
<li><p><strong>React Native Modules</strong><br><a href="http://reactnativemodules.com/" target="_blank" rel="external">http://reactnativemodules.com/</a></p>
</li>
<li><p><strong>最佳轮播类组件</strong><br><a href="https://github.com/leecade/react-native-swiper" target="_blank" rel="external">https://github.com/leecade/react-native-swiper</a></p>
</li>
<li><p>React Native Router<br><a href="https://github.com/t4t5/react-native-router" target="_blank" rel="external">https://github.com/t4t5/react-native-router</a></p>
</li>
<li><p>下拉刷新组件<br><a href="https://github.com/jsdf/react-native-refreshable-listview" target="_blank" rel="external">https://github.com/jsdf/react-native-refreshable-listview</a></p>
</li>
<li><p>模态框<br><a href="https://github.com/brentvatne/react-native-modal" target="_blank" rel="external">https://github.com/brentvatne/react-native-modal</a></p>
</li>
<li><p>react-native-navbar<br><a href="https://github.com/react-native-fellowship/react-native-navbar" target="_blank" rel="external">https://github.com/react-native-fellowship/react-native-navbar</a></p>
</li>
<li><p>滚动轮播组件<br><a href="https://github.com/appintheair/react-native-looped-carousel" target="_blank" rel="external">https://github.com/appintheair/react-native-looped-carousel</a></p>
</li>
<li><p>HTML显示组件<br><a href="https://github.com/jsdf/react-native-htmlview" target="_blank" rel="external">https://github.com/jsdf/react-native-htmlview</a></p>
</li>
<li><p><strong>Material React Native (MRN)</strong> - Material Design组件库<br><a href="https://github.com/binggg/mrn" target="_blank" rel="external">https://github.com/binggg/mrn</a></p>
</li>
</ul>
<h2 id="u5DE5_u5177"><a href="#u5DE5_u5177" class="headerlink" title="工具"></a>工具</h2><ul>
<li><p>react-native-snippets(代码提示)<br><a href="https://github.com/Shrugs/react-native-snippets" target="_blank" rel="external">https://github.com/Shrugs/react-native-snippets</a></p>
</li>
<li><p>react-native-babel(使用ES6+)<br><a href="https://github.com/roman01la/react-native-babel" target="_blank" rel="external">https://github.com/roman01la/react-native-babel</a></p>
</li>
<li><p>sqlite for react-native<br><a href="https://github.com/almost/react-native-sqlite" target="_blank" rel="external">https://github.com/almost/react-native-sqlite</a></p>
</li>
<li><p>gulp-react-native-css(就像写css一样写React Style)<br><a href="https://github.com/soliury/gulp-react-native-css" target="_blank" rel="external">https://github.com/soliury/gulp-react-native-css</a></p>
</li>
<li><p>rnpm(React Native Package Manager)<br><a href="https://github.com/rnpm/rnpm" target="_blank" rel="external">https://github.com/rnpm/rnpm</a></p>
</li>
</ul>
<h2 id="u8D44_u6E90_u7F51_u7AD9"><a href="#u8D44_u6E90_u7F51_u7AD9" class="headerlink" title="资源网站"></a>资源网站</h2><ul>
<li><p>React-native官网<br><a href="http://facebook.github.io/react-native/" target="_blank" rel="external">http://facebook.github.io/react-native/</a></p>
</li>
<li><p><strong>React-China社区</strong><br><a href="http://react-china.org/" target="_blank" rel="external">http://react-china.org/</a></p>
</li>
<li><p><strong>React Native中文社区</strong><br><a href="http://bbs.react-native.cn/" target="_blank" rel="external">http://bbs.react-native.cn/</a></p>
</li>
<li><p><strong>React-native组件库</strong>（比较全的组件库）<br><a href="http://react.parts/" target="_blank" rel="external">http://react.parts/</a></p>
</li>
<li><p><strong>React Native Modules</strong><br><a href="http://reactnativemodules.com/" target="_blank" rel="external">http://reactnativemodules.com/</a></p>
</li>
<li><p><strong>Use React Native 资讯站</strong>(使用技巧及新闻)<br><a href="http://www.reactnative.com/" target="_blank" rel="external">http://www.reactnative.com/</a></p>
</li>
<li><p>11款React Native开源移动 UI 组件<br><a href="http://www.oschina.net/news/61214/11-react-native-ui-components" target="_blank" rel="external">http://www.oschina.net/news/61214/11-react-native-ui-components</a></p>
</li>
<li><p><strong>稀土掘金的 React 标签</strong><br><a href="http://gold.xitu.io/#/tag/React.js" target="_blank" rel="external">http://gold.xitu.io/#/tag/React.js</a> <a href="http://gold.xitu.io/#/tag/React%20Native" target="_blank" rel="external">http://gold.xitu.io/#/tag/React%20Native</a></p>
</li>
</ul>
<h2 id="u4E1A_u754C_u8BA8_u8BBA"><a href="#u4E1A_u754C_u8BA8_u8BBA" class="headerlink" title="业界讨论"></a>业界讨论</h2><ul>
<li><p>跨平台开发时代的 (再次) 到来？（ Xamarin，NativeScript 和 React Native 对比）<br><a href="http://onevcat.com/2015/03/cross-platform/" target="_blank" rel="external">http://onevcat.com/2015/03/cross-platform/</a></p>
</li>
<li><p>谈谈 React Native - 唐巧<br><a href="http://blog.devtang.com/blog/2015/02/01/talk-about-react-native/" target="_blank" rel="external">http://blog.devtang.com/blog/2015/02/01/talk-about-react-native/</a></p>
</li>
<li><p>如何评价React-Native?<br><a href="http://www.zhihu.com/question/27852694/answer/43990708" target="_blank" rel="external">http://www.zhihu.com/question/27852694/answer/43990708</a></p>
</li>
<li><p>React Native概述：背景、规划和风险<br><a href="http://div.io/topic/938" target="_blank" rel="external">http://div.io/topic/938</a></p>
</li>
<li><p>Native与Web的融合 - Qcon中React-Native演讲<br><a href="http://www.infoq.com/cn/presentations/the-fusion-of-native-and-web" target="_blank" rel="external">http://www.infoq.com/cn/presentations/the-fusion-of-native-and-web</a></p>
</li>
</ul>
<p>本文转自:<a href="https://github.com/jondot/awesome-react-native" target="_blank" rel="external">https://github.com/jondot/awesome-react-native</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本指南汇集React-Native各类学习资源，给大家提供便利。指南正在不断的更新，大家有好的资源欢迎Pull Requests！</p>
<p>同时还有Awesome React-Native系列</p>
<p><a href="https://github.com/jondot/awesome-react-native">https://github.com/jondot/awesome-react-native</a></p>
<h1 id="u76EE_u5F55"><a href="#u76EE_u5F55" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="/#教程">教程</a><ul>
<li><a href="/#react-native">React Native</a></li>
<li><a href="/#reactjs">React.js</a></li>
<li><a href="/#es6">ES6</a></li>
<li><a href="/#系列教程">系列教程</a></li>
</ul>
</li>
<li><a href="/#开源app">开源APP</a></li>
<li><a href="/#组件">组件</a></li>
<li><a href="/#工具">工具</a></li>
<li><a href="/#资源网站">资源网站</a></li>
<li><a href="/#业界讨论">业界讨论</a></li>
</ul>
<h2 id="u6559_u7A0B"><a href="#u6559_u7A0B" class="headerlink" title="教程"></a>教程</h2>]]>
    
    </summary>
    
      <category term="React-Native" scheme="http://yoursite.com/tags/React-Native/"/>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[RecyclerView 列表控件中简单实现时间线]]></title>
    <link href="http://yoursite.com/2015/12/18/RecyclerView%20%E5%88%97%E8%A1%A8%E6%8E%A7%E4%BB%B6%E4%B8%AD%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E6%97%B6%E9%97%B4%E7%BA%BF/"/>
    <id>http://yoursite.com/2015/12/18/RecyclerView 列表控件中简单实现时间线/</id>
    <published>2015-12-17T17:01:14.000Z</published>
    <updated>2016-02-19T09:20:12.990Z</updated>
    <content type="html"><![CDATA[<p>看见很多软件中都有时间线的东西，貌似天气啊，旅游啊什么的最多了；具体实现方式很多，在本篇文章中讲解一种自定义View封装的方式。</p>
<h3 id="u6548_u679C"><a href="#u6548_u679C" class="headerlink" title="效果"></a>效果</h3><p>先来看看效果。<br><img src="http://www.jcodecraeer.com/uploads/20150825/1440469250572021.png" alt=""><br><a id="more"></a></p>
<h3 id="u5206_u6790"><a href="#u5206_u6790" class="headerlink" title="分析"></a>分析</h3><p>软件中，可以看见前面的时间线也就是线条加上圆圈组成；当然这里的圆圈与线条也都是可以随意换成其他的，比如图片等等。</p>
<p>当然这里最简单的来说，是上面一个线条，然后一个圆圈，然后下面一个线条；上线条在第一条数据时不做显示，下线条在最后一条数据时不做显示。</p>
<p><img src="http://www.jcodecraeer.com/uploads/20150825/1440469277121276.png" alt=""></p>
<p>这里自定义布局部分也就是把旁边的线条与圆圈封装到一起，并使用简单的方法来控制是否显示。<br>当封装好了后，与旁边的文字部分也就是水瓶方向的线性布局了，然后设置为每一个的RecyclerView 的Item的布局也就完成了。</p>
<h3 id="u63A7_u4EF6"><a href="#u63A7_u4EF6" class="headerlink" title="控件"></a>控件</h3><p>控件很简单，首先我们继承View，取名为 TimeLineMarker 就OK。</p>
<h3 id="Attrs__u5C5E_u6027"><a href="#Attrs__u5C5E_u6027" class="headerlink" title="Attrs 属性"></a>Attrs 属性</h3><p>开始控件之前先准备好需要的属性。</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;resources&gt;
    &lt;declare-styleable name=&quot;TimeLineMarker&quot;&gt;
        &lt;attr name=&quot;markerSize&quot; format=&quot;dimension&quot; /&gt;
        &lt;attr name=&quot;marker&quot; format=&quot;color|reference&quot; /&gt;
        &lt;attr name=&quot;beginLine&quot; format=&quot;color|reference&quot; /&gt;
        &lt;attr name=&quot;endLine&quot; format=&quot;color|reference&quot; /&gt;
        &lt;attr name=&quot;lineSize&quot; format=&quot;dimension&quot; /&gt;
    &lt;/declare-styleable&gt;
&lt;/resources&gt;
</code></pre><p>在这里也就准备了线条的大小、开始线条、结束线条、中间标示部分及大小。</p>
<h3 id="u5C5E_u6027_u4E0E_u73B0_u5B9E"><a href="#u5C5E_u6027_u4E0E_u73B0_u5B9E" class="headerlink" title="属性与现实"></a>属性与现实</h3><pre><code>private int mMarkerSize = 24;
private int mLineSize = 12;
private Drawable mBeginLine;
private Drawable mEndLine;
private Drawable mMarkerDrawable;

@Override
protected void onDraw(Canvas canvas) {
    if (mBeginLine != null) {
        mBeginLine.draw(canvas);
    }

    if (mEndLine != null) {
        mEndLine.draw(canvas);
    }

    if (mMarkerDrawable != null) {
        mMarkerDrawable.draw(canvas);
    }

    super.onDraw(canvas);
}
</code></pre><p>两个大小属性，3个具体的Drawable，然后在onDraw方法中进行具体的显示也就OK。</p>
<h3 id="u6784_u9020_u4E0E_u5C5E_u6027_u521D_u59CB_u5316"><a href="#u6784_u9020_u4E0E_u5C5E_u6027_u521D_u59CB_u5316" class="headerlink" title="构造与属性初始化"></a>构造与属性初始化</h3><p>在上面我们定义了属性，在这里我们在构造函数中获取XML所设置的属性。</p>
<pre><code>public TimeLineMarker(Context context) {
    this(context, null);
}

public TimeLineMarker(Context context, AttributeSet attrs) {
    this(context, attrs, 0);
}

public TimeLineMarker(Context context, AttributeSet attrs, int defStyle) {
    super(context, attrs, defStyle);
    init(attrs);
}

private void init(AttributeSet attrs) {
    // Load attributes
    final TypedArray a = getContext().obtainStyledAttributes(
            attrs, R.styleable.TimeLineMarker, 0, 0);

    mMarkerSize = a.getDimensionPixelSize(
            R.styleable.TimeLineMarker_markerSize,
            mMarkerSize);

    mLineSize = a.getDimensionPixelSize(
            R.styleable.TimeLineMarker_lineSize,
            mLineSize);

    mBeginLine = a.getDrawable(
            R.styleable.TimeLineMarker_beginLine);

    mEndLine = a.getDrawable(
            R.styleable.TimeLineMarker_endLine);

    mMarkerDrawable = a.getDrawable(
            R.styleable.TimeLineMarker_marker);

    a.recycle();

    if (mBeginLine != null)
        mBeginLine.setCallback(this);

    if (mEndLine != null)
        mEndLine.setCallback(this);

    if (mMarkerDrawable != null)
        mMarkerDrawable.setCallback(this);
}
</code></pre><h3 id="Drawable__u7684_u4F4D_u7F6E_u4E0E_u5927_u5C0F_u521D_u59CB_u5316"><a href="#Drawable__u7684_u4F4D_u7F6E_u4E0E_u5927_u5C0F_u521D_u59CB_u5316" class="headerlink" title="Drawable 的位置与大小初始化"></a>Drawable 的位置与大小初始化</h3><p>属性啥的有了，具体的Drawable 也有了，要显示的地方调用也是OK了；但是如果没有进行进行具体的位置调整这一切也都没有意义。</p>
<pre><code>@Override
protected void onSizeChanged(int w, int h, int oldw, int oldh) {
    super.onSizeChanged(w, h, oldw, oldh);
    initDrawableSize();
}

private void initDrawableSize() {
    int pLeft = getPaddingLeft();
    int pRight = getPaddingRight();
    int pTop = getPaddingTop();
    int pBottom = getPaddingBottom();

    int width = getWidth();
    int height = getHeight();

    int cWidth = width - pLeft - pRight;
    int cHeight = height - pTop - pBottom;

    Rect bounds;

    if (mMarkerDrawable != null) {
        // Size
        int markerSize = Math.min(mMarkerSize, Math.min(cWidth, cHeight));
        mMarkerDrawable.setBounds(pLeft, pTop,
                pLeft + markerSize, pTop + markerSize);

        bounds = mMarkerDrawable.getBounds();
    } else {
        bounds = new Rect(pLeft, pTop, pLeft + cWidth, pTop + cHeight);
    }


    int halfLineSize = mLineSize &gt;&gt; 1;
    int lineLeft = bounds.centerX() - halfLineSize;

    if (mBeginLine != null) {
        mBeginLine.setBounds(lineLeft, 0, lineLeft + mLineSize, bounds.top);
    }

    if (mEndLine != null) {
        mEndLine.setBounds(lineLeft, bounds.bottom, lineLeft + mLineSize, height);
    }
}
</code></pre><p>initDrawableSize 方法进行具体的运算，而运算的时间点就是当控件的大小改变（onSizeChanged）的时候。</p>
<p>在初始化中采用了一定的投机取巧；这里利用了上内边距与下内边距分别作为上线条与下线条的长度；而线条与中间的标识都采用了水平距中。</p>
<h3 id="u5176_u4ED6_u8BBE_u7F6E_u65B9_u6CD5"><a href="#u5176_u4ED6_u8BBE_u7F6E_u65B9_u6CD5" class="headerlink" title="其他设置方法"></a>其他设置方法</h3><pre><code>public void setLineSize(int lineSize) {
    if (mLineSize != lineSize) {
        this.mLineSize = lineSize;
        initDrawableSize();
        invalidate();
    }
}

public void setMarkerSize(int markerSize) {
    if (this.mMarkerSize != markerSize) {
        mMarkerSize = markerSize;
        initDrawableSize();
        invalidate();
    }
}

public void setBeginLine(Drawable beginLine) {
    if (this.mBeginLine != beginLine) {
        this.mBeginLine = beginLine;
        if (mBeginLine != null) {
            mBeginLine.setCallback(this);
        }
        initDrawableSize();
        invalidate();
    }
}

public void setEndLine(Drawable endLine) {
    if (this.mEndLine != endLine) {
        this.mEndLine = endLine;
        if (mEndLine != null) {
            mEndLine.setCallback(this);
        }
        initDrawableSize();
        invalidate();
    }
}

public void setMarkerDrawable(Drawable markerDrawable) {
    if (this.mMarkerDrawable != markerDrawable) {
        this.mMarkerDrawable = markerDrawable;
        if (mMarkerDrawable != null) {
            mMarkerDrawable.setCallback(this);
        }
        initDrawableSize();
        invalidate();
    }
}
</code></pre><p>在设置中，首先判断是否更改，如果更改那么就更新并重新计算位置；随后刷新界面。</p>
<blockquote>
<p>到这里，控件差不多准备OK了，其中还有很多可以完善的地方，比如加上快捷设置颜色什么的，也可以加上大小计算的东西。同时还可以加上时间线是水瓶还是垂直等等。在这里就不累赘介绍哪些了。下面来看看如何使用。</p>
</blockquote>
<h3 id="u4F7F_u7528"><a href="#u4F7F_u7528" class="headerlink" title="使用"></a>使用</h3><h4 id="XML_u5E03_u5C40"><a href="#XML_u5E03_u5C40" class="headerlink" title="XML布局"></a>XML布局</h4><h5 id="ITEM_u5E03_u5C40item_time_line-xml"><a href="#ITEM_u5E03_u5C40item_time_line-xml" class="headerlink" title="ITEM布局item_time_line.xml"></a>ITEM布局item_time_line.xml</h5><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:orientation=&quot;horizontal&quot;
    android:paddingLeft=&quot;@dimen/lay_16&quot;
    android:paddingRight=&quot;@dimen/lay_16&quot;
    tools:ignore=&quot;MissingPrefix&quot;&gt;

    &lt;net.qiujuer.example.timeline.widget.TimeLineMarker
        android:id=&quot;@+id/item_time_line_mark&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;match_parent&quot;
        android:paddingBottom=&quot;@dimen/lay_16&quot;
        android:paddingLeft=&quot;@dimen/lay_4&quot;
        android:paddingRight=&quot;@dimen/lay_4&quot;
        android:paddingTop=&quot;@dimen/lay_16&quot;
        app:beginLine=&quot;@color/black_alpha_32&quot;
        app:endLine=&quot;@color/black_alpha_32&quot;
        app:lineSize=&quot;2dp&quot;
        app:marker=&quot;@drawable/ic_timeline_default_marker&quot;
        app:markerSize=&quot;24dp&quot; /&gt;

    &lt;TextView
        android:id=&quot;@+id/item_time_line_txt&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_gravity=&quot;center&quot;
        android:paddingBottom=&quot;@dimen/lay_16&quot;
        android:paddingLeft=&quot;@dimen/lay_4&quot;
        android:paddingRight=&quot;@dimen/lay_4&quot;
        android:paddingTop=&quot;@dimen/lay_16&quot;
        android:textColor=&quot;@color/grey_600&quot;
        android:textSize=&quot;@dimen/font_16&quot; /&gt;

&lt;/LinearLayout&gt;
</code></pre><p>在这里我们之间使用顺序布局，左边是TimelIne控件，右边是一个简单的字体控件，具体使用中可以细化一些。</p>
<p>在TImeLine控件中我们的Mark是使用的drawable/ic_timeline_default_marker；这个就是一个简单的圆圈而已；对于自己美化可以使用一张图片代替或者更加复杂的布局；当然上面的线条就更加简单了，就直接使用颜色代替。</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:shape=&quot;oval&quot;&gt;
    &lt;solid android:color=&quot;@color/cyan_500&quot; /&gt;
    &lt;stroke
        android:width=&quot;1dp&quot;
        android:color=&quot;@color/black_alpha_32&quot; /&gt;
&lt;/shape&gt;
</code></pre><h5 id="u4E3B_u754C_u9762XML_RecyclerView"><a href="#u4E3B_u754C_u9762XML_RecyclerView" class="headerlink" title="主界面XML RecyclerView"></a>主界面XML RecyclerView</h5><pre><code>&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:paddingBottom=&quot;@dimen/activity_vertical_margin&quot;
    android:paddingLeft=&quot;@dimen/activity_horizontal_margin&quot;
    android:paddingRight=&quot;@dimen/activity_horizontal_margin&quot;
    android:paddingTop=&quot;@dimen/activity_vertical_margin&quot;
    tools:context=&quot;.MainActivity&quot;&gt;

    &lt;android.support.v7.widget.RecyclerView
        android:id=&quot;@+id/time_line_recycler&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:clickable=&quot;true&quot;
        android:fadeScrollbars=&quot;true&quot;
        android:fadingEdge=&quot;none&quot;
        android:focusable=&quot;true&quot;
        android:focusableInTouchMode=&quot;true&quot;
        android:overScrollMode=&quot;never&quot;
        android:scrollbarSize=&quot;2dp&quot;
        android:scrollbarThumbVertical=&quot;@color/cyan_500&quot;
        android:scrollbars=&quot;vertical&quot; /&gt;

&lt;/RelativeLayout&gt;
</code></pre><p>在这里就是加上了一个RecyclerView 控件在主界面就OK。</p>
<h5 id="Java_u4EE3_u7801_u90E8_u5206"><a href="#Java_u4EE3_u7801_u90E8_u5206" class="headerlink" title="Java代码部分"></a>Java代码部分</h5><p>在开始之前先来看看我们的文件具体有些神马。</p>
<p><img src="http://www.jcodecraeer.com/uploads/20150825/1440469609114998.png" alt=""></p>
<p>widget中就是具体的自定义控件，model是具体的数据模型，adapter部分，这里有一个Recyclerview的adapter文件，以及一个具体的Item TimeLineViewHolder，当然在这里还定义了一个ItemType类，该类用来标示每个Item的类型，比如头部，第一个，普通，最后一个，底部等等。</p>
<h6 id="TimeLineModel-java"><a href="#TimeLineModel-java" class="headerlink" title="TimeLineModel.java"></a>TimeLineModel.java</h6><pre><code>package net.qiujuer.example.timeline.model;

/**
 * Created by qiujuer
 * on 15/8/23.
 */
public class TimeLineModel {
    private String name;
    private int age;

    public TimeLineModel() {

    }

    public TimeLineModel(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public int getAge() {
        return age;
    }

    public String getName() {
        return name;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public void setName(String name) {
        this.name = name;
    }
}
</code></pre><p>一个名字，一个年龄也就OK。</p>
<h6 id="ItemType-java"><a href="#ItemType-java" class="headerlink" title="ItemType.java"></a>ItemType.java</h6><pre><code>package net.qiujuer.example.timeline.adapter;

/**
 * Created by qiujuer
 * on 15/8/23.
 */
public class ItemType {
    public final static int NORMAL = 0;

    public final static int HEADER = 1;
    public final static int FOOTER = 2;

    public final static int START = 4;
    public final static int END = 8;

    public final static int ATOM = 16;
}
</code></pre><p>分别定义了几个静态值，分别代表普通、头部、底部、开始、结束、原子；当然其中有些可以不用定义。</p>
<h6 id="TimeLineViewHolder-java"><a href="#TimeLineViewHolder-java" class="headerlink" title="TimeLineViewHolder.java"></a>TimeLineViewHolder.java</h6><pre><code>package net.qiujuer.example.timeline.adapter;

import android.support.v7.widget.RecyclerView;
import android.view.View;
import android.widget.TextView;

import net.qiujuer.example.timeline.R;
import net.qiujuer.example.timeline.model.TimeLineModel;
import net.qiujuer.example.timeline.widget.TimeLineMarker;

/**
 * Created by qiujuer
 * on 15/8/23.
 */
public class TimeLineViewHolder extends RecyclerView.ViewHolder {
    private TextView mName;

    public TimeLineViewHolder(View itemView, int type) {
        super(itemView);

        mName = (TextView) itemView.findViewById(R.id.item_time_line_txt);

        TimeLineMarker mMarker = (TimeLineMarker) itemView.findViewById(R.id.item_time_line_mark);
        if (type == ItemType.ATOM) {
            mMarker.setBeginLine(null);
            mMarker.setEndLine(null);
        } else if (type == ItemType.START) {
            mMarker.setBeginLine(null);
        } else if (type == ItemType.END) {
            mMarker.setEndLine(null);
        }

    }

    public void setData(TimeLineModel data) {
        mName.setText(&quot;Name:&quot; + data.getName() + &quot; Age:&quot; + data.getAge());
    }
}
</code></pre><p>该文件为RecyclerView 的Adapter中每个Item需要实现的Holder类。<br>在该类中，我们在构造函数中需要传入一个根View同时传入一个当然item的状态。<br>随后使用find….找到控件，在这里我们把TextView保存起来，而TimeLineView找到后直接进行初始化设置。<br>根据传入的ItemType来判断是否是第一个，最后一个，以及原子；然后设置TimeLineView的属性。<br>在下面的setData方法中我们显示具体的Model数据。</p>
<h6 id="TimeLineAdapter-java"><a href="#TimeLineAdapter-java" class="headerlink" title="TimeLineAdapter.java"></a>TimeLineAdapter.java</h6><p>适配器部分，我们需要做的工作是；根据具体的数据渲染上对应的界面就OK。</p>
<pre><code>package net.qiujuer.example.timeline.adapter;

import android.support.v7.widget.RecyclerView;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;

import net.qiujuer.example.timeline.R;
import net.qiujuer.example.timeline.model.TimeLineModel;

import java.util.List;

/**
 * Created by qiujuer
 * on 15/8/23.
 */
public class TimeLineAdapter extends RecyclerView.Adapter&lt;TimeLineViewHolder&gt; {
    private List&lt;TimeLineModel&gt; mDataSet;

    public TimeLineAdapter(List&lt;TimeLineModel&gt; models) {
        mDataSet = models;
    }

    @Override
    public int getItemViewType(int position) {
        final int size = mDataSet.size() - 1;
        if (size == 0)
            return ItemType.ATOM;
        else if (position == 0)
            return ItemType.START;
        else if (position == size)
            return ItemType.END;
        else return ItemType.NORMAL;
    }

    @Override
    public TimeLineViewHolder onCreateViewHolder(ViewGroup viewGroup, int viewType) {
        // Create a new view.
        View v = LayoutInflater.from(viewGroup.getContext())
                .inflate(R.layout.item_time_line, viewGroup, false);
        return new TimeLineViewHolder(v, viewType);
    }

    @Override
    public void onBindViewHolder(TimeLineViewHolder timeLineViewHolder, int i) {
        timeLineViewHolder.setData(mDataSet.get(i));
    }

    @Override
    public int getItemCount() {
        return mDataSet.size();
    }
}
</code></pre><blockquote>
<p>在这里需要着重说一下：我复写了getItemViewType方法；在该方法中我们需要设置对应的Item的类型；在这里传入的是item的坐标，需要返回的是item的具体状态，该状态标示是int类型；在这里我使用的是ItemType的静态属性。<br>该方法会在调用onCreateViewHolder方法之前调用；而onCreateViewHolder方法中的第二个参数int值也就是从getItemViewType之中来；所以我们可以在这里进行对应的数据状态标示。<br>而在onCreateViewHolder方法中我们返回一个：TimeLineViewHolder就OK，随后在onBindViewHolder方法中进行数据初始化操作。</p>
</blockquote>
<h6 id="MainActivity-java"><a href="#MainActivity-java" class="headerlink" title="MainActivity.java"></a>MainActivity.java</h6><p>上面所有都准备好了，下面就进行具体的显示。<br>在这里就只贴出核心代码了；篇幅也是有些长。</p>
<pre><code>private RecyclerView mRecycler;

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    mRecycler = (RecyclerView) findViewById(R.id.time_line_recycler);
    initRecycler();
}

private void initRecycler() {
    LinearLayoutManager layoutManager = new LinearLayoutManager(this);
    layoutManager.setOrientation(LinearLayoutManager.VERTICAL);

    TimeLineAdapter adapter = new TimeLineAdapter(getData());

    mRecycler.setLayoutManager(layoutManager);
    mRecycler.setAdapter(adapter);
}

private List&lt;TimeLineModel&gt; getData() {
    List&lt;TimeLineModel&gt; models = new ArrayList&lt;TimeLineModel&gt;();

    models.add(new TimeLineModel(&quot;XiaoMing&quot;, 21));
    models.add(new TimeLineModel(&quot;XiaoFang&quot;, 20));
    models.add(new TimeLineModel(&quot;XiaoHua&quot;, 25));
    models.add(new TimeLineModel(&quot;XiaoA&quot;, 22));
    models.add(new TimeLineModel(&quot;XiaoNiu&quot;, 23));

    return models;
}
</code></pre><p>在这里就是傻瓜的操作了，流程就是准备好对应的数据，装进Adapter，准备好对应的布局方式，然后都设置到RecyclerView中就OK。</p>
<h6 id="u6548_u679C-1"><a href="#u6548_u679C-1" class="headerlink" title="效果"></a>效果</h6><p>来看看具体的效果：</p>
<p><img src="http://www.jcodecraeer.com/uploads/20150825/1440469865127253.png" alt=""></p>
<p>效果虽然简单，但是也算是五脏具全；其中无非就是控件的自定义。这个自定义是可以扩展的，大家可以扩展为水平方向试试。</p>
<h6 id="u4EE3_u7801"><a href="#u4EE3_u7801" class="headerlink" title="代码"></a>代码</h6><p>博客代码都开源到项目中了。<br>地址：<a href="https://github.com/qiujuer/BeFoot/tree/master/blog/sample/TimeLine" target="_blank" rel="external">https://github.com/qiujuer/BeFoot/tree/master/blog/sample/TimeLine</a></p>
<h6 id="u5199_u5728_u6700_u540E"><a href="#u5199_u5728_u6700_u540E" class="headerlink" title="写在最后"></a>写在最后</h6><p>文章的开始截屏来源于：最近没事儿捣鼓了一个APP［UPMiss］，一个简单的生日，纪念日提醒软件；欢迎大家尝鲜。</p>
<hr>
<p>转载出处：<a href="http://blog.csdn.net/qiujuer/article/details/47910185" target="_blank" rel="external">http://blog.csdn.net/qiujuer/article/details/47910185</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>看见很多软件中都有时间线的东西，貌似天气啊，旅游啊什么的最多了；具体实现方式很多，在本篇文章中讲解一种自定义View封装的方式。</p>
<h3 id="u6548_u679C"><a href="#u6548_u679C" class="headerlink" title="效果"></a>效果</h3><p>先来看看效果。<br><img src="http://www.jcodecraeer.com/uploads/20150825/1440469250572021.png" alt=""><br>]]>
    
    </summary>
    
      <category term="时间轴" scheme="http://yoursite.com/tags/%E6%97%B6%E9%97%B4%E8%BD%B4/"/>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[亮点和不足]]></title>
    <link href="http://yoursite.com/2015/11/21/3.5%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E4%BA%AE%E7%82%B9%E5%92%8C%E4%B8%8D%E8%B6%B3/"/>
    <id>http://yoursite.com/2015/11/21/3.5开发中的亮点和不足/</id>
    <published>2015-11-20T18:33:45.000Z</published>
    <updated>2016-02-19T08:25:42.229Z</updated>
    <content type="html"><![CDATA[<h3 id="1_u3001_u4E00_u952E_u52A0_u6CB9_u7684_u6570_u636E_u7F13_u5B58_u64CD_u4F5C"><a href="#1_u3001_u4E00_u952E_u52A0_u6CB9_u7684_u6570_u636E_u7F13_u5B58_u64CD_u4F5C" class="headerlink" title="1、一键加油的数据缓存操作"></a>1、一键加油的数据缓存操作</h3><ul>
<li><p>添加缓存</p>
<pre><code>原因：
    开发过程，由于测试服务器的网络带宽，客户端请求数据超级慢，用户的体验非常不好。
工具：
    sharedPreference：
流程：
    1、将一键加油的数据，在进入到主页的时候，进行请求完成，将JSON,时间，当前请求的位置等数据缓存到本地
    2、在进入到一键加油的流程时候，先拿到本地缓存的数据，对时间和位置进行对比，时间超过5分钟，位置移动超过20m，都会重新向服务器请求数据。
    3、在首页生命周期走到onStop()方法时候，将缓存数据进行致空（json=&quot;&quot;;）操作。
    4、3的操作，保证每次打开首页进入到一键加油流程都是最新的数据，同样也保证再次回到首页的时候，在网络情况差，请求不到数据的情况，不会使用上一次缓存的数据
优点：
    优化用户体验，节省流量
缺点：暂未发现
</code></pre></li>
</ul>
<a id="more"></a>
<h3 id="2_u3001_u70ED_u4FEE_u590D_u529F_u80FD_u7684_u662F_u5B9E_u73B0"><a href="#2_u3001_u70ED_u4FEE_u590D_u529F_u80FD_u7684_u662F_u5B9E_u73B0" class="headerlink" title="2、热修复功能的是实现"></a>2、热修复功能的是实现</h3><ul>
<li><p>添加的热修复框架</p>
<pre><code>来源：
    使用的是阿里开源的一个Android热补丁框架（AndFix）
功能：
    允许APP在不重新发布版本的情况下修复线上的bug。
原理：
    apkpatch将两个apk做一次对比，然后找出不同的部分。可以看到生成的apatch了文件，后缀改成zip再解压开，里面有一个dex文件。通过jadx查看一下源码，
    里面就是被修复的代码所在的类文件,这些更改过的类都加上了一个_CF的后缀，并且变动的方法都被加上了一个叫@MethodReplace的annotation，
    通过clazz和method指定了需要替换的方法。然后客户端sdk得到补丁文件后就会根据annotation来寻找需要替换的方法。最后由JNI层完成方法的替换。
优点：
    1、不需要重启APP即可应用补丁。
    2、安全性更好，Nuwa后面的版本应该也会加上安全方面的内容。
支持：
    Android 2.3 到 6.0。
格式：
    .apatch
安全：
    必须使用签名工具进行操作生成的apatch文件，才能进行patch操作
局限：
    1、不支持YunOS
    2、无法添加新类和新的字段
    3、需要使用加固前的apk制作补丁，但是补丁文件很容易被反编译，也就是修改过的类源码容易泄露。
    4、使用加固平台可能会使热补丁功能失效（看到有人在360加固提了这个问题，自己还未验证）。
缺点：
    无法添加类和字段
使用：
    打补丁的过程，首先生成一个apk文件，然后更改代码，在修复bug后生成另一个apk。
    通过官方提供的工具apkpatch
    生成一个.apatch格式的补丁文件，需要提供原apk，修复后的apk，以及一个签名文件。
    可以直接使用命令apkpatch查看具体的使用方法。
</code></pre></li>
</ul>
<h3 id="3-_u5F00_u53D1_u4E2D_u4E00_u952E_u52A0_u6CB9_u7684_u903B_u8F91_u8003_u8651"><a href="#3-_u5F00_u53D1_u4E2D_u4E00_u952E_u52A0_u6CB9_u7684_u903B_u8F91_u8003_u8651" class="headerlink" title="3.开发中一键加油的逻辑考虑"></a>3.开发中一键加油的逻辑考虑</h3><p>*</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copyright (c) 2015 Copyright Holder All Rights Reserved.</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1_u3001_u4E00_u952E_u52A0_u6CB9_u7684_u6570_u636E_u7F13_u5B58_u64CD_u4F5C"><a href="#1_u3001_u4E00_u952E_u52A0_u6CB9_u7684_u6570_u636E_u7F13_u5B58_u64CD_u4F5C" class="headerlink" title="1、一键加油的数据缓存操作"></a>1、一键加油的数据缓存操作</h3><ul>
<li><p>添加缓存</p>
<pre><code>原因：
    开发过程，由于测试服务器的网络带宽，客户端请求数据超级慢，用户的体验非常不好。
工具：
    sharedPreference：
流程：
    1、将一键加油的数据，在进入到主页的时候，进行请求完成，将JSON,时间，当前请求的位置等数据缓存到本地
    2、在进入到一键加油的流程时候，先拿到本地缓存的数据，对时间和位置进行对比，时间超过5分钟，位置移动超过20m，都会重新向服务器请求数据。
    3、在首页生命周期走到onStop()方法时候，将缓存数据进行致空（json=&quot;&quot;;）操作。
    4、3的操作，保证每次打开首页进入到一键加油流程都是最新的数据，同样也保证再次回到首页的时候，在网络情况差，请求不到数据的情况，不会使用上一次缓存的数据
优点：
    优化用户体验，节省流量
缺点：暂未发现
</code></pre></li>
</ul>]]>
    
    </summary>
    
      <category term="反思" scheme="http://yoursite.com/tags/%E5%8F%8D%E6%80%9D/"/>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ActionBar沉浸式实现]]></title>
    <link href="http://yoursite.com/2015/10/09/ActionBar%E6%B2%89%E6%B5%B8%E5%BC%8F%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2015/10/09/ActionBar沉浸式实现/</id>
    <published>2015-10-09T13:56:17.000Z</published>
    <updated>2016-02-23T04:22:02.190Z</updated>
    <content type="html"><![CDATA[<p>studio，中引入沉浸式兼容库 <code>compile &#39;com.readystatesoftware.systembartint:systembartint:1.0.3&#39;</code><br>eclipse，可以导入相应的那个类。</p>
<h3 id="u7B2C_u4E00_u7C7B_uFF0C_u517C_u5BB9actionbar"><a href="#u7B2C_u4E00_u7C7B_uFF0C_u517C_u5BB9actionbar" class="headerlink" title="第一类，兼容actionbar"></a>第一类，兼容actionbar</h3><ul>
<li><p>第一步：设置activity主题android:theme=”@style/ActionBarTheme”</p>
<a id="more"></a>
  <style name="ActionBarTheme" parent="android:Theme.Holo.Light.DarkActionBar">
    <!--API 14 themecustomizationscangohere. -->
    <item name="android:actionBarStyle">@style/ActionBarStyle</item>
  </style>
  <style name="ActionBarStyle" parent="android:Widget.Holo.Light.ActionBar.Solid.Inverse">
    <item name="android:background">@color/actionbar_bg</item>
  </style>
</li>
<li><p>第二步：设置状态栏透明，然后设置状态栏沉浸的颜色</p>
</li>
</ul>
<pre><code>@TargetApi(19)
private void setTranslucentStatus(boolean on) {
Window win = getWindow();
WindowManager.LayoutParams winParams = win.getAttributes();
final int bits = WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS;
    if (on) {
            winParams.flags |= bits;
        } else {
            winParams.flags &amp;= ~bits;
        }
        win.setAttributes(winParams);
    }
@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main);

if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) {
            setTranslucentStatus(true);
        }

SystemBarTintManager tintManager = new SystemBarTintManager(this);
tintManager.setStatusBarTintEnabled(true);
//设置沉浸的颜色        
tintManager.setStatusBarTintResource(R.color.statusbar_bg);
}
</code></pre><ul>
<li>第三步：设置适应windows，在布局文件设置</li>
</ul>
<pre><code>android:fitsSystemWindows=”true”
如果不设置，应用的ui会顶上去，顶进system ui
ok
</code></pre><h3 id="u7B2C_u4E8C_u7C7B__u6CA1_u6709actionbar_u7684activity"><a href="#u7B2C_u4E8C_u7C7B__u6CA1_u6709actionbar_u7684activity" class="headerlink" title="第二类 没有actionbar的activity"></a>第二类 没有actionbar的activity</h3><ul>
<li>第一步，设置主题，android:theme=”@style/FullBleedTheme”</li>
</ul>
<pre><code>&lt;stylename=&quot;FullBleedTheme&quot;parent=&quot;android:Theme.Holo.Light.NoActionBar&quot;&gt;
&lt;!--API 14 themecustomizationscangohere. --&gt;
&lt;/style&gt;
&lt;stylename=&quot;FullBleedTheme&quot;parent=&quot;android:Theme.Holo.Light.NoActionBar.TranslucentDecor&quot;&gt;
&lt;!--API 19 themecustomizationscangohere. --&gt;
&lt;/style&gt;
</code></pre><blockquote>
<p>或者用toolbar只能设置Theme.AppCompat.NoActionBar主题</p>
</blockquote>
<pre><code>&lt;style name=&quot;AppThemeToolbar&quot; parent=&quot;Theme.AppCompat.NoActionBar&quot;&gt;
    &lt;itemname=&quot;colorPrimary&quot;&gt;#2196F3&lt;/item&gt;
    &lt;itemname=&quot;colorPrimaryDark&quot;&gt;#2196F3&lt;/item&gt;
    &lt;!--&lt;item name=&quot;colorPrimaryDark&quot;&gt;#1565C0&lt;/item&gt;--&gt;
    &lt;itemname=&quot;colorAccent&quot;&gt;#E91E63&lt;/item&gt;
&lt;/style&gt;
</code></pre><ul>
<li>第二步：同上一个第二步。<br>设置状态栏透明+颜色</li>
</ul>
<pre><code>mTintManager = new SystemBarTintManager(this);
mTintManager.setStatusBarTintEnabled(true);
mTintManager.setNavigationBarTintEnabled(true);  mTintManager.setStatusBarTintResource(R.color.statusbar_bg);
</code></pre><ul>
<li>第三步：</li>
</ul>
<pre><code>android:fitsSystemWindows=”true”
android:clipToPadding=”false
&lt;item name=&quot;android:fitsSystemWindows&quot;&gt;true&lt;/item&gt;
&lt;item name=&quot;android:clipToPadding&quot;&gt;false&lt;/item&gt;```
</code></pre><h3 id="u53EF_u80FD_u51FA_u73B0_u7684_u95EE_u9898"><a href="#u53EF_u80FD_u51FA_u73B0_u7684_u95EE_u9898" class="headerlink" title="可能出现的问题"></a>可能出现的问题</h3><ul>
<li>android:fitsSystemWindows属性的奇怪问题</li>
</ul>
<blockquote>
<p>官方解释是布局的时候是否考虑系统的状态栏，标题栏，通知栏之类的。</p>
<p>我的实际使用是，为true：那么布局的时候会把系统的状态栏，标题栏，通知栏的高度考虑进去。布局的内容会在状态栏，标题栏，通知栏的下面，不会被遮挡。</p>
<p>但是在项目开发的过程中，突然发现对话框，AlertDialog的内容会超出背景大小，ProgressDialog的内容会超出背景大小并且不居中。</p>
<p>也是很偶然才发现是这个属性造成的。我也没理清楚，大概是这个属性也使对话框考虑了系统的一些元素的缘故。</p>
<p>所以我们在使用这个属性的时候不用直接把这个属性加到theme中。在相关的布局layout中使用就可以了。</p>
</blockquote>
<ul>
<li>Android Toast显示文字超出了背景，文字布局中</li>
</ul>
<blockquote>
<p>项目中突然出现了上述的情况，先开始以为是theme的问题，但是查了很久的资料，也做了很多实验，但是没有效果，还是之前的样子。一个很偶然的情况，<code>Toast.makeText(getActivity(), “密码不可为空”,Toast.LENGTH_SHORT).show();</code>改成了<code>Toast.makeText(App.getInstance(), “密码不可为空”,Toast.LENGTH_SHORT).show();</code>发现就可以了。</p>
<p>别问我，我也不知道原因。</p>
<p>但是这提醒我们，以后的Toast 的上下文参数，直接用ApplicationContext就对了。</p>
</blockquote>
<p>Copyright (c) 2016 Copyright Holder All Rights Reserved.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>studio，中引入沉浸式兼容库 <code>compile &#39;com.readystatesoftware.systembartint:systembartint:1.0.3&#39;</code><br>eclipse，可以导入相应的那个类。</p>
<h3 id="u7B2C_u4E00_u7C7B_uFF0C_u517C_u5BB9actionbar"><a href="#u7B2C_u4E00_u7C7B_uFF0C_u517C_u5BB9actionbar" class="headerlink" title="第一类，兼容actionbar"></a>第一类，兼容actionbar</h3><ul>
<li><p>第一步：设置activity主题android:theme=”@style/ActionBarTheme”</p>]]>
    
    </summary>
    
      <category term="沉浸式" scheme="http://yoursite.com/tags/%E6%B2%89%E6%B5%B8%E5%BC%8F/"/>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android注解(Annotation)自定义注解入门]]></title>
    <link href="http://yoursite.com/2015/07/22/%E6%B3%A8%E8%A7%A3(Annotation)%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2015/07/22/注解(Annotation)自定义注解入门/</id>
    <published>2015-07-22T15:12:17.000Z</published>
    <updated>2016-02-19T09:06:01.365Z</updated>
    <content type="html"><![CDATA[<p>要深入学习注解，我们就必须能定义自己的注解，并使用注解，在定义自己的注解之前，我们就必须要了解Java为我们提供的元注解和相关定义注解的语法。</p>
<p>元注解：<br>元注解的作用就是负责注解其他注解。Java5.0定义了4个标准的<code>meta-annotation</code>类型，它们被用来提供对其它 <code>annotation</code>类型作说明。Java5.0定义的元注解：<a id="more"></a></p>
<pre><code>1.@Target,
2.@Retention,
3.@Documented,
4.@Inherited
</code></pre><p>这些类型和它们所支持的类在<code>java.lang.annotation</code>包中可以找到。下面我们看一下每个元注解的作用和相应分参数的使用说明。</p>
<h4 id="@Target_uFF1A"><a href="#@Target_uFF1A" class="headerlink" title="@Target："></a>@Target：</h4><blockquote>
<p>@Target说明了Annotation所修饰的对象范围：Annotation可被用于 packages、types（类、接口、枚举、Annotation类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数）。在Annotation类型的声明中使用了target可更加明晰其修饰的目标。<br>作用：用于描述注解的使用范围（即：被描述的注解可以用在什么地方）<br>取值(ElementType)有：</p>
<ul>
<li>1.CONSTRUCTOR:用于描述构造器</li>
<li>2.FIELD:用于描述域</li>
<li>3.LOCAL_VARIABLE:用于描述局部变量</li>
<li>4.METHOD:用于描述方法</li>
<li>5.PACKAGE:用于描述包</li>
<li>6.PARAMETER:用于描述参数</li>
<li>7.TYPE:用于描述类、接口(包括注解类型) 或enum声明</li>
</ul>
</blockquote>
<p>使用实例：</p>
<pre><code>@Target(ElementType.TYPE)
public @interface Table {
    /**
     * 数据表名称注解，默认值为类名称
     * @return
     */
    public String tableName() default &quot;className&quot;;
}
@Target(ElementType.FIELD)
public @interface NoDBColumn {
}
</code></pre><h3 id="u6CE8_u89E3Table"><a href="#u6CE8_u89E3Table" class="headerlink" title="注解Table"></a>注解Table</h3><p>可以用于注解类、接口(包括注解类型) 或enum声明,而注解NoDBColumn仅可用于注解类的成员变量。</p>
<h4 id="@Retention_uFF1A"><a href="#@Retention_uFF1A" class="headerlink" title="@Retention："></a>@Retention：</h4><blockquote>
<p>@Retention定义了该Annotation被保留的时间长短：某些Annotation仅出现在源代码中，而被编译器丢弃；而另一些却被编译在class文件中；编译在class文件中的Annotation可能会被虚拟机忽略，而另一些在class被装载时将被读取（请注意并不影响class的执行，因为Annotation与class在使用上是被分离的）。使用这个meta-Annotation可以对 Annotation的“生命周期”限制。<br>作用：表示需要在什么级别保存该注释信息，用于描述注解的生命周期（即：被描述的注解在什么范围内有效）<br>取值（RetentionPoicy）有：</p>
<ul>
<li>1.SOURCE:在源文件中有效（即源文件保留）</li>
<li>2.CLASS:在class文件中有效（即class保留）</li>
<li>3.RUNTIME:在运行时有效（即运行时保留）</li>
</ul>
</blockquote>
<h4 id="Retention"><a href="#Retention" class="headerlink" title="Retention"></a>Retention</h4><blockquote>
<p>meta-annotation类型有唯一的value作为成员，它的取值来自java.lang.annotation.RetentionPolicy的枚举类型值。具体实例如下：</p>
</blockquote>
<pre><code>@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Column {
    public String name() default &quot;fieldName&quot;;
    public String setFuncName() default &quot;setField&quot;;
    public String getFuncName() default &quot;getField&quot;;
    public boolean defaultDBValue() default false;
}
</code></pre><blockquote>
<p>Column注解的的RetentionPolicy的属性值是RUTIME,这样注解处理器可以通过反射，获取到该注解的属性值，从而去做一些运行时的逻辑处理</p>
</blockquote>
<h4 id="@Documented_3A"><a href="#@Documented_3A" class="headerlink" title="@Documented:"></a>@Documented:</h4><p>@Documented用于描述其它类型的annotation应该被作为被标注的程序成员的公共API，因此可以被例如javadoc此类的工具文档化。Documented是一个标记注解，没有成员。</p>
<pre><code>@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Column {
    public String name() default &quot;fieldName&quot;;
    public String setFuncName() default &quot;setField&quot;;
    public String getFuncName() default &quot;getField&quot;;
    public boolean defaultDBValue() default false;
}
</code></pre><h4 id="@Inherited_uFF1A"><a href="#@Inherited_uFF1A" class="headerlink" title="@Inherited："></a>@Inherited：</h4><p>@Inherited 元注解是一个标记注解，@Inherited阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类。</p>
<blockquote>
<p>注意：@Inherited annotation类型是被标注过的class的子类所继承。类并不从它所实现的接口继承annotation，方法并不从它所重载的方法继承annotation。<br>当@Inherited annotation类型标注的annotation的Retention是RetentionPolicy.RUNTIME，则反射API增强了这种继承性。如果我们使用java.lang.reflect去查询一个@Inherited annotation类型的annotation时，反射代码检查将展开工作：检查class和其父类，直到发现指定的annotation类型被发现，或者到达类继承结构的顶层。</p>
</blockquote>
<p>实例代码：</p>
<pre><code>/**
 *
 * @author peida
 *
 */
@Inherited
public @interface Greeting {
    public enum FontColor{ BULE,RED,GREEN};
    String name();
    FontColor fontColor() default FontColor.GREEN;
}
</code></pre><h3 id="u81EA_u5B9A_u4E49_u6CE8_u89E3_uFF1A"><a href="#u81EA_u5B9A_u4E49_u6CE8_u89E3_uFF1A" class="headerlink" title="自定义注解："></a>自定义注解：</h3><blockquote>
<p>使用@interface自定义注解时，自动继承了java.lang.annotation.Annotation接口，由编译程序自动完成其他细节。在定义注解时，不能继承其他的注解或接口。@interface用来声明一个注解，其中的每一个方法实际上是声明了一个配置参数。方法的名称就是参数的名称，返回值类型就是参数的类型（返回值类型只能是基本类型、Class、String、enum）。可以通过default来声明参数的默认值。</p>
</blockquote>
<hr>
<blockquote>
<p>定义注解格式：<br>public @interface 注解名 {定义体}</p>
</blockquote>
<hr>
<blockquote>
<p>注解参数的可支持数据类型：</p>
</blockquote>
<ul>
<li>1.所有基本数据类型（int,float,boolean,byte,double,char,long,short)</li>
<li>2.String类型</li>
<li>3.Class类型</li>
<li>4.enum类型</li>
<li>5.Annotation类型</li>
<li>6.以上所有类型的数组</li>
</ul>
<p>Annotation类型里面的参数该怎么设定:</p>
<blockquote>
<p>第一,只能用public或默认(default)这两个访问权修饰.例如,String value();这里把方法设为defaul默认类型；</p>
</blockquote>
<hr>
<blockquote>
<p>第二,参数成员只能用基本类型byte,short,char,int,long,float,double,boolean八种基本数据类型和 String,Enum,Class,annotations等数据类型,以及这一些类型的数组.例如,String value();这里的参数成员就为String;</p>
</blockquote>
<hr>
<blockquote>
<p>第三,如果只有一个参数成员,最好把参数名称设为”value”,后加小括号.例:下面的例子FruitName注解就只有一个参数成员。</p>
</blockquote>
<hr>
<p>简单的自定义注解和使用注解实例：</p>
<pre><code>package annotation;
import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * 水果名称注解
 * @author peida
 *
 */
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface FruitName {
    String value() default &quot;&quot;;
}
</code></pre><hr>
<pre><code>package annotation;
import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * 水果颜色注解
 * @author peida
 *
 */
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface FruitColor {
    /**
     * 颜色枚举
     * @author peida
     *
     */
    public enum Color{ BULE,RED,GREEN};

    /**
     * 颜色属性
     * @return
     */
    Color fruitColor() default Color.GREEN;
}
</code></pre><hr>
<pre><code>package annotation;
import annotation.FruitColor.Color;
public class Apple {

    @FruitName(&quot;Apple&quot;)
    private String appleName;

    @FruitColor(fruitColor=Color.RED)
    private String appleColor;




    public void setAppleColor(String appleColor) {
        this.appleColor = appleColor;
    }
    public String getAppleColor() {
        return appleColor;
    }


    public void setAppleName(String appleName) {
        this.appleName = appleName;
    }
    public String getAppleName() {
        return appleName;
    }

    public void displayName(){
        System.out.println(&quot;水果的名字是：苹果&quot;);
    }
}
</code></pre><h4 id="u6CE8_u89E3_u5143_u7D20_u7684_u9ED8_u8BA4_u503C_uFF1A"><a href="#u6CE8_u89E3_u5143_u7D20_u7684_u9ED8_u8BA4_u503C_uFF1A" class="headerlink" title="注解元素的默认值："></a>注解元素的默认值：</h4><blockquote>
<p>注解元素必须有确定的值，要么在定义注解的默认值中指定，要么在使用注解时指定，非基本类型的注解元素的值不可为null。因此, 使用空字符串或0作为默认值是一种常用的做法。这个约束使得处理器很难表现一个元素的存在或缺失的状态，因为每个注解的声明中，所有元素都存在，并且都具有相应的值，为了绕开这个约束，我们只能定义一些特殊的值，例如空字符串或者负数，一次表示某个元素不存在，在定义注解时，这已经成为一个习惯用法。</p>
</blockquote>
<p>例如：</p>
<pre><code> 1 package annotation;
 2
 3 import java.lang.annotation.Documented;
 4 import java.lang.annotation.ElementType;
 5 import java.lang.annotation.Retention;
 6 import java.lang.annotation.RetentionPolicy;
 7 import java.lang.annotation.Target;
 8
 9 /**
10  * 水果供应者注解
11  * @author peida
12  *
13  */
14 @Target(ElementType.FIELD)
15 @Retention(RetentionPolicy.RUNTIME)
16 @Documented
17 public @interface FruitProvider {
18     /**
19      * 供应商编号
20      * @return
21      */
22     public int id() default -1;
23     
24     /**
25      * 供应商名称
26      * @return
27      */
28     public String name() default &quot;&quot;;
29     
30     /**
31      * 供应商地址
32      * @return
33      */
34     public String address() default &quot;&quot;;
35 }
</code></pre><blockquote>
<p>定义了注解，并在需要的时候给相关类，类属性加上注解信息，如果没有响应的注解信息处理流程，注解可以说是没有实用价值。如何让注解真真的发挥作用，主要就在于注解处理方法，下一步我们将学习注解信息的获取和处理！</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>要深入学习注解，我们就必须能定义自己的注解，并使用注解，在定义自己的注解之前，我们就必须要了解Java为我们提供的元注解和相关定义注解的语法。</p>
<p>元注解：<br>元注解的作用就是负责注解其他注解。Java5.0定义了4个标准的<code>meta-annotation</code>类型，它们被用来提供对其它 <code>annotation</code>类型作说明。Java5.0定义的元注解：]]>
    
    </summary>
    
      <category term="Annotation" scheme="http://yoursite.com/tags/Annotation/"/>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android OkHttp完全解析]]></title>
    <link href="http://yoursite.com/2015/07/21/Android%20OkHttp%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2015/07/21/Android OkHttp完全解析/</id>
    <published>2015-07-21T05:56:17.000Z</published>
    <updated>2016-02-19T09:08:00.429Z</updated>
    <content type="html"><![CDATA[<h2 id="u4E00_u3001_u6982_u8FF0"><a href="#u4E00_u3001_u6982_u8FF0" class="headerlink" title="一、概述"></a>一、概述</h2><blockquote>
<p>最近在群里听到各种讨论okhttp的话题，可见okhttp的口碑相当好了。再加上Google貌似在6.0版本里面删除了HttpClient相关API，对于这个行为不做评价。为了更好的在应对网络访问，学习下okhttp还是蛮必要的，本篇博客首先介绍okhttp的简单使用，主要包含：</p>
</blockquote>
<a id="more"></a>
<pre><code>• 一般的get请求
• 一般的post请求
• 基于Http的文件上传
• 文件下载
• 加载图片
• 支持请求回调，直接返回对象、对象集合
• 支持session的保持
</code></pre><p>最后会对上述几个功能进行封装，完整的封装类的地址见：<code>https://github.com/hongyangAndroid/okhttp-utils</code><br>使用前，对于Android Studio的用户，可以选择添加:<br><code>compile &#39;com.squareup.okhttp:okhttp:2.4.0&#39;</code></p>
<p>或者Eclipse的用户，可以下载最新的jar okhttp he latest JAR ，添加依赖就可以用了。<br>注意:okhttp内部依赖okio，别忘了同时导入okio：<br><code>gradle: compile &#39;com.squareup.okio:okio:1.5.0&#39;</code></p>
<h2 id="u4E8C_u3001_u4F7F_u7528_u6559_u7A0B"><a href="#u4E8C_u3001_u4F7F_u7528_u6559_u7A0B" class="headerlink" title="二、使用教程"></a>二、使用教程</h2><h3 id="uFF08_u4E00_uFF09Http_Get"><a href="#uFF08_u4E00_uFF09Http_Get" class="headerlink" title="（一）Http Get"></a>（一）Http Get</h3><p>对了网络加载库，那么最常见的肯定就是http get请求了，比如获取一个网页的内容。</p>
<pre><code>//创建okHttpClient对象
OkHttpClient mOkHttpClient = new OkHttpClient();
//创建一个Request
final Request request = new Request.Builder()
                .url(&quot;https://github.com/hongyangAndroid&quot;)
                .build();
//new call
Call call = mOkHttpClient.newCall(request);
//请求加入调度
call.enqueue(new Callback()
        {
            @Override
            public void onFailure(Request request, IOException e)
            {
            }
@Override
            public void onResponse(final Response response) throws IOException
            {
                    //String htmlStr =  response.body().string();
            }
        });
</code></pre><h4 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h4><p> 以上就是发送一个get请求的步骤，首先构造一个Request对象，参数最起码有个url，当然你可以通过Request.Builder设置更多的参数比如：header、method等。</p>
<h4 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h4><p> 然后通过request的对象去构造得到一个Call对象，类似于将你的请求封装成了任务，既然是任务，就会有execute()和cancel()等方法。</p>
<h4 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h4><p> 最后，我们希望以异步的方式去执行请求，所以我们调用的是call.enqueue，将call加入调度队列，然后等待任务执行完成，我们在Callback中即可得到结果。<br>看到这，你会发现，整体的写法还是比较长的，所以封装肯定是要做的，不然每个请求这么写，得累死。</p>
<h4 id="ok_uFF0C_u9700_u8981_u6CE8_u610F_u51E0_u70B9_uFF1A"><a href="#ok_uFF0C_u9700_u8981_u6CE8_u610F_u51E0_u70B9_uFF1A" class="headerlink" title="ok，需要注意几点："></a>ok，需要注意几点：</h4><ul>
<li>onResponse回调的参数是response，一般情况下，比如我们希望获得返回的字符串，可以通过<code>response.body().string()``获取；如果希望获得返回的二进制字节数组，则调用</code>response.body().bytes()<code>；如果你想拿到返回的inputStream，则调用`response.body().byteStream()</code><br>看到这，你可能会奇怪，竟然还能拿到返回的<code>inputStream</code>，看到这个最起码能意识到一点，这里支持大文件下载，有<code>inputStream</code>我们就可以通过IO的方式写文件。不过也说明一个问题，这个<code>onResponse</code>执行的线程并不是UI线程。的确是的，如果你希望操作控件，还是需要使用<code>handler</code>等，例如：</li>
</ul>
<pre><code>@Override
public void onResponse(final Response response) throws IOException
{
      final String res = response.body().string();
      runOnUiThread(new Runnable()
      {
          @Override
          public void run()
          {
            mTv.setText(res);
          }

});
}
</code></pre><p> 我们这里是异步的方式去执行，当然也支持阻塞的方式，上面我们也说了Call有一个execute()方法，你也可以直接调用<code>call.execute()</code>通过返回一个Response。</p>
<h3 id="28_u4E8C_29_Http_Post__u643A_u5E26_u53C2_u6570"><a href="#28_u4E8C_29_Http_Post__u643A_u5E26_u53C2_u6570" class="headerlink" title="(二) Http Post 携带参数"></a>(二) Http Post 携带参数</h3><p>看来上面的简单的get请求，基本上整个的用法也就掌握了，比如post携带参数，也仅仅是Request的构造的不同。</p>
<pre><code>Request request = buildMultipartFormRequest(
        url, new File[]{file}, new String[]{fileKey}, null);
FormEncodingBuilder builder = new FormEncodingBuilder();
builder.add(&quot;username&quot;,&quot;张鸿洋&quot;);
Request request = new Request.Builder()
                   .url(url)
                .post(builder.build())
                .build();
 mOkHttpClient.newCall(request).enqueue(new Callback(){});
</code></pre><p>大家都清楚，post的时候，参数是包含在请求体中的；所以我们通过<code>FormEncodingBuilder</code>。添加多个String键值对，然后去构造<code>RequestBody</code>，最后完成我们Request的构造。<br>后面的就和上面一样了。</p>
<h3 id="uFF08_u4E09_uFF09_u57FA_u4E8EHttp_u7684_u6587_u4EF6_u4E0A_u4F20"><a href="#uFF08_u4E09_uFF09_u57FA_u4E8EHttp_u7684_u6587_u4EF6_u4E0A_u4F20" class="headerlink" title="（三）基于Http的文件上传"></a>（三）基于Http的文件上传</h3><p>接下来我们在介绍一个可以构造RequestBody的Builder，叫做<code>MultipartBuilder</code>。当我们需要做类似于表单上传的时候，就可以使用它来构造我们的requestBody。</p>
<pre><code>File file = new File(Environment.getExternalStorageDirectory(), &quot;balabala.mp4&quot;);
RequestBody fileBody = RequestBody.create(MediaType.parse(&quot;application/octet-stream&quot;), file);
RequestBody requestBody = new MultipartBuilder()
     .type(MultipartBuilder.FORM)
     .addPart(Headers.of(
          &quot;Content-Disposition&quot;,
              &quot;form-data; name=\&quot;username\&quot;&quot;),
          RequestBody.create(null, &quot;张鸿洋&quot;))
     .addPart(Headers.of(
         &quot;Content-Disposition&quot;,
         &quot;form-data; name=\&quot;mFile\&quot;;
         filename=\&quot;wjd.mp4\&quot;&quot;), fileBody)
     .build();
Request request = new Request.Builder()
    .url(&quot;http://192.168.1.103:8080/okHttpServer/fileUpload&quot;)
    .post(requestBody)
    .build();
Call call = mOkHttpClient.newCall(request);
call.enqueue(new Callback()
{
    //...
});
</code></pre><p>上述代码向服务器传递了一个键值对username:张鸿洋和一个文件。我们通过MultipartBuilder的addPart方法可以添加键值对或者文件。<br>其实类似于我们拼接模拟浏览器行为的方式，如果你对这块不了解，可以参考：从原理角度解析Android （Java） http 文件上传<br>ok，对于我们最开始的目录还剩下图片下载，文件下载；这两个一个是通过回调的Response拿到byte[]然后decode成图片；文件下载，就是拿到inputStream做写文件操作，我们这里就不赘述了。</p>
<p>接下来我们主要看如何封装上述的代码。</p>
<h2 id="u4E09_u3001_u5C01_u88C5"><a href="#u4E09_u3001_u5C01_u88C5" class="headerlink" title="三、封装"></a>三、封装</h2><p>由于按照上述的代码，写多个请求肯定包含大量的重复代码，所以我希望封装后的代码调用是这样的：</p>
<h3 id="uFF08_u4E00_uFF09_u4F7F_u7528"><a href="#uFF08_u4E00_uFF09_u4F7F_u7528" class="headerlink" title="（一）使用"></a>（一）使用</h3><h4 id="4-__u4E00_u822C_u7684get_u8BF7_u6C42"><a href="#4-__u4E00_u822C_u7684get_u8BF7_u6C42" class="headerlink" title="4. 一般的get请求"></a>4. 一般的get请求</h4><pre><code> OkHttpClientManager.getAsyn(&quot;https://www.baidu.com&quot;, new OkHttpClientManager.ResultCallback&lt;String&gt;()
        {
            @Override
            public void onError(Request request, Exception e)
            {
                e.printStackTrace();
            }

@Override
            public void onResponse(String u)
            {
                mTv.setText(u);//注意这里是UI线程
            }
        });
</code></pre><p>对于一般的请求，我们希望给个url，然后CallBack里面直接操作控件。</p>
<h4 id="5-__u6587_u4EF6_u4E0A_u4F20_u4E14_u643A_u5E26_u53C2_u6570"><a href="#5-__u6587_u4EF6_u4E0A_u4F20_u4E14_u643A_u5E26_u53C2_u6570" class="headerlink" title="5. 文件上传且携带参数"></a>5. 文件上传且携带参数</h4><p>我们希望提供一个方法，传入url,params,file,callback即可。</p>
<pre><code> OkHttpClientManager.postAsyn(&quot;http://192.168.1.103:8080/okHttpServer/fileUpload&quot;,//
    new OkHttpClientManager.ResultCallback&lt;String&gt;()
    {
        @Override
        public void onError(Request request, IOException e)
        {
            e.printStackTrace();
        }

@Override
        public void onResponse(String result)
        {

}
    },//
    file,//
    &quot;mFile&quot;,//
    new OkHttpClientManager.Param[]{
            new OkHttpClientManager.Param(&quot;username&quot;, &quot;zhy&quot;),
            new OkHttpClientManager.Param(&quot;password&quot;, &quot;123&quot;)}
        );
</code></pre><p>键值对没什么说的，参数3为file，参数4为file对应的name，这个name不是文件的名字；<br>对应于http中的</p>
<pre><code>&lt;input type=&quot;file&quot; name=&quot;mFile&quot; &gt;
</code></pre><p>对应的是name后面的值，即mFile.</p>
<h4 id="6-__u6587_u4EF6_u4E0B_u8F7D"><a href="#6-__u6587_u4EF6_u4E0B_u8F7D" class="headerlink" title="6. 文件下载"></a>6. 文件下载</h4><p>对于文件下载，提供url，目标dir，callback即可。</p>
<pre><code>OkHttpClientManager.downloadAsyn(
    &quot;http://192.168.1.103:8080/okHttpServer/files/messenger_01.png&quot;,
    Environment.getExternalStorageDirectory().getAbsolutePath(),
new OkHttpClientManager.ResultCallback&lt;String&gt;()
    {
        @Override
        public void onError(Request request, IOException e)
        {

}

@Override
        public void onResponse(String response)
        {
            //文件下载成功，这里回调的reponse为文件的absolutePath
        }
});
</code></pre><h4 id="7-__u5C55_u793A_u56FE_u7247"><a href="#7-__u5C55_u793A_u56FE_u7247" class="headerlink" title="7. 展示图片"></a>7. 展示图片</h4><p>展示图片，我们希望提供一个url和一个imageview，如果下载成功，直接帮我们设置上即可。</p>
<pre><code>OkHttpClientManager.displayImage(mImageView,
    &quot;http://images.csdn.net/20150817/1.jpg&quot;);
</code></pre><p>内部会自动根据imageview的大小自动对图片进行合适的压缩。虽然，这里可能不适合一次性加载大量图片的场景，但是对于app中偶尔有几个图片的加载，还是可用的。</p>
<h2 id="u56DB_u3001_u6574_u5408Gson"><a href="#u56DB_u3001_u6574_u5408Gson" class="headerlink" title="四、整合Gson"></a>四、整合Gson</h2><p>很多人提出项目中使用时，服务端返回的是Json字符串，希望客户端回调可以直接拿到对象，于是整合进入了Gson，完善该功能。</p>
<h3 id="uFF08_u4E00_uFF09_u76F4_u63A5_u56DE_u8C03_u5BF9_u8C61"><a href="#uFF08_u4E00_uFF09_u76F4_u63A5_u56DE_u8C03_u5BF9_u8C61" class="headerlink" title="（一）直接回调对象"></a>（一）直接回调对象</h3><p>例如现在有个User实体类：</p>
<pre><code>package com.zhy.utils.http.okhttp;
public class User {
public String username ;
    public String password  ;
public User() {
        // TODO Auto-generated constructor stub
    }
public User(String username, String password) {
        this.username = username;
        this.password = password;
    }
@Override
    public String toString()
    {
        return &quot;User{&quot; +
                &quot;username=&apos;&quot; + username + &apos;\&apos;&apos; +
                &quot;, password=&apos;&quot; + password + &apos;\&apos;&apos; +
                &apos;}&apos;;
    }
}
</code></pre><p>服务端返回：</p>
<pre><code>{&quot;username&quot;:&quot;zhy&quot;,&quot;password&quot;:&quot;123&quot;}
</code></pre><p>客户端可以如下方式调用：</p>
<pre><code> OkHttpClientManager.getAsyn(&quot;http://192.168.56.1:8080/okHttpServer/user!getUser&quot;,
new OkHttpClientManager.ResultCallback&lt;User&gt;()
{
    @Override
    public void onError(Request request, Exception e)
    {
        e.printStackTrace();
    }
@Override
    public void onResponse(User user)
    {
        mTv.setText(u.toString());//UI线程
    }
});
</code></pre><p>我们传入泛型User，在onResponse里面直接回调User对象。</p>
<p>这里特别要注意的事，如果在json字符串-&gt;实体对象过程中发生错误，程序不会崩溃，onError方法会被回调。<br>注意：这里做了少许的更新，接口命名从StringCallback修改为ResultCallback。接口中的onFailure方法修改为onError。</p>
<h3 id="28_u4E8C_29__u56DE_u8C03_u5BF9_u8C61_u96C6_u5408"><a href="#28_u4E8C_29__u56DE_u8C03_u5BF9_u8C61_u96C6_u5408" class="headerlink" title="(二) 回调对象集合"></a>(二) 回调对象集合</h3><p>依然是上述的User类，服务端返回</p>
<pre><code>[{&quot;username&quot;:&quot;zhy&quot;,&quot;password&quot;:&quot;123&quot;},{&quot;username&quot;:&quot;lmj&quot;,&quot;password&quot;:&quot;12345&quot;}]
</code></pre><p>则客户端可以如下调用：</p>
<pre><code>OkHttpClientManager.getAsyn(&quot;http://192.168.56.1:8080/okHttpServer/user!getUsers&quot;,
new OkHttpClientManager.ResultCallback&lt;List&lt;User&gt;&gt;()
{
    @Override
    public void onError(Request request, Exception e)
    {
        e.printStackTrace();
    }
    @Override
    public void onResponse(List&lt;User&gt; us)
    {
        Log.e(&quot;TAG&quot;, us.size() + &quot;&quot;);
        mTv.setText(us.get(1).toString());
    }
});
</code></pre><p>唯一的区别，就是泛型变为List<user> ，ok ， 如果发现bug或者有任何意见欢迎留言。</user></p>
<h3 id="u6E90_u7801"><a href="#u6E90_u7801" class="headerlink" title="源码"></a>源码</h3><p>ok，基本介绍完了，对于封装的代码其实也很简单，我就直接贴出来了，因为也没什么好介绍的，如果你看完上面的用法，肯定可以看懂：</p>
<pre><code>package com.zhy.utils.http.okhttp;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.os.Handler;
import android.os.Looper;
import android.widget.ImageView;
import com.google.gson.Gson;
import com.google.gson.internal.$Gson$Types;
import com.squareup.okhttp.Call;
import com.squareup.okhttp.Callback;
import com.squareup.okhttp.FormEncodingBuilder;
import com.squareup.okhttp.Headers;
import com.squareup.okhttp.MediaType;
import com.squareup.okhttp.MultipartBuilder;
import com.squareup.okhttp.OkHttpClient;
import com.squareup.okhttp.Request;
import com.squareup.okhttp.RequestBody;
import com.squareup.okhttp.Response;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.net.CookieManager;
import java.net.CookiePolicy;
import java.net.FileNameMap;
import java.net.URLConnection;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
/**
 * Created by zhy on 15/8/17.
 */
public class OkHttpClientManager
{
    private static OkHttpClientManager mInstance;
    private OkHttpClient mOkHttpClient;
    private Handler mDelivery;
    private Gson mGson;
private static final String TAG = &quot;OkHttpClientManager&quot;;
private OkHttpClientManager()
    {
        mOkHttpClient = new OkHttpClient();
        //cookie enabled
        mOkHttpClient.setCookieHandler(new CookieManager(null, CookiePolicy.ACCEPT_ORIGINAL_SERVER));
        mDelivery = new Handler(Looper.getMainLooper());
        mGson = new Gson();
    }
public static OkHttpClientManager getInstance()
    {
        if (mInstance == null)
        {
            synchronized (OkHttpClientManager.class)
            {
                if (mInstance == null)
                {
                    mInstance = new OkHttpClientManager();
                }
            }
        }
        return mInstance;
    }
/**
     * 同步的Get请求
     *
     * @param url
     * @return Response
     */
    private Response _getAsyn(String url) throws IOException
    {
        final Request request = new Request.Builder()
                .url(url)
                .build();
        Call call = mOkHttpClient.newCall(request);
        Response execute = call.execute();
        return execute;
    }
/**
     * 同步的Get请求
     *
     * @param url
     * @return 字符串
     */
    private String _getAsString(String url) throws IOException
    {
        Response execute = _getAsyn(url);
        return execute.body().string();
    }
/**
     * 异步的get请求
     *
     * @param url
     * @param callback
     */
    private void _getAsyn(String url, final ResultCallback callback)
    {
        final Request request = new Request.Builder()
                .url(url)
                .build();
        deliveryResult(callback, request);
    }
/**
     * 同步的Post请求
     *
     * @param url
     * @param params post的参数
     * @return
     */
    private Response _post(String url, Param... params) throws IOException
    {
        Request request = buildPostRequest(url, params);
        Response response = mOkHttpClient.newCall(request).execute();
        return response;
    }
/**
     * 同步的Post请求
     *
     * @param url
     * @param params post的参数
     * @return 字符串
     */
    private String _postAsString(String url, Param... params) throws IOException
    {
        Response response = _post(url, params);
        return response.body().string();
    }
/**
     * 异步的post请求
     *
     * @param url
     * @param callback
     * @param params
     */
    private void _postAsyn(String url, final ResultCallback callback, Param... params)
    {
        Request request = buildPostRequest(url, params);
        deliveryResult(callback, request);
    }
/**
     * 异步的post请求
     *
     * @param url
     * @param callback
     * @param params
     */
    private void _postAsyn(String url, final ResultCallback callback, Map&lt;String, String&gt; params)
    {
        Param[] paramsArr = map2Params(params);
        Request request = buildPostRequest(url, paramsArr);
        deliveryResult(callback, request);
    }
/**
     * 同步基于post的文件上传
     *
     * @param params
     * @return
     */
    private Response _post(String url, File[] files, String[] fileKeys, Param... params) throws IOException
    {
        Request request = buildMultipartFormRequest(url, files, fileKeys, params);
        return mOkHttpClient.newCall(request).execute();
    }
private Response _post(String url, File file, String fileKey) throws IOException
    {
        Request request = buildMultipartFormRequest(url, new File[]{file}, new String[]{fileKey}, null);
        return mOkHttpClient.newCall(request).execute();
    }
private Response _post(String url, File file, String fileKey, Param... params) throws IOException
    {
        Request request = buildMultipartFormRequest(url, new File[]{file}, new String[]{fileKey}, params);
        return mOkHttpClient.newCall(request).execute();
    }
/**
     * 异步基于post的文件上传
     *
     * @param url
     * @param callback
     * @param files
     * @param fileKeys
     * @throws IOException
     */
    private void _postAsyn(String url, ResultCallback callback, File[] files, String[] fileKeys, Param... params) throws IOException
    {
        Request request = buildMultipartFormRequest(url, files, fileKeys, params);
        deliveryResult(callback, request);
    }
/**
     * 异步基于post的文件上传，单文件不带参数上传
     *
     * @param url
     * @param callback
     * @param file
     * @param fileKey
     * @throws IOException
     */
    private void _postAsyn(String url, ResultCallback callback, File file, String fileKey) throws IOException
    {
        Request request = buildMultipartFormRequest(url, new File[]{file}, new String[]{fileKey}, null);
        deliveryResult(callback, request);
    }
/**
     * 异步基于post的文件上传，单文件且携带其他form参数上传
     *
     * @param url
     * @param callback
     * @param file
     * @param fileKey
     * @param params
     * @throws IOException
     */
    private void _postAsyn(String url, ResultCallback callback, File file, String fileKey, Param... params) throws IOException
    {
        Request request = buildMultipartFormRequest(url, new File[]{file}, new String[]{fileKey}, params);
        deliveryResult(callback, request);
    }
/**
     * 异步下载文件
     *
     * @param url
     * @param destFileDir 本地文件存储的文件夹
     * @param callback
     */
    private void _downloadAsyn(final String url, final String destFileDir, final ResultCallback callback)
    {
        final Request request = new Request.Builder()
                .url(url)
                .build();
        final Call call = mOkHttpClient.newCall(request);
        call.enqueue(new Callback()
        {
            @Override
            public void onFailure(final Request request, final IOException e)
            {
                sendFailedStringCallback(request, e, callback);
            }
@Override
            public void onResponse(Response response)
            {
                InputStream is = null;
                byte[] buf = new byte[2048];
                int len = 0;
                FileOutputStream fos = null;
                try
                {
                    is = response.body().byteStream();
                    File file = new File(destFileDir, getFileName(url));
                    fos = new FileOutputStream(file);
                    while ((len = is.read(buf)) != -1)
                    {
                        fos.write(buf, 0, len);
                    }
                    fos.flush();
                    //如果下载文件成功，第一个参数为文件的绝对路径
                    sendSuccessResultCallback(file.getAbsolutePath(), callback);
                } catch (IOException e)
                {
                    sendFailedStringCallback(response.request(), e, callback);
                } finally
                {
                    try
                    {
                        if (is != null) is.close();
                    } catch (IOException e)
                    {
                    }
                    try
                    {
                        if (fos != null) fos.close();
                    } catch (IOException e)
                    {
                    }
                }
}
        });
    }
private String getFileName(String path)
    {
        int separatorIndex = path.lastIndexOf(&quot;/&quot;);
        return (separatorIndex &lt; 0) ? path : path.substring(separatorIndex + 1, path.length());
    }
/**
     * 加载图片
     *
     * @param view
     * @param url
     * @throws IOException
     */
    private void _displayImage(final ImageView view, final String url, final int errorResId)
    {
        final Request request = new Request.Builder()
                .url(url)
                .build();
        Call call = mOkHttpClient.newCall(request);
        call.enqueue(new Callback()
        {
            @Override
            public void onFailure(Request request, IOException e)
            {
                setErrorResId(view, errorResId);
            }
@Override
            public void onResponse(Response response)
            {
                InputStream is = null;
                try
                {
                    is = response.body().byteStream();
                    ImageUtils.ImageSize actualImageSize = ImageUtils.getImageSize(is);
                    ImageUtils.ImageSize imageViewSize = ImageUtils.getImageViewSize(view);
                    int inSampleSize = ImageUtils.calculateInSampleSize(actualImageSize, imageViewSize);
                    try
                    {
                        is.reset();
                    } catch (IOException e)
                    {
                        response = _getAsyn(url);
                        is = response.body().byteStream();
                    }
BitmapFactory.Options ops = new BitmapFactory.Options();
                    ops.inJustDecodeBounds = false;
                    ops.inSampleSize = inSampleSize;
                    final Bitmap bm = BitmapFactory.decodeStream(is, null, ops);
                    mDelivery.post(new Runnable()
                    {
                        @Override
                        public void run()
                        {
                            view.setImageBitmap(bm);
                        }
                    });
                } catch (Exception e)
                {
                    setErrorResId(view, errorResId);
} finally
                {
                    if (is != null) try
                    {
                        is.close();
                    } catch (IOException e)
                    {
                        e.printStackTrace();
                    }
                }
            }
        });
}
private void setErrorResId(final ImageView view, final int errorResId)
    {
        mDelivery.post(new Runnable()
        {
            @Override
            public void run()
            {
                view.setImageResource(errorResId);
            }
        });
    }
//*************对外公布的方法************
public static Response getAsyn(String url) throws IOException
    {
        return getInstance()._getAsyn(url);
    }
public static String getAsString(String url) throws IOException
    {
        return getInstance()._getAsString(url);
    }
public static void getAsyn(String url, ResultCallback callback)
    {
        getInstance()._getAsyn(url, callback);
    }
public static Response post(String url, Param... params) throws IOException
    {
        return getInstance()._post(url, params);
    }
public static String postAsString(String url, Param... params) throws IOException
    {
        return getInstance()._postAsString(url, params);
    }
public static void postAsyn(String url, final ResultCallback callback, Param... params)
    {
        getInstance()._postAsyn(url, callback, params);
    }
public static void postAsyn(String url, final ResultCallback callback, Map&lt;String, String&gt; params)
    {
        getInstance()._postAsyn(url, callback, params);
    }
public static Response post(String url, File[] files, String[] fileKeys, Param... params) throws IOException
    {
        return getInstance()._post(url, files, fileKeys, params);
    }
public static Response post(String url, File file, String fileKey) throws IOException
    {
        return getInstance()._post(url, file, fileKey);
    }
public static Response post(String url, File file, String fileKey, Param... params) throws IOException
    {
        return getInstance()._post(url, file, fileKey, params);
    }
public static void postAsyn(String url, ResultCallback callback, File[] files, String[] fileKeys, Param... params) throws IOException
    {
        getInstance()._postAsyn(url, callback, files, fileKeys, params);
    }
public static void postAsyn(String url, ResultCallback callback, File file, String fileKey) throws IOException
    {
        getInstance()._postAsyn(url, callback, file, fileKey);
    }
public static void postAsyn(String url, ResultCallback callback, File file, String fileKey, Param... params) throws IOException
    {
        getInstance()._postAsyn(url, callback, file, fileKey, params);
    }
public static void displayImage(final ImageView view, String url, int errorResId) throws IOException
    {
        getInstance()._displayImage(view, url, errorResId);
    }
public static void displayImage(final ImageView view, String url)
    {
        getInstance()._displayImage(view, url, -1);
    }
public static void downloadAsyn(String url, String destDir, ResultCallback callback)
    {
        getInstance()._downloadAsyn(url, destDir, callback);
    }
//****************************
private Request buildMultipartFormRequest(String url, File[] files,
                                              String[] fileKeys, Param[] params)
    {
        params = validateParam(params);
MultipartBuilder builder = new MultipartBuilder()
                .type(MultipartBuilder.FORM);
for (Param param : params)
        {
            builder.addPart(Headers.of(&quot;Content-Disposition&quot;, &quot;form-data; name=\&quot;&quot; + param.key + &quot;\&quot;&quot;),
                    RequestBody.create(null, param.value));
        }
        if (files != null)
        {
            RequestBody fileBody = null;
            for (int i = 0; i &lt; files.length; i++)
            {
                File file = files[i];
                String fileName = file.getName();
                fileBody = RequestBody.create(MediaType.parse(guessMimeType(fileName)), file);
                //TODO 根据文件名设置contentType
                builder.addPart(Headers.of(&quot;Content-Disposition&quot;,
                                &quot;form-data; name=\&quot;&quot; + fileKeys[i] + &quot;\&quot;; filename=\&quot;&quot; + fileName + &quot;\&quot;&quot;),
                        fileBody);
            }
        }
RequestBody requestBody = builder.build();
        return new Request.Builder()
                .url(url)
                .post(requestBody)
                .build();
    }
private String guessMimeType(String path)
    {
        FileNameMap fileNameMap = URLConnection.getFileNameMap();
        String contentTypeFor = fileNameMap.getContentTypeFor(path);
        if (contentTypeFor == null)
        {
            contentTypeFor = &quot;application/octet-stream&quot;;
        }
        return contentTypeFor;
    }
private Param[] validateParam(Param[] params)
    {
        if (params == null)
            return new Param[0];
        else return params;
    }
private Param[] map2Params(Map&lt;String, String&gt; params)
    {
        if (params == null) return new Param[0];
        int size = params.size();
        Param[] res = new Param[size];
        Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = params.entrySet();
        int i = 0;
        for (Map.Entry&lt;String, String&gt; entry : entries)
        {
            res[i++] = new Param(entry.getKey(), entry.getValue());
        }
        return res;
    }
private static final String SESSION_KEY = &quot;Set-Cookie&quot;;
    private static final String mSessionKey = &quot;JSESSIONID&quot;;
private Map&lt;String, String&gt; mSessions = new HashMap&lt;String, String&gt;();
private void deliveryResult(final ResultCallback callback, Request request)
    {
        mOkHttpClient.newCall(request).enqueue(new Callback()
        {
            @Override
            public void onFailure(final Request request, final IOException e)
            {
                sendFailedStringCallback(request, e, callback);
            }
@Override
            public void onResponse(final Response response)
            {
                try
                {
                    final String string = response.body().string();
                    if (callback.mType == String.class)
                    {
                        sendSuccessResultCallback(string, callback);
                    } else
                    {
                        Object o = mGson.fromJson(string, callback.mType);
                        sendSuccessResultCallback(o, callback);
                    }
} catch (IOException e)
                {
                    sendFailedStringCallback(response.request(), e, callback);
                } catch (com.google.gson.JsonParseException e)//Json解析的错误
                {
                    sendFailedStringCallback(response.request(), e, callback);
                }
}
        });
    }
private void sendFailedStringCallback(final Request request, final Exception e, final ResultCallback callback)
    {
        mDelivery.post(new Runnable()
        {
            @Override
            public void run()
            {
                if (callback != null)
                    callback.onError(request, e);
            }
        });
    }
private void sendSuccessResultCallback(final Object object, final ResultCallback callback)
    {
        mDelivery.post(new Runnable()
        {
            @Override
            public void run()
            {
                if (callback != null)
                {
                    callback.onResponse(object);
                }
            }
        });
    }
private Request buildPostRequest(String url, Param[] params)
    {
        if (params == null)
        {
            params = new Param[0];
        }
        FormEncodingBuilder builder = new FormEncodingBuilder();
        for (Param param : params)
        {
            builder.add(param.key, param.value);
        }
        RequestBody requestBody = builder.build();
        return new Request.Builder()
                .url(url)
                .post(requestBody)
                .build();
    }
public static abstract class ResultCallback&lt;T&gt;
    {
        Type mType;
public ResultCallback()
        {
            mType = getSuperclassTypeParameter(getClass());
        }
static Type getSuperclassTypeParameter(Class&lt;?&gt; subclass)
        {
            Type superclass = subclass.getGenericSuperclass();
            if (superclass instanceof Class)
            {
                throw new RuntimeException(&quot;Missing type parameter.&quot;);
            }
            ParameterizedType parameterized = (ParameterizedType) superclass;
            return $Gson$Types.canonicalize(parameterized.getActualTypeArguments()[0]);
        }
public abstract void onError(Request request, Exception e);
public abstract void onResponse(T response);
    }
public static class Param
    {
        public Param()
        {
        }
public Param(String key, String value)
        {
            this.key = key;
            this.value = value;
        }
String key;
        String value;
    }
}
</code></pre><p>源码地址okhttp-utils，大家可以自己下载查看。</p>
<p>来自 <a href="http://blog.csdn.net/lmj623565791/article/details/47911083" target="_blank" rel="external">http://blog.csdn.net/lmj623565791/article/details/47911083</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u4E00_u3001_u6982_u8FF0"><a href="#u4E00_u3001_u6982_u8FF0" class="headerlink" title="一、概述"></a>一、概述</h2><blockquote>
<p>最近在群里听到各种讨论okhttp的话题，可见okhttp的口碑相当好了。再加上Google貌似在6.0版本里面删除了HttpClient相关API，对于这个行为不做评价。为了更好的在应对网络访问，学习下okhttp还是蛮必要的，本篇博客首先介绍okhttp的简单使用，主要包含：</p>
</blockquote>]]>
    
    </summary>
    
      <category term="OkHttp" scheme="http://yoursite.com/tags/OkHttp/"/>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android OkHttp使用教程]]></title>
    <link href="http://yoursite.com/2015/07/19/Android%20OkHttp%E5%88%9D%E7%BA%A7%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2015/07/19/Android OkHttp初级入门/</id>
    <published>2015-07-19T05:33:17.000Z</published>
    <updated>2016-02-19T09:07:45.648Z</updated>
    <content type="html"><![CDATA[<p>Android系统提供了两种HTTP通信类，HttpURLConnection和HttpClient。</p>
<p>尽管Google在大部分安卓版本中推荐使用HttpURLConnection，但是这个类相比HttpClient实在是太难用，太弱爆了。</p>
<p>OkHttp是一个相对成熟的解决方案，据说Android4.4的源码中可以看到HttpURLConnection已经替换成OkHttp实现了。所以我们更有理由相信OkHttp的强大。<br><a id="more"></a><br>OkHttp 处理了很多网络疑难杂症：会从很多常用的连接问题中自动恢复。如果您的服务器配置了多个IP地址，当第一个IP连接失败的时候，OkHttp会自动尝试下一个IP。OkHttp还处理了代理服务器问题和SSL握手失败问题。</p>
<p>使用 OkHttp 无需重写您程序中的网络代码。OkHttp实现了几乎和java.net.HttpURLConnection一样的API。如果你用了 Apache HttpClient，则OkHttp也提供了一个对应的okhttp-apache 模块。</p>
<pre><code>注：在国内使用OkHttp会因为这个问题导致部分酷派手机用户无法联网，所以对于大众app来说，需要等待这个bug修复后再使用。或者尝试使用OkHttp的老版本。
截止到目前，OkHttp一直没有修复，并把修复计划延迟到了OkHttp2.3中。不是所有设备都能重现，仅少量设备会出现这个问题。（如果问题这么明显，OkHttp早就修复了）
</code></pre><h3 id="u5165_u95E8"><a href="#u5165_u95E8" class="headerlink" title="入门"></a>入门</h3><pre><code>官方资料
官方介绍
github源码
使用范围
OkHttp支持Android 2.3及其以上版本。
对于Java, JDK1.7以上。
jar包准备
官方介绍页面有链接位置。这里把下载链接也写在下面。
OkHttp
Okio
</code></pre><h3 id="u57FA_u672C_u4F7F_u7528"><a href="#u57FA_u672C_u4F7F_u7528" class="headerlink" title="基本使用"></a>基本使用</h3><h4 id="HTTP_GET"><a href="#HTTP_GET" class="headerlink" title="HTTP GET"></a>HTTP GET</h4><pre><code>1    OkHttpClient client = new OkHttpClient();
2     
3    String run(String url) throws IOException {
4        Request request = new Request.Builder().url(url).build();
5        Response response = client.newCall(request).execute();    if (response.isSuccessful()) {        return response.body().string();
6        } else {        throw new IOException(&quot;Unexpected code &quot; + response);
7        }
8    }
Request是OkHttp中访问的请求，Builder是辅助类。Response即OkHttp中的响应。
Response类：
1    public boolean isSuccessful()
2    Returns true if the code is in [200..300),
3     which means the request was successfully received, understood, and accepted.
response.body()返回ResponseBody类
</code></pre><p>可以方便的获取string</p>
<pre><code>1    public final String string() throws IOException
2    Returns the response as a string decoded with the charset of the Content-Type header. If that header is either absent or lacks a charset,
3     this will attempt to decode the response body as UTF-8.Throws:
4    IOException
</code></pre><p>当然也能获取到流的形式：</p>
<pre><code>1    public final InputStream byteStream()
</code></pre><h4 id="HTTP_POST"><a href="#HTTP_POST" class="headerlink" title="HTTP POST"></a>HTTP POST</h4><p>POST提交Json数据</p>
<pre><code>1    public static final MediaType JSON = MediaType.parse(&quot;application/json; charset=utf-8&quot;);
2    OkHttpClient client = new OkHttpClient();
3    String post(String url, String json) throws IOException {
4         RequestBody body = RequestBody.create(JSON, json);
5          Request request = new Request.Builder()
6          .url(url)
7          .post(body)
8          .build();
9          Response response = client.newCall(request).execute();
10        f (response.isSuccessful()) {
11            return response.body().string();
12        } else {
13            throw new IOException(&quot;Unexpected code &quot; + response);
14        }
15    }
</code></pre><p>使用Request的post方法来提交请求体RequestBody<br>POST提交键值对<br>很多时候我们会需要通过POST方式把键值对数据传送到服务器。 OkHttp提供了很方便的方式来做这件事情。</p>
<pre><code>1    OkHttpClient client = new OkHttpClient();
2    String post(String url, String json) throws IOException {
3     
4         RequestBody formBody = new FormEncodingBuilder()
5        .add(&quot;platform&quot;, &quot;android&quot;)
6        .add(&quot;name&quot;, &quot;bug&quot;)
7        .add(&quot;subject&quot;, &quot;XXXXXXXXXXXXXXX&quot;)
8        .build();
9     
10          Request request = new Request.Builder()
11          .url(url)
12          .post(body)
13          .build();
14     
15          Response response = client.newCall(request).execute();
16        if (response.isSuccessful()) {
17            return response.body().string();
18        } else {
19            throw new IOException(&quot;Unexpected code &quot; + response);
20        }
21    }
</code></pre><h4 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h4><p>通过上面的例子我们可以发现，OkHttp在很多时候使用都是很方便的，而且很多代码也有重复，因此特地整理了下面的工具类。<br>注意：</p>
<pre><code>• OkHttp官方文档并不建议我们创建多个OkHttpClient，因此全局使用一个。 如果有需要，可以使用clone方法，再进行自定义。这点在后面的高级教程里会提到。
• enqueue为OkHttp提供的异步方法，入门教程中并没有提到，后面的高级教程里会有解释。
1    import java.io.IOException;
2    import java.util.List;
3    import java.util.concurrent.TimeUnit;
4    import org.apache.http.client.utils.URLEncodedUtils;
5    import org.apache.http.message.BasicNameValuePair;
6    import cn.wiz.sdk.constant.WizConstant;
7    import com.squareup.okhttp.Callback;
8    import com.squareup.okhttp.OkHttpClient;
9    import com.squareup.okhttp.Request;
10    import com.squareup.okhttp.Response; 
11      
12    public class OkHttpUtil {
13        private static final OkHttpClient mOkHttpClient = new OkHttpClient();
14        static{
15            mOkHttpClient.setConnectTimeout(30, TimeUnit.SECONDS);
16        }
17        /**
18         * 该不会开启异步线程。
19         * @param request
20         * @return
21         * @throws IOException
22         */
23        public static Response execute(Request request) throws IOException{
24            return mOkHttpClient.newCall(request).execute();
25        }
26        /**
27         * 开启异步线程访问网络
28         * @param request
29         * @param responseCallback
30         */
31        public static void enqueue(Request request, Callback responseCallback){
32            mOkHttpClient.newCall(request).enqueue(responseCallback);
33        }
34        /**
35         * 开启异步线程访问网络, 且不在意返回结果（实现空callback）
36         * @param request
37         */
38        public static void enqueue(Request request){
39            mOkHttpClient.newCall(request).enqueue(new Callback() {
40                 
41                @Override
42                public void onResponse(Response arg0) throws IOException {
43                     
44                }
45                 
46                @Override
47                public void onFailure(Request arg0, IOException arg1) {
48                     
49                }
50            });
51        }
52        public static String getStringFromServer(String url) throws IOException{
53            Request request = new Request.Builder().url(url).build();
54            Response response = execute(request);
55            if (response.isSuccessful()) {
56                String responseUrl = response.body().string();
57                return responseUrl;
58            } else {
59                throw new IOException(&quot;Unexpected code &quot; + response);
60            }
61        }
62        private static final String CHARSET_NAME = &quot;UTF-8&quot;;
63        /**
64         * 这里使用了HttpClinet的API。只是为了方便
65         * @param params
66         * @return
67         */
68        public static String formatParams(List&lt;BasicNameValuePair&gt; params){
69            return URLEncodedUtils.format(params, CHARSET_NAME);
70        }
71        /**
72         * 为HttpGet 的 url 方便的添加多个name value 参数。
73         * @param url
74         * @param params
75         * @return
76         */
77        public static String attachHttpGetParams(String url, List&lt;BasicNameValuePair&gt; params){
78            return url + &quot;?&quot; + formatParams(params);
79        }
80        /**
81         * 为HttpGet 的 url 方便的添加1个name value 参数。
82         * @param url
83         * @param name
84         * @param value
85         * @return
86         */
87        public static String attachHttpGetParam(String url, String name, String value){
88            return url + &quot;?&quot; + name + &quot;=&quot; + value;
89        }
90    }
</code></pre><h3 id="u9AD8_u7EA7"><a href="#u9AD8_u7EA7" class="headerlink" title="高级"></a>高级</h3><p>高级属性其实用的不多，这里主要是对OkHttp github官方教程进行了翻译。</p>
<h4 id="u540C_u6B65get"><a href="#u540C_u6B65get" class="headerlink" title="同步get"></a>同步get</h4><p>下载一个文件，打印他的响应头，以string形式打印响应体。<br>响应体的 string() 方法对于小文档来说十分方便、高效。但是如果响应体太大（超过1MB），应避免适应 string()方法 ，因为他会将把整个文档加载到内存中。<br>对于超过1MB的响应body，应使用流的方式来处理body。</p>
<pre><code>1    private final OkHttpClient client = new OkHttpClient();
2     
3    public void run() throws Exception {
4        Request request = new Request.Builder()
5            .url(&quot;http://publicobject.com/helloworld.txt&quot;)
6            .build();
7     
8        Response response = client.newCall(request).execute();
9        if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);
10     
11        Headers responseHeaders = response.headers();
12        for (int i = 0; i &lt; responseHeaders.size(); i++) {
13          System.out.println(responseHeaders.name(i) + &quot;: &quot; + responseHeaders.value(i));
14        }
15     
16        System.out.println(response.body().string());
17    }
</code></pre><h4 id="u5F02_u6B65get"><a href="#u5F02_u6B65get" class="headerlink" title="异步get"></a>异步get</h4><p>在一个工作线程中下载文件，当响应可读时回调Callback接口。读取响应时会阻塞当前线程。OkHttp现阶段不提供异步api来接收响应体。</p>
<pre><code>1    private final OkHttpClient client = new OkHttpClient();
2     
3    public void run() throws Exception {
4        Request request = new Request.Builder()
5            .url(&quot;http://publicobject.com/helloworld.txt&quot;)
6            .build();
7     
8        client.newCall(request).enqueue(new Callback() {
9          @Override public void onFailure(Request request, Throwable throwable) {
10            throwable.printStackTrace();
11          }
12     
13          @Override public void onResponse(Response response) throws IOException {
14            if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);
15     
16            Headers responseHeaders = response.headers();
17            for (int i = 0; i &lt; responseHeaders.size(); i++) {
18              System.out.println(responseHeaders.name(i) + &quot;: &quot; + responseHeaders.value(i));
19            }
20     
21            System.out.println(response.body().string());
22          }
23        });
24    }
</code></pre><h4 id="u63D0_u53D6_u54CD_u5E94_u5934"><a href="#u63D0_u53D6_u54CD_u5E94_u5934" class="headerlink" title="提取响应头"></a>提取响应头</h4><p>典型的HTTP头 像是一个 Map<string, string=""> :每个字段都有一个或没有值。但是一些头允许多个值，像Guava的Multimap。例如：HTTP响应里面提供的Vary响应头，就是多值的。OkHttp的api试图让这些情况都适用。<br>当写请求头的时候，使用header(name, value)可以设置唯一的name、value。如果已经有值，旧的将被移除，然后添加新的。使用addHeader(name, value)可以添加多值（添加，不移除已有的）。<br>当读取响应头时，使用header(name)返回最后出现的name、value。通常情况这也是唯一的name、value。如果没有值，那么header(name)将返回null。如果想读取字段对应的所有值，使用headers(name)会返回一个list。<br>为了获取所有的Header，Headers类支持按index访问。</string,></p>
<pre><code>1    private final OkHttpClient client = new OkHttpClient();
2     
3    public void run() throws Exception {
4        Request request = new Request.Builder()
5            .url(&quot;https://api.github.com/repos/square/okhttp/issues&quot;)
6            .header(&quot;User-Agent&quot;, &quot;OkHttp Headers.java&quot;)
7            .addHeader(&quot;Accept&quot;, &quot;application/json; q=0.5&quot;)
8            .addHeader(&quot;Accept&quot;, &quot;application/vnd.github.v3+json&quot;)
9            .build();
10     
11        Response response = client.newCall(request).execute();
12        if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);
13     
14        System.out.println(&quot;Server: &quot; + response.header(&quot;Server&quot;));
15        System.out.println(&quot;Date: &quot; + response.header(&quot;Date&quot;));
16        System.out.println(&quot;Vary: &quot; + response.headers(&quot;Vary&quot;));
17    }
</code></pre><h4 id="Post_u65B9_u5F0F_u63D0_u4EA4String"><a href="#Post_u65B9_u5F0F_u63D0_u4EA4String" class="headerlink" title="Post方式提交String"></a>Post方式提交String</h4><p>使用HTTP POST提交请求到服务。这个例子提交了一个markdown文档到web服务，以HTML方式渲染markdown。因为整个请求体都在内存中，因此避免使用此api提交大文档（大于1MB）。</p>
<pre><code>1    public static final MediaType MEDIA_TYPE_MARKDOWN
2      = MediaType.parse(&quot;text/x-markdown; charset=utf-8&quot;);
3     
4    private final OkHttpClient client = new OkHttpClient();
5     
6    public void run() throws Exception {
7        String postBody = &quot;&quot;
8            + &quot;Releases\n&quot;
9            + &quot;--------\n&quot;
10            + &quot;\n&quot;
11            + &quot; * _1.0_ May 6, 2013\n&quot;
12            + &quot; * _1.1_ June 15, 2013\n&quot;
13            + &quot; * _1.2_ August 11, 2013\n&quot;;
14     
15        Request request = new Request.Builder()
16            .url(&quot;https://api.github.com/markdown/raw&quot;)
17            .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, postBody))
18            .build();
19     
20        Response response = client.newCall(request).execute();
21        if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);
22     
23        System.out.println(response.body().string());
24    }
</code></pre><h4 id="Post_u65B9_u5F0F_u63D0_u4EA4_u6D41"><a href="#Post_u65B9_u5F0F_u63D0_u4EA4_u6D41" class="headerlink" title="Post方式提交流"></a>Post方式提交流</h4><p>以流的方式POST提交请求体。请求体的内容由流写入产生。这个例子是流直接写入Okio的BufferedSink。你的程序可能会使用OutputStream，你可以使用BufferedSink.outputStream()来获取。</p>
<pre><code>1    public static final MediaType MEDIA_TYPE_MARKDOWN
2          = MediaType.parse(&quot;text/x-markdown; charset=utf-8&quot;);
3     
4    private final OkHttpClient client = new OkHttpClient();
5     
6    public void run() throws Exception {
7        RequestBody requestBody = new RequestBody() {
8          @Override public MediaType contentType() {
9            return MEDIA_TYPE_MARKDOWN;
10          }
11     
12          @Override public void writeTo(BufferedSink sink) throws IOException {
13            sink.writeUtf8(&quot;Numbers\n&quot;);
14            sink.writeUtf8(&quot;-------\n&quot;);
15            for (int i = 2; i &lt;= 997; i++) {
16              sink.writeUtf8(String.format(&quot; * %s = %s\n&quot;, i, factor(i)));
17            }
18          }
19     
20          private String factor(int n) {
21            for (int i = 2; i &lt; n; i++) {
22              int x = n / i;
23              if (x * i == n) return factor(x) + &quot; × &quot; + i;
24            }
25            return Integer.toString(n);
26          }
27        };
28     
29        Request request = new Request.Builder()
30            .url(&quot;https://api.github.com/markdown/raw&quot;)
31            .post(requestBody)
32            .build();
33     
34        Response response = client.newCall(request).execute();
35        if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);
36     
37        System.out.println(response.body().string());
38    }
</code></pre><h4 id="Post_u65B9_u5F0F_u63D0_u4EA4_u6587_u4EF6"><a href="#Post_u65B9_u5F0F_u63D0_u4EA4_u6587_u4EF6" class="headerlink" title="Post方式提交文件"></a>Post方式提交文件</h4><p>以文件作为请求体是十分简单的。</p>
<pre><code>1    public static final MediaType MEDIA_TYPE_MARKDOWN
2      = MediaType.parse(&quot;text/x-markdown; charset=utf-8&quot;);
3     
4    private final OkHttpClient client = new OkHttpClient();
5     
6    public void run() throws Exception {
7        File file = new File(&quot;README.md&quot;);
8     
9        Request request = new Request.Builder()
10            .url(&quot;https://api.github.com/markdown/raw&quot;)
11            .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, file))
12            .build();
13     
14        Response response = client.newCall(request).execute();
15        if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);
16     
17        System.out.println(response.body().string());
18    }
</code></pre><h4 id="Post_u65B9_u5F0F_u63D0_u4EA4_u8868_u5355"><a href="#Post_u65B9_u5F0F_u63D0_u4EA4_u8868_u5355" class="headerlink" title="Post方式提交表单"></a>Post方式提交表单</h4><p>使用FormEncodingBuilder来构建和HTML<form>标签相同效果的请求体。键值对将使用一种HTML兼容形式的URL编码来进行编码。</form></p>
<pre><code>1    private final OkHttpClient client = new OkHttpClient();
2     
3    public void run() throws Exception {
4        RequestBody formBody = new FormEncodingBuilder()
5            .add(&quot;search&quot;, &quot;Jurassic Park&quot;)
6            .build();
7        Request request = new Request.Builder()
8            .url(&quot;https://en.wikipedia.org/w/index.php&quot;)
9            .post(formBody)
10            .build();
11     
12        Response response = client.newCall(request).execute();
13        if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);
14     
15        System.out.println(response.body().string());
16    }
</code></pre><h4 id="Post_u65B9_u5F0F_u63D0_u4EA4_u5206_u5757_u8BF7_u6C42"><a href="#Post_u65B9_u5F0F_u63D0_u4EA4_u5206_u5757_u8BF7_u6C42" class="headerlink" title="Post方式提交分块请求"></a>Post方式提交分块请求</h4><p>MultipartBuilder可以构建复杂的请求体，与HTML文件上传形式兼容。多块请求体中每块请求都是一个请求体，可以定义自己的请求头。这些请求头可以用来描述这块请求，例如他的Content-Disposition。如果Content-Length和Content-Type可用的话，他们会被自动添加到请求头中。</p>
<pre><code>1    private static final String IMGUR_CLIENT_ID = &quot;...&quot;;
2    private static final MediaType MEDIA_TYPE_PNG = MediaType.parse(&quot;image/png&quot;);
3     
4    private final OkHttpClient client = new OkHttpClient();
5     
6    public void run() throws Exception {
7        // Use the imgur image upload API as documented at https://api.imgur.com/endpoints/image
8        RequestBody requestBody = new MultipartBuilder()
9            .type(MultipartBuilder.FORM)
10            .addPart(
11                Headers.of(&quot;Content-Disposition&quot;, &quot;form-data; name=\&quot;title\&quot;&quot;),
12                RequestBody.create(null, &quot;Square Logo&quot;))
13            .addPart(
14                Headers.of(&quot;Content-Disposition&quot;, &quot;form-data; name=\&quot;image\&quot;&quot;),
15                RequestBody.create(MEDIA_TYPE_PNG, new File(&quot;website/static/logo-square.png&quot;)))
16            .build();
17     
18        Request request = new Request.Builder()
19            .header(&quot;Authorization&quot;, &quot;Client-ID &quot; + IMGUR_CLIENT_ID)
20            .url(&quot;https://api.imgur.com/3/image&quot;)
21            .post(requestBody)
22            .build();
23     
24        Response response = client.newCall(request).execute();
25        if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);
26     
27        System.out.println(response.body().string());
28    }
</code></pre><h4 id="u4F7F_u7528Gson_u6765_u89E3_u6790JSON_u54CD_u5E94"><a href="#u4F7F_u7528Gson_u6765_u89E3_u6790JSON_u54CD_u5E94" class="headerlink" title="使用Gson来解析JSON响应"></a>使用Gson来解析JSON响应</h4><p>Gson是一个在JSON和Java对象之间转换非常方便的api。这里我们用Gson来解析Github API的JSON响应。<br>注意：ResponseBody.charStream()使用响应头Content-Type指定的字符集来解析响应体。默认是UTF-8。</p>
<pre><code>1    private final OkHttpClient client = new OkHttpClient();
2    private final Gson gson = new Gson();
3     
4    public void run() throws Exception {
5        Request request = new Request.Builder()
6            .url(&quot;https://api.github.com/gists/c2a7c39532239ff261be&quot;)
7            .build();
8        Response response = client.newCall(request).execute();
9        if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);
10     
11        Gist gist = gson.fromJson(response.body().charStream(), Gist.class);
12        for (Map.Entry&lt;String, GistFile&gt; entry : gist.files.entrySet()) {
13          System.out.println(entry.getKey());
14          System.out.println(entry.getValue().content);
15        }
16    }
17     
18    static class Gist {
19        Map&lt;String, GistFile&gt; files;
20    }
21     
22    static class GistFile {
23        String content;
24    }
</code></pre><h4 id="u54CD_u5E94_u7F13_u5B58"><a href="#u54CD_u5E94_u7F13_u5B58" class="headerlink" title="响应缓存"></a>响应缓存</h4><p>为了缓存响应，你需要一个你可以读写的缓存目录，和缓存大小的限制。这个缓存目录应该是私有的，不信任的程序应不能读取缓存内容。<br>一个缓存目录同时拥有多个缓存访问是错误的。大多数程序只需要调用一次new OkHttp()，在第一次调用时配置好缓存，然后其他地方只需要调用这个实例就可以了。否则两个缓存示例互相干扰，破坏响应缓存，而且有可能会导致程序崩溃。<br>响应缓存使用HTTP头作为配置。你可以在请求头中添加Cache-Control: max-stale=3600 ,OkHttp缓存会支持。你的服务通过响应头确定响应缓存多长时间，例如使用Cache-Control: max-age=9600。</p>
<pre><code>1    private final OkHttpClient client;
2     
3    public CacheResponse(File cacheDirectory) throws Exception {
4        int cacheSize = 10 * 1024 * 1024; // 10 MiB
5        Cache cache = new Cache(cacheDirectory, cacheSize);
6     
7        client = new OkHttpClient();
8        client.setCache(cache);
9    }
10     
11    public void run() throws Exception {
12        Request request = new Request.Builder()
13            .url(&quot;http://publicobject.com/helloworld.txt&quot;)
14            .build();
15     
16        Response response1 = client.newCall(request).execute();
17        if (!response1.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response1);
18     
19        String response1Body = response1.body().string();
20        System.out.println(&quot;Response 1 response:          &quot; + response1);
21        System.out.println(&quot;Response 1 cache response:    &quot; + response1.cacheResponse());
22        System.out.println(&quot;Response 1 network response:  &quot; + response1.networkResponse());
23     
24        Response response2 = client.newCall(request).execute();
25        if (!response2.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response2);
26     
27        String response2Body = response2.body().string();
28        System.out.println(&quot;Response 2 response:          &quot; + response2);
29        System.out.println(&quot;Response 2 cache response:    &quot; + response2.cacheResponse());
30        System.out.println(&quot;Response 2 network response:  &quot; + response2.networkResponse());
31     
32        System.out.println(&quot;Response 2 equals Response 1? &quot; + response1Body.equals(response2Body));
33    }
</code></pre><h3 id="u6269_u5C55"><a href="#u6269_u5C55" class="headerlink" title="扩展"></a>扩展</h3><p>在这一节还提到了下面一句：<br>There are cache headers to force a cached response, force a network response, or force the network response to be validated with a conditional GET.<br>我不是很懂cache，平时用到的也不多，所以把Google在Android Developers一段相关的解析放到这里吧。<br>Force a Network Response<br>In some situations, such as after a user clicks a ‘refresh’ button, it may be necessary to skip the cache, and fetch data directly from the server. To force a full refresh, add the no-cache directive:<br>connection.addRequestProperty(“Cache-Control”, “no-cache”);<br>If it is only necessary to force a cached response to be validated by the server, use the more efficient max-age=0 instead:<br>connection.addRequestProperty(“Cache-Control”, “max-age=0”);<br>Force a Cache Response<br>Sometimes you’ll want to show resources if they are available immediately, but not otherwise. This can be used so your application can show something while waiting for the latest data to be downloaded. To restrict a request to locally-cached resources, add the only-if-cached directive:</p>
<pre><code>1    try {
2         connection.addRequestProperty(&quot;Cache-Control&quot;, &quot;only-if-cached&quot;);
3         InputStream cached = connection.getInputStream();
4         // the resource was cached! show it
5      catch (FileNotFoundException e) {
6         // the resource was not cached
7     }
8    }
</code></pre><p>This technique works even better in situations where a stale response is better than no response. To permit stale cached responses, use the max-stale directive with the maximum staleness in seconds:</p>
<pre><code>1    int maxStale = 60 * 60 * 24 * 28; // tolerate 4-weeks staleconnection.addRequestProperty(&quot;Cache-Control&quot;, &quot;max-stale=&quot; + maxStale);
</code></pre><p>以上信息来自：<code>HttpResponseCache - Android SDK | Android Developers</code><br>取消一个Call<br>使用Call.cancel()可以立即停止掉一个正在执行的call。如果一个线程正在写请求或者读响应，将会引发IOException。当call没有必要的时候，使用这个api可以节约网络资源。例如当用户离开一个应用时。不管同步还是异步的call都可以取消。<br>你可以通过tags来同时取消多个请求。当你构建一请求时，使用RequestBuilder.tag(tag)来分配一个标签。之后你就可以用OkHttpClient.cancel(tag)来取消所有带有这个tag的call。</p>
<pre><code>1    private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);
2    private final OkHttpClient client = new OkHttpClient();
3     
4    public void run() throws Exception {
5        Request request = new Request.Builder()
6            .url(&quot;http://httpbin.org/delay/2&quot;) // This URL is served with a 2 second delay.
7            .build();
8     
9        final long startNanos = System.nanoTime();
10        final Call call = client.newCall(request);
11     
12        // Schedule a job to cancel the call in 1 second.
13        executor.schedule(new Runnable() {
14          @Override public void run() {
15            System.out.printf(&quot;%.2f Canceling call.%n&quot;, (System.nanoTime() - startNanos) / 1e9f);
16            call.cancel();
17            System.out.printf(&quot;%.2f Canceled call.%n&quot;, (System.nanoTime() - startNanos) / 1e9f);
18          }
19        }, 1, TimeUnit.SECONDS);
20     
21        try {
22          System.out.printf(&quot;%.2f Executing call.%n&quot;, (System.nanoTime() - startNanos) / 1e9f);
23          Response response = call.execute();
24          System.out.printf(&quot;%.2f Call was expected to fail, but completed: %s%n&quot;,
25              (System.nanoTime() - startNanos) / 1e9f, response);
26        } catch (IOException e) {
27          System.out.printf(&quot;%.2f Call failed as expected: %s%n&quot;,
28              (System.nanoTime() - startNanos) / 1e9f, e);
29        }
30    }
</code></pre><h4 id="u8D85_u65F6"><a href="#u8D85_u65F6" class="headerlink" title="超时"></a>超时</h4><p>没有响应时使用超时结束call。没有响应的原因可能是客户点链接问题、服务器可用性问题或者这之间的其他东西。OkHttp支持连接，读取和写入超时。</p>
<pre><code>1    private final OkHttpClient client;
2     
3    public ConfigureTimeouts() throws Exception {
4        client = new OkHttpClient();
5        client.setConnectTimeout(10, TimeUnit.SECONDS);
6        client.setWriteTimeout(10, TimeUnit.SECONDS);
7        client.setReadTimeout(30, TimeUnit.SECONDS);
8    }
9     
10    public void run() throws Exception {
11        Request request = new Request.Builder()
12            .url(&quot;http://httpbin.org/delay/2&quot;) // This URL is served with a 2 second delay.
13            .build();
14     
15        Response response = client.newCall(request).execute();
16        System.out.println(&quot;Response completed: &quot; + response);
17    }
</code></pre><h4 id="u6BCF_u4E2Acall_u7684_u914D_u7F6E"><a href="#u6BCF_u4E2Acall_u7684_u914D_u7F6E" class="headerlink" title="每个call的配置"></a>每个call的配置</h4><p>使用OkHttpClient，所有的HTTP Client配置包括代理设置、超时设置、缓存设置。当你需要为单个call改变配置的时候，clone 一个 OkHttpClient。这个api将会返回一个浅拷贝（shallow copy），你可以用来单独自定义。下面的例子中，我们让一个请求是500ms的超时、另一个是3000ms的超时。</p>
<pre><code>1    private final OkHttpClient client = new OkHttpClient();
2     
3    public void run() throws Exception {
4        Request request = new Request.Builder()
5            .url(&quot;http://httpbin.org/delay/1&quot;) // This URL is served with a 1 second delay.
6            .build();
7     
8        try {
9          Response response = client.clone() // Clone to make a customized OkHttp for this request.
10              .setReadTimeout(500, TimeUnit.MILLISECONDS)
11              .newCall(request)
12              .execute();
13          System.out.println(&quot;Response 1 succeeded: &quot; + response);
14        } catch (IOException e) {
15          System.out.println(&quot;Response 1 failed: &quot; + e);
16        }
17     
18        try {
19          Response response = client.clone() // Clone to make a customized OkHttp for this request.
20              .setReadTimeout(3000, TimeUnit.MILLISECONDS)
21              .newCall(request)
22              .execute();
23          System.out.println(&quot;Response 2 succeeded: &quot; + response);
24        } catch (IOException e) {
25          System.out.println(&quot;Response 2 failed: &quot; + e);
26        }
27    }
</code></pre><h4 id="u5904_u7406_u9A8C_u8BC1"><a href="#u5904_u7406_u9A8C_u8BC1" class="headerlink" title="处理验证"></a>处理验证</h4><p>这部分和HTTP AUTH有关。<br>相关资料：HTTP AUTH 那些事 - 王绍全的博客 - 博客频道 - CSDN.NET<br>OkHttp会自动重试未验证的请求。当响应是401 Not Authorized时，Authenticator会被要求提供证书。Authenticator的实现中需要建立一个新的包含证书的请求。如果没有证书可用，返回null来跳过尝试。</p>
<pre><code>1    public List&lt;Challenge&gt; challenges()
2    Returns the authorization challenges appropriate for this response&apos;s code. 
3    If the response code is 401 unauthorized, 
4    this returns the &quot;WWW-Authenticate&quot; challenges.
5    If the response code is 407 proxy unauthorized, this returns the &quot;Proxy-Authenticate&quot; challenges.
6    Otherwise this returns an empty list of challenges.
</code></pre><p>当需要实现一个Basic challenge， 使用Credentials.basic(username, password)来编码请求头。</p>
<pre><code>1    private final OkHttpClient client = new OkHttpClient();
2     
3    public void run() throws Exception {
4        client.setAuthenticator(new Authenticator() {
5          @Override public Request authenticate(Proxy proxy, Response response) {
6            System.out.println(&quot;Authenticating for response: &quot; + response);
7            System.out.println(&quot;Challenges: &quot; + response.challenges());
8            String credential = Credentials.basic(&quot;jesse&quot;, &quot;password1&quot;);
9            return response.request().newBuilder()
10                .header(&quot;Authorization&quot;, credential)
11                .build();
12          }
13     
14          @Override public Request authenticateProxy(Proxy proxy, Response response) {
15            return null; // Null indicates no attempt to authenticate.
16          }
17        });
18     
19        Request request = new Request.Builder()
20            .url(&quot;http://publicobject.com/secrets/hellosecret.txt&quot;)
21            .build();
22     
23        Response response = client.newCall(request).execute();
24        if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);
25     
26        System.out.println(response.body().string());
27    }
</code></pre><p>转自  <a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0106/2275.html" target="_blank" rel="external">http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0106/2275.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Android系统提供了两种HTTP通信类，HttpURLConnection和HttpClient。</p>
<p>尽管Google在大部分安卓版本中推荐使用HttpURLConnection，但是这个类相比HttpClient实在是太难用，太弱爆了。</p>
<p>OkHttp是一个相对成熟的解决方案，据说Android4.4的源码中可以看到HttpURLConnection已经替换成OkHttp实现了。所以我们更有理由相信OkHttp的强大。<br>]]>
    
    </summary>
    
      <category term="OkHttp" scheme="http://yoursite.com/tags/OkHttp/"/>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[EventBus 3.0的用法详解（二）]]></title>
    <link href="http://yoursite.com/2015/06/27/EventBus%203.0%E7%9A%84%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3(%E4%BA%8C)/"/>
    <id>http://yoursite.com/2015/06/27/EventBus 3.0的用法详解(二)/</id>
    <published>2015-06-27T15:59:14.000Z</published>
    <updated>2016-02-19T09:11:37.585Z</updated>
    <content type="html"><![CDATA[<p>前一篇文章简单介绍了<code>EventBus 3.0</code>的用法，现在是时候详解其用法了。首先声明，<code>EventBus 3.0</code>的改动针对2.4的改动并不是特别大，但是对于其性能的提升是另外一个说法了，所以建议学习EventBus 3.0。<a id="more"></a></p>
<h4 id="u6CE8_u89E3"><a href="#u6CE8_u89E3" class="headerlink" title="注解"></a>注解</h4><h5 id="u65B0_u589E_u7684_60@Subscribe"><a href="#u65B0_u589E_u7684_60@Subscribe" class="headerlink" title="新增的`@Subscribe"></a>新增的<code>`@Subscribe</code></h5><pre><code>threadMode = ThreadMode.MainThread
</code></pre><p>用注解的方式代替约定的方法名规范，是其最大的改变。在2.4中，你可能需要这么定义：</p>
<pre><code>public void onEventMainThread(MessageEvent event) {
        log(event.message);
    }
</code></pre><p>该方法为接收消息后在主线程中处理事件，而在3.0中：</p>
<pre><code>@Subscribe(threadMode = ThreadMode.MainThread) //在ui线程执行
public void onUserEvent(UserEvent event) {
        log(event.message);
    }
</code></pre><p>其中ThreadMode提供了四个常量：</p>
<ul>
<li>MainThread 主线程</li>
<li>BackgroundThread 后台线程</li>
<li>Async 后台线程</li>
<li>PostThread 发送线程（默认）</li>
</ul>
<p><code>BackgroundThread</code>:当事件是在UI线程发出，那么事件处理实际上是需要新建单独线程，如果是在后台线程发出，那么事件处理就在该线程。该事件处理方法应该是快速的，避免阻塞后台线程。</p>
<p>Async：发送事件方不需要等待事件处理完毕。这种方式适用于该事件处理方法需要较长时间，例如网络请求。</p>
<pre><code>sticky = true
</code></pre><h5 id="u9ED8_u8BA4_u60C5_u51B5_u4E0B_uFF0C_u5176_u4E3Afalse_u3002_u4EC0_u4E48_u60C5_u51B5_u4E0B_u4F7F_u7528sticky_u5462_uFF1F"><a href="#u9ED8_u8BA4_u60C5_u51B5_u4E0B_uFF0C_u5176_u4E3Afalse_u3002_u4EC0_u4E48_u60C5_u51B5_u4E0B_u4F7F_u7528sticky_u5462_uFF1F" class="headerlink" title="默认情况下，其为false。什么情况下使用sticky呢？"></a>默认情况下，其为false。什么情况下使用sticky呢？</h5><p>相信大多数使用过<code>EventBus 2.4</code>的同学或多或少的使用过：</p>
<pre><code>EventBus.getDefault().postSticky(new VoteEvent(obj));
EventBus.getDefault().registerSticky(this);
</code></pre><p>你会发现非常的麻烦，那么在3.0中：</p>
<pre><code>EventBus.getDefault().postSticky(new VoteEvent(obj));
EventBus.getDefault().register(this);
@Subscribe(sticky = true)
</code></pre><p>什么时候使用<code>sticy</code>,当你希望你的事件不被马上处理的时候，举个栗子，比如说，在一个详情页点赞之后，产生一个<code>VoteEvent</code>，<code>VoteEvent</code>并不立即被消费，而是等用户退出详情页回到商品列表之后，接收到该事件，然后刷新<code>Adapter</code>等。其实这就是之前我们用<code>startActivityForResult</code>和<code>onActivityResult</code>做的事情。</p>
<p>  priority = 1</p>
<p>相信大部分人知道该用法，值越小优先级越低，默认为0。</p>
<h5 id="u5EFA_u8BAE"><a href="#u5EFA_u8BAE" class="headerlink" title="建议"></a>建议</h5><p>推荐大家在使用EventBus的时候，创建一个事件类，把你的每一个参数（或者可能发生冲突的参数），封装成一个类：</p>
<pre><code>public class Event  {  
    public static class UserListEvent {  
        public List&lt;User&gt; users ;  
    }
    public static class ItemListEvent {  
        public List&lt;Item&gt; items;  
    }    
}  
</code></pre><h5 id="u6DFB_u52A0processor"><a href="#u6DFB_u52A0processor" class="headerlink" title="添加processor"></a>添加processor</h5><p>按照Markus Junginger的说法（EventBus创作者），在3.0中，如果你想进一步提升你的app的性能，你需要添加：</p>
<pre><code>provided &apos;de.greenrobot:eventbus-annotation-processor:3.0.0-beta1&apos;
</code></pre><p>其在编译的时候为注册类构建了一个索引，而不是在运行时，这样的结果是其让EventBus 3.0的性能提升了一倍，相比2.4来说，其会是它的3到6倍。大家可以感受下：<br><img src="https://segmentfault.com/img/bVsgvf" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前一篇文章简单介绍了<code>EventBus 3.0</code>的用法，现在是时候详解其用法了。首先声明，<code>EventBus 3.0</code>的改动针对2.4的改动并不是特别大，但是对于其性能的提升是另外一个说法了，所以建议学习EventBus 3.0。]]>
    
    </summary>
    
      <category term="EventBus" scheme="http://yoursite.com/tags/EventBus/"/>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[EventBus 3.0的用法详解（一）]]></title>
    <link href="http://yoursite.com/2015/06/25/EventBus%203.0%E7%9A%84%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2015/06/25/EventBus 3.0的用法详解（一）/</id>
    <published>2015-06-25T14:01:14.000Z</published>
    <updated>2016-02-19T09:11:57.392Z</updated>
    <content type="html"><![CDATA[<p>看到大家提出的关于Android的问题，有一部分可以用EventBus解决，而也有相当多的人推荐使用<code>EventsBus</code>,因为其和GreenDAO出自一家公司，并且使用它非常的简单，所以现在很多的互联网app都会使用<code>EventsBus</code>来进行消息传递。</p>
<p>基于此，有很多<code>EventBus</code>的文章，写的非常的好，但是由于<code>EventBus</code>已经出了3.0版本，而国内的大多数翻译只是停留在了2.4版本左右，对于那些刚刚接触<code>EventBus</code>的人，从最新版接触学习，是最理想的学习路线。</p>
<p>所以，在这儿，我总结下<code>EventBus3.0</code>的用法。<a id="more"></a></p>
<h3 id="u4EC0_u4E48_u662FEventBus"><a href="#u4EC0_u4E48_u662FEventBus" class="headerlink" title="什么是EventBus"></a>什么是<code>EventBus</code></h3><p><code>EventBus</code>是一个Android端优化的<code>publish/subscribe</code>消息总线，简化了应用程序内各组件间、组件与后台线程间的通信。比如请求网络，等网络返回时通过<code>Handler</code>或<code>Broadcast</code>通知UI，两个<code>Fragment</code>之间需要通过<code>Listener</code>通信，这些需求都可以通过<code>EventBus</code>实现。</p>
<h3 id="EventBus_u6846_u67B6"><a href="#EventBus_u6846_u67B6" class="headerlink" title="EventBus框架"></a>EventBus框架</h3><p>大家谈到EventBus，总会想到<code>greenrobot</code>的<code>EventBus</code>，但是实际上<code>EventBus</code>是一个通用的叫法，例如Google出品的Guava，Guava是一个庞大的库，<code>EventBus</code>只是它附带的一个小功能，因此实际项目中使用并不多。用的最多的是<code>greenrobot/EventBus</code>，这个库的优点是接口简洁，集成方便，但是限定了方法名，不支持注解。另一个库<code>square/otto</code>修改自 <code>Guava</code>，用的人也不少。</p>
<h3 id="u8FD9_u7BC7_u535A_u6587_u6682_u65F6_u53EA_u8BA8_u8BBAgreenrobot_u7684EventBus_u5E93_u3002"><a href="#u8FD9_u7BC7_u535A_u6587_u6682_u65F6_u53EA_u8BA8_u8BBAgreenrobot_u7684EventBus_u5E93_u3002" class="headerlink" title="这篇博文暂时只讨论greenrobot的EventBus库。"></a>这篇博文暂时只讨论greenrobot的EventBus库。</h3><h3 id="u57FA_u672C_u7528_u6CD5"><a href="#u57FA_u672C_u7528_u6CD5" class="headerlink" title="基本用法"></a>基本用法</h3><p>很多文章会讲到<code>Subscriber</code>，以及<code>Publisher</code>和<code>ThreadMode</code>等概念，我觉得暂时没有必要，简单粗暴，直接上代码：</p>
<h4 id="1_u3001_u6DFB_u52A0_u4F9D_u8D56_u5E93_uFF1A"><a href="#1_u3001_u6DFB_u52A0_u4F9D_u8D56_u5E93_uFF1A" class="headerlink" title="1、添加依赖库："></a>1、添加依赖库：</h4><p>首先你要为你的app添加依赖库：</p>
<pre><code>compile &apos;de.greenrobot:eventbus:3.0.0-beta1&apos;
</code></pre><p>有些人会问为什么是beta版本，因为eventbus现阶段3.0版本只处于beta测试阶段。有些人会问如何找到·eventbus 3.0.0·版本，具体添加:</p>
<p><img src="https://segmentfault.com/img/bVr7mp" alt=""></p>
<h4 id="2_u3001_u6CE8_u518C"><a href="#2_u3001_u6CE8_u518C" class="headerlink" title="2、注册"></a>2、注册</h4><p>举个例子，你需要在一个activity中注册eventbus事件，然后定义接收方法，这和Android的广播机制很像，你需要首先注册广播，然后需要编写内部类，实现接收广播，然后操作UI,在EventBus中，你同样需要这么做。</p>
<pre><code>@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    EventBus.getDefault().register(this);

}
@Override
protected void onDestroy() {
    super.onDestroy();
    EventBus.getDefault().unregister(this);
}
</code></pre><h4 id="3_u3001_u8BA2_u9605_u8005"><a href="#3_u3001_u8BA2_u9605_u8005" class="headerlink" title="3、订阅者"></a>3、订阅者</h4><p>类似广播，但是有别于2.4版本，你不必再去约定OnEvent方法开头了（看不懂没关系）：</p>
<pre><code>@Subscribe(threadMode = ThreadMode.MainThread)
public void helloEventBus(String message){
    mText.setText(message);
}
</code></pre><p>该操作很简单，定义了一个hello方法，需要传入String参数，在其中操作UI操作，注意：<br>我们添加了注解@Subscribe，其含义为订阅者，在其内传入了threadMode，我们定义为ThreadMode.MainThread，其含义为该方法在UI线程完成，这样你就不要担心抛出异常啦。是不是很简单？</p>
<h4 id="4_u3001_u53D1_u5E03_u8005"><a href="#4_u3001_u53D1_u5E03_u8005" class="headerlink" title="4、发布者"></a>4、发布者</h4><p>既然你在某个地方订阅了内容，当然就会在某个地方发布消息。举个例子，你的这个activity需要http请求，而http请求你肯定是在异步线程中操作，其返回结果后，你可以这么写：</p>
<pre><code>String json=&quot;&quot;;
EventBus.getDefault().post(json);
</code></pre><p>这样就OK了，你可以试下能否正常运行了！</p>
<h4 id="5_u3001_u539F_u7406_u521D_u63A2"><a href="#5_u3001_u539F_u7406_u521D_u63A2" class="headerlink" title="5、原理初探"></a>5、原理初探</h4><p>你订阅了内容，所以你需要在该类注册EventBus，而你订阅的方法需要传入String,即你的接收信息为String类型，那么在post的时候，你post出去的也应该是String类型，其才会接收到消息。</p>
<h4 id="6_u3001_u5982_u679C_u4F60post_u7684_u662F_u5BF9_u8C61"><a href="#6_u3001_u5982_u679C_u4F60post_u7684_u662F_u5BF9_u8C61" class="headerlink" title="6、如果你post的是对象"></a>6、如果你post的是对象</h4><p>首先你需要定义一个类似pojo类：</p>
<pre><code>public class MessageEvent {
  public final String name;
  public final String password;
  public MessageEvent(String name,String password) {
    this.name = name;
    this.password=password;
  }
}
</code></pre><p>然后你post的时候：</p>
<pre><code>EventBus.getDefault().post(new MessageEvent(&quot;hello&quot;,&quot;world&quot;));
</code></pre><p>当然，你接收的方法也需要改为：</p>
<pre><code>@Subscribe(threadMode = ThreadMode.MainThread)
public void helloEventBus(MessageEvent message){
    mText.setText(message.name);
}
</code></pre><p>疑问，当你post了消息之后，你的订阅者有多个，每一个都接收吗？能否做到指定接收者。</p>
<p>下一章，带来源码解析以及EventBus的高级用法；<br>如果大家有兴趣，也可带领大家编写属于自己的EventBus框架，敬请期待。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>看到大家提出的关于Android的问题，有一部分可以用EventBus解决，而也有相当多的人推荐使用<code>EventsBus</code>,因为其和GreenDAO出自一家公司，并且使用它非常的简单，所以现在很多的互联网app都会使用<code>EventsBus</code>来进行消息传递。</p>
<p>基于此，有很多<code>EventBus</code>的文章，写的非常的好，但是由于<code>EventBus</code>已经出了3.0版本，而国内的大多数翻译只是停留在了2.4版本左右，对于那些刚刚接触<code>EventBus</code>的人，从最新版接触学习，是最理想的学习路线。</p>
<p>所以，在这儿，我总结下<code>EventBus3.0</code>的用法。]]>
    
    </summary>
    
      <category term="EventBus" scheme="http://yoursite.com/tags/EventBus/"/>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android自定义对话框(Dialog)位置,大小]]></title>
    <link href="http://yoursite.com/2015/06/21/%E8%87%AA%E5%AE%9A%E4%B9%89Dialog%E7%9A%84%E5%A4%A7%E5%B0%8F%E3%80%81%E4%BD%8D%E7%BD%AE%E3%80%81%E9%A2%9C%E8%89%B2/"/>
    <id>http://yoursite.com/2015/06/21/自定义Dialog的大小、位置、颜色/</id>
    <published>2015-06-21T14:32:17.000Z</published>
    <updated>2016-02-19T09:06:22.945Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>代码:</p>
</blockquote>
<pre><code>package angel.devil;
import android.app.Activity;
import android.app.Dialog;
import android.os.Bundle;
import android.view.Gravity;
import android.view.Window;
import android.view.WindowManager;

public class DialogDemoActivity extends Activity {
/** Called when the activity is first created. */
@Override
public void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.main);
Dialog dialog = new Dialog(this);

// setContentView可以设置为一个View也可以简单地指定资源ID
// LayoutInflater
// li=(LayoutInflater)getSystemService(LAYOUT_INFLATER_SERVICE);
// View v=li.inflate(R.layout.dialog_layout, null);
// dialog.setContentView(v);
dialog.setContentView(R.layout.dialog_layout);

dialog.setTitle(&quot;Custom Dialog&quot;);
</code></pre><hr>
<a id="more"></a>
<pre><code>/*
* 获取圣诞框的窗口对象及参数对象以修改对话框的布局设置,
* 可以直接调用getWindow(),表示获得这个Activity的Window
* 对象,这样这可以以同样的方式改变这个Activity的属性.
*/
Window dialogWindow = dialog.getWindow();
WindowManager.LayoutParams lp = dialogWindow.getAttributes();
dialogWindow.setGravity(Gravity.LEFT | Gravity.TOP);

/*
* lp.x与lp.y表示相对于原始位置的偏移.
* 当参数值包含Gravity.LEFT时,对话框出现在左边,所以lp.x就表示相对左边的偏移,负值忽略.
* 当参数值包含Gravity.RIGHT时,对话框出现在右边,所以lp.x就表示相对右边的偏移,负值忽略.
* 当参数值包含Gravity.TOP时,对话框出现在上边,所以lp.y就表示相对上边的偏移,负值忽略.
* 当参数值包含Gravity.BOTTOM时,对话框出现在下边,所以lp.y就表示相对下边的偏移,负值忽略.
* 当参数值包含Gravity.CENTER_HORIZONTAL时
* ,对话框水平居中,所以lp.x就表示在水平居中的位置移动lp.x像素,正值向右移动,负值向左移动.
* 当参数值包含Gravity.CENTER_VERTICAL时
* ,对话框垂直居中,所以lp.y就表示在垂直居中的位置移动lp.y像素,正值向右移动,负值向左移动.
* gravity的默认值为Gravity.CENTER,即Gravity.CENTER_HORIZONTAL |
* Gravity.CENTER_VERTICAL.
*
* 本来setGravity的参数值为Gravity.LEFT | Gravity.TOP时对话框应出现在程序的左上角,但在
* 我手机上测试时发现距左边与上边都有一小段距离,而且垂直坐标把程序标题栏也计算在内了,
* Gravity.LEFT, Gravity.TOP, Gravity.BOTTOM与Gravity.RIGHT都是如此,据边界有一小段距离
*/
lp.x = 100; // 新位置X坐标
lp.y = 100; // 新位置Y坐标
lp.width = 300; // 宽度
lp.height = 300; // 高度
lp.alpha = 0.7f; // 透明度

// 当Window的Attributes改变时系统会调用此函数,可以直接调用以应用上面对窗口参数的更改,也可以用setAttributes
// dialog.onWindowAttributesChanged(lp);
dialogWindow.setAttributes(lp);

/*
* 将对话框的大小按屏幕大小的百分比设置
*/
//        WindowManager m = getWindowManager();
//        Display d = m.getDefaultDisplay(); // 获取屏幕宽、高用
//        WindowManager.LayoutParams p = dialogWindow.getAttributes(); // 获取对话框当前的参数值
//        p.height = (int) (d.getHeight() * ); // 高度设置为屏幕的0.6
//        p.width = (int) (d.getWidth() * 0.65); // 宽度设置为屏幕的0.65
//        dialogWindow.setAttributes(p);

dialog.show();

}
}
</code></pre><blockquote>
<p>布局文件:<br>main.xml</p>
</blockquote>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
android:layout_width=&quot;fill_parent&quot;
android:layout_height=&quot;fill_parent&quot;
android:background=&quot;#00FF00&quot;
android:orientation=&quot;vertical&quot; &gt;

&lt;TextView
android:layout_width=&quot;fill_parent&quot;
android:layout_height=&quot;wrap_content&quot;
android:text=&quot;@string/hello&quot; /&gt;

&lt;/LinearLayout&gt;

dialog_layout.xml

&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
android:id=&quot;@+id/layout_root&quot;
android:layout_width=&quot;fill_parent&quot;
android:layout_height=&quot;fill_parent&quot;
android:orientation=&quot;horizontal&quot;
android:padding=&quot;10dp&quot; &gt;

&lt;ImageView
android:id=&quot;@+id/image&quot;
android:layout_width=&quot;wrap_content&quot;
android:layout_height=&quot;wrap_content&quot;
android:layout_marginRight=&quot;10dp&quot;
android:src=&quot;@drawable/ic_launcher&quot; /&gt;

&lt;TextView
android:id=&quot;@+id/text&quot;
android:layout_width=&quot;wrap_content&quot;
android:layout_height=&quot;wrap_content&quot;
android:text=&quot;A Dialog&quot;
android:textColor=&quot;#FFF&quot; /&gt;

&lt;/LinearLayout&gt;
</code></pre><blockquote>
<p>取消自定义dialog的标题栏</p>
</blockquote>
<p>Android中取消自定义dialog的标题栏, 只需在</p>
<pre><code>dialog.setContentView(R.layout.popwin_chooseversion);
</code></pre><p>前面加一句:</p>
<pre><code>dialog.requestWindowFeature(Window.FEATURE_NO_TITLE);
</code></pre><p>加在这句之后会产生异常.</p>
<p>还要导入</p>
<pre><code>import android.view.Window;
</code></pre><p>包.</p>
<h3 id="android__u5982_u4F55_u8BA9_u81EA_u5B9A_u4E49dialog_u7684_u5BBD_u5EA6_u5145_u6EE1_u6574_u4E2A_u5C4F_u5E55"><a href="#android__u5982_u4F55_u8BA9_u81EA_u5B9A_u4E49dialog_u7684_u5BBD_u5EA6_u5145_u6EE1_u6574_u4E2A_u5C4F_u5E55" class="headerlink" title="android 如何让自定义dialog的宽度充满整个屏幕"></a>android 如何让自定义dialog的宽度充满整个屏幕</h3><h4 id="u65B9_u6848_uFF1A"><a href="#u65B9_u6848_uFF1A" class="headerlink" title="方案："></a>方案：</h4><p>  通过设置Dialog的样式实现</p>
<h5 id="u6B65_u9AA4_uFF1A"><a href="#u6B65_u9AA4_uFF1A" class="headerlink" title="步骤："></a>步骤：</h5><blockquote>
<p>1、添加style</p>
</blockquote>
<pre><code>&lt;style name=&quot;Dialog_FS&quot;&gt;
&lt;item name=&quot;android:windowFullscreen&quot;&gt;true&lt;/item&gt; //设置填充父窗体
&lt;item name=&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt; //设置隐藏标题栏
&lt;/style&gt;
</code></pre><blockquote>
<p>2、代码里面设置dialog的样式</p>
</blockquote>
<pre><code>Dialog dialog = new Dialog(this,R.style.Dialog_FS); //设置全屏样式
dialog.setContentView(R.layout.main); //设置dialog的布局
dialog.show();//显示dialog界面
</code></pre><blockquote>
<p>3.style文件具体</p>
</blockquote>
<pre><code>  &lt;style name=&quot;iphone_progress_dialog&quot; parent=&quot;@android:style/Theme.Dialog&quot;&gt;
     &lt;item name=&quot;android:windowFrame&quot;&gt;@null&lt;/item&gt; &lt;!--Dialog的windowFrame框为无--&gt; 
     &lt;item name=&quot;android:windowIsFloating&quot;&gt;true&lt;/item&gt;&lt;!-- 是否漂现在activity上--&gt;
     &lt;item name=&quot;android:windowIsTranslucent&quot;&gt;true&lt;/item&gt;&lt;!-- 是否半透明 --&gt;
     &lt;item name=&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt;
     &lt;item name=&quot;android:backgroundDimEnabled&quot;&gt;false&lt;/item&gt;&lt;!-- dim:模糊的 阴影效果 --&gt;
     &lt;item name=&quot;android:windowBackground&quot;&gt;@drawable/load_bg&lt;/item&gt;&lt;!-- 背景图片的大小也影响窗口的大小 --&gt;
&lt;/style&gt;
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>代码:</p>
</blockquote>
<pre><code>package angel.devil;
import android.app.Activity;
import android.app.Dialog;
import android.os.Bundle;
import android.view.Gravity;
import android.view.Window;
import android.view.WindowManager;

public class DialogDemoActivity extends Activity {
/** Called when the activity is first created. */
@Override
public void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.main);
Dialog dialog = new Dialog(this);

// setContentView可以设置为一个View也可以简单地指定资源ID
// LayoutInflater
// li=(LayoutInflater)getSystemService(LAYOUT_INFLATER_SERVICE);
// View v=li.inflate(R.layout.dialog_layout, null);
// dialog.setContentView(v);
dialog.setContentView(R.layout.dialog_layout);

dialog.setTitle(&quot;Custom Dialog&quot;);
</code></pre><hr>]]>
    
    </summary>
    
      <category term="Dialog" scheme="http://yoursite.com/tags/Dialog/"/>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android AsyncTask 技巧]]></title>
    <link href="http://yoursite.com/2014/11/07/Android%20AsyncTask%20%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2014/11/07/Android AsyncTask 技巧/</id>
    <published>2014-11-07T15:23:14.000Z</published>
    <updated>2016-02-22T05:44:14.472Z</updated>
    <content type="html"><![CDATA[<h4 id="AsyncTask_u7684_u539F_u7406"><a href="#AsyncTask_u7684_u539F_u7406" class="headerlink" title="AsyncTask的原理"></a>AsyncTask的原理</h4><p>其实AsyncTask的原理简单来说，就是：</p>
<ul>
<li>一个任务队：用于存放自定义的（WorkerRunnable）。</li>
<li>一个线程池：初始化好任务队列，放入该线程池中。</li>
<li>一个内部Handler：用于提供线程池执行线程时与主线程之间的交互（刷新控件各种）。</li>
</ul>
<a id="more"></a>
<p>AsyncTask.execute(…)时，会启动AsyncTask的线程池，开始执行池中的任务队。只有doInBackground()在线程池中的线程执行，所以不能更新主UI线程的控件，剩下的onProgressUpdate()、onPostExecute()、onCancelled()、onPreExecute()在主UI线程中。onPreExecute()比较特殊的地方就是，它是主线程自己调用的。</p>
<p>这是execute()就直接走到的executeOnExecutor()源码：</p>
<pre><code>public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec,
        Params... params) {
    if (mStatus != Status.PENDING) {
        switch (mStatus) {
            case RUNNING:
                throw new IllegalStateException(&quot;Cannot execute task:&quot;
                        + &quot; the task is already running.&quot;);
            case FINISHED:
                throw new IllegalStateException(&quot;Cannot execute task:&quot;
                        + &quot; the task has already been executed &quot;
                        + &quot;(a task can be executed only once)&quot;);
        }
    }

    mStatus = Status.RUNNING;

    onPreExecute();

    mWorker.mParams = params;
    exec.execute(mFuture);

    return this;
}
</code></pre><p>其他的onProgressUpdate()、onPostExecute()、onCancelled()都经由InternalHandler调用。</p>
<pre><code>private static class InternalHandler extends Handler {
    public InternalHandler() {
        super(Looper.getMainLooper());
    }

    @SuppressWarnings({&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;})
    @Override
    public void handleMessage(Message msg) {
        AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;
        switch (msg.what) {
            case MESSAGE_POST_RESULT:
                // There is only one result
                result.mTask.finish(result.mData[0]);
                break;
            case MESSAGE_POST_PROGRESS:
                result.mTask.onProgressUpdate(result.mData);
                break;
        }
    }
}
</code></pre><p>这里就是各种sendMessage(…)后的转发，最明显是是看到了onProgressUpdate()；</p>
<p>然后onPostExecute()、onCancelled()就在finish()中再次转发</p>
<pre><code>private void finish(Result result) {
    if (isCancelled()) {
        onCancelled(result);
    } else {
        onPostExecute(result);
    }
    mStatus = Status.FINISHED;
}
</code></pre><p>综上，就是内置一个线程池既花式又完美的sendMessage(…)给内部Handler处理的二次封装类<br>AsyncTask 模板</p>
<h4 id="ProgressBarAsyncTask_uFF1A"><a href="#ProgressBarAsyncTask_uFF1A" class="headerlink" title="ProgressBarAsyncTask："></a>ProgressBarAsyncTask：</h4><pre><code>/**
 * Description：
 * Created by：CaMnter
 * Time：2015-09-17 14:19
 */
public class ProgressBarAsyncTask extends AsyncTask&lt;String, Integer, String&gt; {

    private TextView textview;
    private ProgressBar progressBar;

    public ProgressBarAsyncTask(ProgressBar progressBar, TextView textview) {
        super();
        this.textview = textview;
        this.progressBar = progressBar;

    }

    /**
     * 对应AsyncTask第一个参数
     * 异步操作，不在主UI线程中，不能对控件进行修改
     * 可以调用publishProgress方法中转到onProgressUpdate(这里完成了一个handler.sendMessage(...)的过程)
     *
     * @param params The parameters of the task.
     * @return A result, defined by the subclass of this task.
     * @see #onPreExecute()
     * @see #onPostExecute
     * @see #publishProgress
     */
    @Override
    protected String doInBackground(String... params) {
        int i = 0;
        for (; i &lt; 100; i++) {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            this.publishProgress(i);
        }
        return i + params[0];
    }

    /**
     * 对应AsyncTask第二个参数
     * 在doInBackground方法当中，每次调用publishProgress方法都会中转(handler.sendMessage(...))到onProgressUpdate
     * 在主UI线程中，可以对控件进行修改
     *
     * @param values The values indicating progress.
     * @see #publishProgress
     * @see #doInBackground
     */
    @Override
    protected void onProgressUpdate(Integer... values) {
        int value = values[0];
        this.progressBar.setProgress(value);
        this.textview.setText(value+&quot;%&quot;);
    }

    /**
     * 对应AsyncTask第三个参数 (接受doInBackground的返回值)
     * 在doInBackground方法执行结束之后在运行，此时已经回来主UI线程当中 能对UI控件进行修改
     *
     * @param s The result of the operation computed by {@link #doInBackground}.
     * @see #onPreExecute
     * @see #doInBackground
     * @see #onCancelled(Object)
     */
    @Override
    protected void onPostExecute(String s) {
        this.textview.setText(&quot;执行结束：&quot; + s);
    }

    /**
     * 运行在主UI线程中，此时是预执行状态，下一步是doInBackground
     *
     * @see #onPostExecute
     * @see #doInBackground
     */
    @Override
    protected void onPreExecute() {
        super.onPreExecute();
    }

    /**
     * &lt;p&gt;Applications should preferably override {@link #onCancelled(Object)}.
     * This method is invoked by the default implementation of
     * {@link #onCancelled(Object)}.&lt;/p&gt;
     * &lt;p/&gt;
     * &lt;p&gt;Runs on the UI thread after {@link #cancel(boolean)} is invoked and
     * {@link #doInBackground(Object[])} has finished.&lt;/p&gt;
     *
     * @see #onCancelled(Object)
     * @see #cancel(boolean)
     * @see #isCancelled()
     */
    @Override
    protected void onCancelled() {
        super.onCancelled();
    }

}
</code></pre><h4 id="Activity_uFF1A"><a href="#Activity_uFF1A" class="headerlink" title="Activity："></a>Activity：</h4><pre><code>ProgressBarAsyncTask asyncTask = new ProgressBarAsyncTask(this.progressBar, this.textview);
asyncTask.execute(&quot;%&quot;);
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h4 id="AsyncTask_u7684_u539F_u7406"><a href="#AsyncTask_u7684_u539F_u7406" class="headerlink" title="AsyncTask的原理"></a>AsyncTask的原理</h4><p>其实AsyncTask的原理简单来说，就是：</p>
<ul>
<li>一个任务队：用于存放自定义的（WorkerRunnable）。</li>
<li>一个线程池：初始化好任务队列，放入该线程池中。</li>
<li>一个内部Handler：用于提供线程池执行线程时与主线程之间的交互（刷新控件各种）。</li>
</ul>]]>
    
    </summary>
    
      <category term="AsyncTask" scheme="http://yoursite.com/tags/AsyncTask/"/>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[图像、背景、View更新、布局、内存]]></title>
    <link href="http://yoursite.com/2014/11/05/%E5%9B%BE%E5%83%8F%E3%80%81%E8%83%8C%E6%99%AF%E3%80%81View%E6%9B%B4%E6%96%B0%E3%80%81%E5%B8%83%E5%B1%80%E3%80%81%E5%86%85%E5%AD%98/"/>
    <id>http://yoursite.com/2014/11/05/图像、背景、View更新、布局、内存/</id>
    <published>2014-11-05T14:01:14.000Z</published>
    <updated>2016-02-22T05:43:04.243Z</updated>
    <content type="html"><![CDATA[<h3 id="u56FE_u50CF"><a href="#u56FE_u50CF" class="headerlink" title="图像"></a>图像</h3><p>选择适当的图像尺寸<br>视图背景图像总会填充整个视图区域</p>
<pre><code>1.视图背景图像总会填充整个视图区域
2.避免实时缩放
3.最好预先缩放到视图大小
</code></pre><a id="more"></a>
<hr>
<pre><code>package com.zyy.android_csdn.skill;

import android.graphics.Bitmap;
import android.view.View;

/**
 *
 * 精致的图片
 *
 * @author CaMnter
 *
 */
public class ExquisiteImage {

    // 被缩放的图片
    private Bitmap originalImage;

    // 视图
    private View view;

    public ExquisiteImage(Bitmap originalImage, View view) {

        this.originalImage = originalImage;

        this.view = view;

    }

    /**
     * @return 适应View的Bitmap
     */
    public Bitmap getBitmap() {

        /**
         *
         * 第一参数：被缩放图像
         * 第二参数：视图宽度
         * 第三参数：视图高度
         * 第四参数：双线性过滤器
         *
         */
        return Bitmap.createScaledBitmap(this.originalImage,
                this.view.getWidth(), this.view.getHeight(), true);

    }

}
</code></pre><h3 id="u80CC_u666F"><a href="#u80CC_u666F" class="headerlink" title="背景"></a>背景</h3><pre><code>  默认情况下, 窗口有一个不透明的背景

  有时可以不需要
1.最高层的视图是不透明的
   2.最高层的视图覆盖整个窗口
      &lt;1&gt;.layout_width = fill_parent
      &lt;2&gt;.layout_height = fill_parent
   更新看不见的背景是浪费时间
</code></pre><hr>
<pre><code>@Override
protected void onCreate(Bundle savedInstanceState) {

    super.onCreate(savedInstanceState);

    setContentView(R.layout.activity_main);

    // 删除窗口背景
    getWindow().setBackgroundDrawable(null);

    ...

}
</code></pre><h3 id="View_u66F4_u65B0"><a href="#View_u66F4_u65B0" class="headerlink" title="View更新"></a>View更新</h3><p>当屏幕需要更新时, 调用 invalidate()</p>
<pre><code>1.简单方便
2.但是会更新整个视图, 代价太大了
</code></pre><p>最好先找到无效的区域，然后调用</p>
<pre><code>1.invalidate(Rect dirty);
2.invalidate(int left, int top, int right, int bottom);
</code></pre><p>优化上：就是 原来的 刷新了整个视图，现在的只是刷新了 改变后的位置和原来的位置 在内存的一块区域。</p>
<h3 id="u5E03_u5C40"><a href="#u5E03_u5C40" class="headerlink" title="布局"></a>布局</h3><p>越简单越好</p>
<p>如果一个窗口包含很多视图：</p>
<pre><code>1.启动时间长
2.测量时间长
3.布局时间长
4.绘制时间长
</code></pre><p>如果视图树深度太深</p>
<pre><code>1.StackOverflowException
2.用户界面反应速度很慢
</code></pre><p>解决办法：</p>
<pre><code>1.使用TextView的复合drawables减少层次
2.使用ViewStub延迟展开视图
3.使用&lt;merge&gt;合并中间视图
4.使用RelativeLayout减少层次
5.使用自定义视图
6.使用自定义布局
</code></pre><h4 id="u5185_u5B58"><a href="#u5185_u5B58" class="headerlink" title="内存"></a>内存</h4><p>不要随意创建 Java 对象</p>
<p>在以下性能敏感的代码中，尽量避免创建Java对象：</p>
<pre><code>1.测量：onMeasure()
2.布局：onLayout()
3.绘图：dispatchDraw(), onDraw()
4.事件处理：dispatchTouchEvent(), onTouchEvent()
5.Adapter：getView(), bindView()
</code></pre><p>GC，垃圾回收</p>
<pre><code>1.整个程序会暂停
2.慢（大概好几百个毫秒）
</code></pre><p>管理好Java对象</p>
<pre><code>1.使用软引用：内存缓存的最佳选择
2.使用弱引用：避免内存泄露
</code></pre><hr>
<pre><code>private final HashMap&lt;String, SoftReference&lt;T&gt;&gt; mCache;

public void put(String key, T value) {
    mCache.put(key, new SoftReference&lt;T&gt;(value));
}

public T get(String key, ValueBuilder builder) {
    T value = null;
    SoftReferece&lt;T&gt; reference = mCache.get(key);
    if (reference != null) {
        value = reference.get();
    }
    if (value == null) {
        value = builder.build(key);
        mCache.put(key, new SoftReference&lt;T&gt;(value));
    }
    return value;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u56FE_u50CF"><a href="#u56FE_u50CF" class="headerlink" title="图像"></a>图像</h3><p>选择适当的图像尺寸<br>视图背景图像总会填充整个视图区域</p>
<pre><code>1.视图背景图像总会填充整个视图区域
2.避免实时缩放
3.最好预先缩放到视图大小
</code></pre>]]>
    
    </summary>
    
      <category term="图像、背景、View更新、布局、内存" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%83%8F%E3%80%81%E8%83%8C%E6%99%AF%E3%80%81View%E6%9B%B4%E6%96%B0%E3%80%81%E5%B8%83%E5%B1%80%E3%80%81%E5%86%85%E5%AD%98/"/>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[健身]]></title>
    <link href="http://yoursite.com/2014/10/08/%E5%81%A5%E8%BA%AB/"/>
    <id>http://yoursite.com/2014/10/08/健身/</id>
    <published>2014-10-08T07:13:06.000Z</published>
    <updated>2016-02-19T09:05:23.442Z</updated>
    <content type="html"><![CDATA[<p>少年不知精贵，老了望批空流泪。<br><a id="more"></a></p>
<p>这句话常常都是说给那些爱打飞机的男性朋友了，确实，打飞机在某种程度上真的可以给我们带来一些“快乐时光”。但是，你怎么不想想，如果因为你长期打飞机，导致当有一个美女裸身在你眼前，你却硬不起来时，那该是怎样的一种悲剧呢？<br>  男人怎么让自己更持久一点？来看看真正的锻炼方法！<br>有人会说，那我戒撸就可以了，其实如果你经常打飞机，虽然你可以克制自己，达到戒撸成功，但你的肾已经有亏损了，你还是会早泄。所以就算你不撸了，你的肾功能还是不行，你还是会不持久，你还是不能满足你的女友或老婆。<br>  所以，现在很多男性朋友都想找方法，怎么让自己持久起来呢？下面，给大家分享一下方法。先说一下名字，分别是金刚铁板桥和缩阴功，一听到这两个名字，估计就有人知道了。</p>
<p>  金刚铁板桥方法：准备两个一样高的椅子，仰卧，将肩膀以上的部位和脚踝以下的部位放在椅子上，身体悬空挺直，一直坚持下去就可，注意屁股不可下垂，身体一定要挺直，如桥一样。双手可以随意放在腹上，由于解放了手，锻练部位即完全集中于腰背部。不用任何的意念，运气之类，坚持下次就见效果，一般刚练习的人一分钟左右就感到腰部酸疼难忍，这证明你练对了。<br>  效果：一般能坚持三十分钟以上，练习两三个月左右，平常有腰酸背痛，遗精早泄毛病的人很容易恢复正常，感觉精力强大，走路轻快，不易疲劳。<br>缩阴功方法：缩阴功练法有两种:一种是用力收缩肛门，如忍便状，能忍十分钟不放松即合格，另一种是一下一下的用力收缩肛门，节奏两秒一次，意识要集中。<br>效果：一般能做到连继收缩三百 下以上，性能力则能做到三十分钟不泄。<br>  解说金刚铁板桥的要点在于每日坚持练习，每一次练习争取比上一次多坚持一段时间，各位则可以计数练习。古人训练时会在屁股下点一根香，当每次坚持不了，屁股下沉时即被香火烧到屁股。这种方法当然不会建议你们模仿，毕竟安全更重要。<br>为了练习安全，建议你们在床上练习，用两个小矮凳架在肩脚两头，没有凳子可另找东西代替，比如箱子，一叠书都行。这样练习的好处时，万一你坚持不住，即可以一屁股掉到床上，没多大的危险。<br>  金刚铁板桥练到高级境界，如能坚持一小时，则可以在腹上放五十斤以上的东西，也可以让一人坐在肚子上。如果你仍能坚持一小时以上，则你的腰肾强壮到极限，真正的如金刚铁板，比吃了任何大补药的人还健壮，就算到老了也如少年人。如果你还能坚持练习了缩阴功，那恭喜你，你已经金枪不倒了。<br>上面两种方法最好是配合起来练习，我让我弟弟试了一下，配合起来练还是很有效果的，一般当天做，当天去啪啪啪，你就能感受到。所以，如果你以前是经常打飞机的话，那么这个方法还是趁早去锻炼吧！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>少年不知精贵，老了望批空流泪。<br>]]>
    
    </summary>
    
      <category term="开发规范" scheme="http://yoursite.com/tags/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[widget用法]]></title>
    <link href="http://yoursite.com/2014/09/18/widget%E7%94%A8%E6%B3%95/"/>
    <id>http://yoursite.com/2014/09/18/widget用法/</id>
    <published>2014-09-17T18:24:16.000Z</published>
    <updated>2016-02-19T09:01:18.404Z</updated>
    <content type="html"><![CDATA[<p>September 23, 2015 8:21 PM</p>
<p>创建AppWidgetProvider的子类</p>
<pre><code>public class MyAppWidgetProvider extends AppWidgetProvider {
@Override
public void onEnabled(Context context) {
    // 第一次创建执行
    // 服务监控进程状态
    Intent service = new Intent(context,TaskWidgetService.class);
    context.startService(service);
    super.onEnabled(context);
}

@Override
public void onDisabled(Context context) {
    //删除最后一个执行
    Intent service = new Intent(context,TaskWidgetService.class);
    context.stopService(service);
    super.onDisabled(context);
}
}
</code></pre><a id="more"></a>
<p>创建xml文件夹，创建info的xml文件</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;appwidget-provider xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:initialLayout=&quot;@layout/process_widget&quot;
    android:minHeight=&quot;72.0dip&quot;
    android:minWidth=&quot;294.0dip&quot;
    android:updatePeriodMillis=&quot;0&quot; /&gt;
</code></pre><p>配置清单文件</p>
<pre><code>&lt;receiver android:name=&quot;ExampleAppWidgetProvider&quot; &gt;
    &lt;intent-filter&gt;
    &lt;action android:name=&quot;android.appwidget.action.APPWIDGET_UPDATE&quot; /&gt;
    &lt;/intent-filter&gt;
    &lt;meta-data android:name=&quot;android.appwidget.provider&quot;
    android:resource=&quot;@xml/example_appwidget_info&quot; /&gt;
&lt;/receiver&gt;
</code></pre><p>广播一定要在清单文件中注册</p>
<pre><code> &lt;receiver android:name=&quot;com.itheima.mobilesafe13.receiver.WidgetClearTaskReceiver&quot;&gt;
    &lt;intent-filter &gt;然后在显示Toast的地方
        &lt;action android:name=&quot;widget.clear.task&quot;&gt;&lt;/action&gt;
        &lt;/intent-filter&gt;
&lt;/receiver&gt;
&lt;receiver android:name=&quot;com.itheima.mobilesafe13.receiver.MyAppWidgetProvider&quot; &gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.appwidget.action.APPWIDGET_UPDATE&quot; /&gt;
    &lt;/intent-filter&gt;
    &lt;meta-data
        android:name=&quot;android.appwidget.provider&quot;
        android:resource=&quot;@xml/process_widget_provider&quot; /&gt;
    &lt;/receiver&gt;
</code></pre><p>使用widget</p>
<pre><code>/**
* @author Administrator
* @desc 清理进程的widget的服务
*/
public class TaskWidgetService extends Service {

    private AppWidgetManager mAWM;

    @Override
    public IBinder onBind(Intent intent) {
        // TODO Auto-generated method stub
        return null;
    }

    @Override
    public void onCreate() {
        mAWM = AppWidgetManager.getInstance(getApplicationContext());
        System.out.println(&quot;widget  service create&quot;);

        Timer timer = new Timer();
        TimerTask task = new TimerTask() {

            @Override
            public void run() {
                updateWidgetMessage();

            }
        };
        timer.schedule(task, 0 , 1000 * 2);
        super.onCreate();
    }

    protected void updateWidgetMessage() {
        ComponentName provider = new ComponentName(getApplicationContext(), MyAppWidgetProvider.class);
        RemoteViews views = new RemoteViews(getPackageName(), R.layout.process_widget);
        views.setTextViewText(R.id.tv_process_count, &quot;运行中的软件:&quot; + TaskInfoUtils.getAllRunningAppInfos(getApplicationContext()).size());
        views.setTextViewText(R.id.tv_process_memory, &quot;可用内存:&quot; + Formatter.formatFileSize(getApplicationContext(),
                TaskInfoUtils.getAvailMem(getApplicationContext())));

        Intent intent = new Intent();
        intent.setAction(&quot;widget.clear.task&quot;);
        PendingIntent pendingIntent = PendingIntent.getBroadcast(getApplicationContext(), 0, intent , 0);
        views.setOnClickPendingIntent(R.id.btn_clear, pendingIntent );
        // 更新widget界面
        mAWM.updateAppWidget(provider, views);
    }

    @Override
    public void onDestroy() {
        // TODO Auto-generated method stub
        System.out.println(&quot;widget  service stop&quot;);
        super.onDestroy();
    }

}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>September 23, 2015 8:21 PM</p>
<p>创建AppWidgetProvider的子类</p>
<pre><code>public class MyAppWidgetProvider extends AppWidgetProvider {
@Override
public void onEnabled(Context context) {
    // 第一次创建执行
    // 服务监控进程状态
    Intent service = new Intent(context,TaskWidgetService.class);
    context.startService(service);
    super.onEnabled(context);
}

@Override
public void onDisabled(Context context) {
    //删除最后一个执行
    Intent service = new Intent(context,TaskWidgetService.class);
    context.stopService(service);
    super.onDisabled(context);
}
}
</code></pre>]]>
    
    </summary>
    
      <category term="widget" scheme="http://yoursite.com/tags/widget/"/>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[WebView入门]]></title>
    <link href="http://yoursite.com/2014/08/08/webview%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2014/08/08/webview入门/</id>
    <published>2014-08-07T19:01:56.000Z</published>
    <updated>2016-02-19T09:14:15.816Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>WebView控件可以实现一个浏览器的功能，直接在控件中显示指定的网页</p>
</blockquote>
<p>第一种方式</p>
<p>第一种方式是不需要，在布局文件中，使用WebView控件的</p>
<p>步骤：<br><a id="more"></a></p>
<p>1、创建WebView实例</p>
<pre><code>WebView web= new WebView(Context context);
</code></pre><p>2、webkit浏览器是支持JavaScript的所以，添加支持</p>
<pre><code>web.getSetting.setJavaScriptEnabled（true）;
</code></pre><p>3、添加需要加载的网页地址Uri</p>
<pre><code>web.loadUri(&quot;http://www.google.com&quot;);
</code></pre><p>4、为保证能点击加载页面中的超链接是在当前打开，而不是在系统默认的浏览器中打开 ，需要添加支持</p>
<pre><code>web.setWebViewClient(shouldOverrideUrlLoad(view,url){
                view.loadUrl(url);
                return super.shouldOverrideUrlLoad(view,url);   
});
</code></pre><p>5、显示页面</p>
<pre><code>setContentView(web);
</code></pre><p>6、为了在按系统返回键，出现直接退出app的情况，重写activity的 onkeydown（）方法</p>
<p>7、添加权限</p>
<pre><code>&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;
</code></pre><p>代码实现</p>
<p>布局文件</p>
<pre><code>&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:orientation=&quot;vertical&quot;&gt;

    &lt;TextView
        android:layout_width=&quot;fill_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;社会新闻&quot; /&gt;

&lt;/LinearLayout&gt;
</code></pre><p>实现代码</p>
<pre><code>public class MainActivity extends Activity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
       WebView webView= new WebView(this);
        //支持javascript
        webView.getSettings().setJavaScriptEnabled(true);
        //触摸焦点
        webView.requestFocus();
        //滚动条取消
        webView.setScrollBarStyle(View.SCROLLBARS_OUTSIDE_OVERLAY);
       //指定网页
        webView.loadUrl(&quot;http://www.qiushibaike.com&quot;);
        //显示网页
        setContentView(webView);

       //保证超链接跳转在当前页面
        webView.setWebViewClient(new WebViewClient(){
            @Override
            public boolean shouldOverrideUrlLoading(WebView view, String url) {
                view.loadUrl(url);
                return super.shouldOverrideUrlLoading(view, url);
            }
        } );
    }
       /**
         * 保证，在按系统返回键的时候，不是退出程序，而是，返回上一个页面
         * @param keyCode
         * @param event
         * @return
         */
        @Override
        public boolean onKeyDown(int keyCode, KeyEvent event) {
            if((keyCode==KeyEvent.KEYCODE_BACK))
            {
                webView.goBack(); //返回上一个页面
                return true;
            }
            return  false;
        }
}
</code></pre><p>清单文件</p>
<pre><code>&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
          package=&quot;com.kevin.fragmentdemo&quot; &gt;
        &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;
&lt;/manifest&gt;
</code></pre><p>第二种方式</p>
<p>基本上与第一种方式相同，只是在布局文件中定义了WebView的控件</p>
<p>步骤</p>
<p>1、创建WebView实例,通过的是布局文件中的id创建 XX是WebView组件的id</p>
<pre><code>WebView webView= (WebView) findViewById(R.id.XX);
</code></pre><p>2、webkit浏览器是支持JavaScript的所以，添加支持</p>
<pre><code>webView.getSetting.setJavaScriptEnabled（true）;  
</code></pre><p>3、为保证能点击加载页面中的超链接是在当前打开，而不是在系统默认的浏览器中打开 ，需要添加支持</p>
<pre><code>web.setWebViewClient(shouldOverrideUrlLoad(view,url){
                view.loadUrl(url);
                return super.shouldOverrideUrlLoad(view,url);   
});
</code></pre><p>4、添加需要加载的网页地址Uri</p>
<pre><code>webView.loadUri(&quot;http://www.google.com&quot;);
</code></pre><p>5、为了在按系统返回键，出现直接退出app的情况，重写activity的 onkeydown（）方法（详见代码）</p>
<p>6、添加权限、添加权限</p>
<pre><code>&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;
</code></pre><p>代码实现</p>
<p>布局文件</p>
<pre><code>&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    tools:context=&quot;.MainActivity&quot;&gt;
    &lt;WebView
        android:id=&quot;@+id/wv&quot;
        android:layout_width=&quot;fill_parent&quot;
        android:layout_height=&quot;fill_parent&quot;&gt;
    &lt;/WebView&gt;
&lt;/RelativeLayout&gt;
</code></pre><p>实现代码</p>
<pre><code>public class MainActivity extends Activity {
private WebView webView;
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    webView = (WebView) findViewById(R.id.web_view);
    webView.getSettings().setJavaScriptEnabled(true);
    webView.setWebViewClient(new WebViewClient() {
        @Override
        public boolean shouldOverrideUrlLoading(WebView view, String
        url) {
        view.loadUrl(url); // 根据传入的参数再去加载新的网页
        return true; // 表示当前WebView可以处理打开新网页的请求,不用借助
        系统浏览器
        }
    });
    webView.loadUrl(&quot;http://www.baidu.com&quot;);
}
 /**
  * 保证，在按系统返回键的时候，不是退出程序，而是，返回上一个页面
  * @param keyCode
  * @param event
  * @return
  */
 @Override
 public boolean onKeyDown(int keyCode, KeyEvent event) {
 if((keyCode==KeyEvent.KEYCODE_BACK))
  {
        webView.goBack(); //返回上一个页面
         return true;
  }
            return  false;
  }
}
</code></pre><p>清单文件</p>
<pre><code>&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
        package=&quot;com.kevin.fragmentdemo&quot; &gt;
        &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;
&lt;/manifest&gt;
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>WebView控件可以实现一个浏览器的功能，直接在控件中显示指定的网页</p>
</blockquote>
<p>第一种方式</p>
<p>第一种方式是不需要，在布局文件中，使用WebView控件的</p>
<p>步骤：<br>]]>
    
    </summary>
    
      <category term="WebView" scheme="http://yoursite.com/tags/WebView/"/>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[解析：TypedArray 为什么需要调用recycle()]]></title>
    <link href="http://yoursite.com/2014/07/18/TypedArray/"/>
    <id>http://yoursite.com/2014/07/18/TypedArray/</id>
    <published>2014-07-17T18:21:14.000Z</published>
    <updated>2016-02-19T09:13:59.859Z</updated>
    <content type="html"><![CDATA[<p>在 Android 自定义 View 的时候，需要使用 TypedArray 来获取 XML layout 中的属性值，使用完之后，需要调用 recyle() 方法将 TypedArray 回收。</p>
<p>那么问题来了，这个TypedArray是个什么东西？为什么需要回收呢？TypedArray并没有占用IO，线程，它仅仅是一个变量而已，为什么需要 recycle？<br>为了解开这个谜，首先去找官网的 Documentation，到找 TypedArray 方法，得到下面一个简短的回答：</p>
<p><img src="http://i.imgur.com/0YmjniV.png" alt=""></p>
<a id="more"></a>
<p>这里写图片描述</p>
<p>告诉我们在确定使用完之后调用 recycle() 方法。于是进一步查看该方法的解释，如下：<br>这里写图片描述</p>
<p>简单翻译下来，就是说：回收 TypedArray,用于后续调用时可复用之。当调用该方法后，不能再操作该变量。</p>
<p>同样是一个简洁的答复，但没有解开我们心中的疑惑，这个TypedArray背后，到底隐藏着怎样的秘密……</p>
<p>求之不得，辗转反侧，于是我们决定深入源码，一探其究竟……</p>
<p>首先，是 TypedArray 的常规使用方法：</p>
<pre><code>TypedArray array = context.getTheme().obtainStyledAttributes(attrs,
                R.styleable.PieChart,0,0);
try {
    mShowText = array.getBoolean(R.styleable.PieChart_showText,false);
    mTextPos = array.getInteger(R.styleable.PieChart_labelPosition,0);
}finally {
    array.recycle();
}
</code></pre><p>可见，TypedArray不是我们new出来的，而是调用了 obtainStyledAttributes 方法得到的对象，该方法实现如下：</p>
<pre><code>public TypedArray obtainStyledAttributes(AttributeSet set,
                int[] attrs, int defStyleAttr, int defStyleRes) {
    final int len = attrs.length;
    final TypedArray array = TypedArray.obtain(Resources.this, len);
    // other code .....
    return array;
}
</code></pre><p>我们只关注当前待解决的问题，其他的代码忽略不看。从上面的代码片段得知，TypedArray也不是它实例化的，而是调用了TypedArray的一个静态方法，得到一个实例，再做一些处理，最后返回这个实例。看到这里，我们似乎知道了什么，，，带着猜测，我们进一步查看该静态方法的内部实现：</p>
<pre><code>/**
 * Container for an array of values that were retrieved with
 * {@link Resources.Theme#obtainStyledAttributes(AttributeSet, int[], int, int)}
 * or {@link Resources#obtainAttributes}.  Be
 * sure to call {@link #recycle} when done with them.
 *
 * The indices used to retrieve values from this structure correspond to
 * the positions of the attributes given to obtainStyledAttributes.
 */
public class TypedArray {

    static TypedArray obtain(Resources res, int len) {
        final TypedArray attrs = res.mTypedArrayPool.acquire();
        if (attrs != null) {
            attrs.mLength = len;
            attrs.mRecycled = false;

            final int fullLen = len * AssetManager.STYLE_NUM_ENTRIES;
            if (attrs.mData.length &gt;= fullLen) {
                return attrs;
            }

            attrs.mData = new int[fullLen];
            attrs.mIndices = new int[1 + len];
            return attrs;
        }

        return new TypedArray(res,
                new int[len*AssetManager.STYLE_NUM_ENTRIES],
                new int[1+len], len);
    }
    // Other members ......
}
</code></pre><p>仔细看一下这个方法的实现，我想大部分人都明了了，该类没有公共的构造函数，只提供静态方法获取实例，显然是一个典型的单例模式。在代码片段的第 13 行，很清晰的表达了这个 array 是从一个 array pool的池中获取的。</p>
<p>因此，我们得出结论：</p>
<p>程序在运行时维护了一个 TypedArray的池，程序调用时，会向该池中请求一个实例，用完之后，调用 recycle() 方法来释放该实例，从而使其可被其他模块复用。</p>
<p>那为什么要使用这种模式呢？答案也很简单，TypedArray的使用场景之一，就是上述的自定义View，会随着 Activity的每一次Create而Create，因此，需要系统频繁的创建array，对内存和性能是一个不小的开销，如果不使用池模式，每次都让GC来回收，很可能就会造成OutOfMemory。</p>
<p>这就是使用池+单例模式的原因，这也就是为什么官方文档一再的强调：使用完之后一定 recycle,recycle,recycle。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在 Android 自定义 View 的时候，需要使用 TypedArray 来获取 XML layout 中的属性值，使用完之后，需要调用 recyle() 方法将 TypedArray 回收。</p>
<p>那么问题来了，这个TypedArray是个什么东西？为什么需要回收呢？TypedArray并没有占用IO，线程，它仅仅是一个变量而已，为什么需要 recycle？<br>为了解开这个谜，首先去找官网的 Documentation，到找 TypedArray 方法，得到下面一个简短的回答：</p>
<p><img src="http://i.imgur.com/0YmjniV.png" alt=""></p>]]>
    
    </summary>
    
      <category term="TypedArray" scheme="http://yoursite.com/tags/TypedArray/"/>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
</feed>
