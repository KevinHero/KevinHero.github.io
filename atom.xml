<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[熊凯的个人博客]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://kevinhero.github.io/"/>
  <updated>2016-04-10T08:45:45.000Z</updated>
  <id>http://kevinhero.github.io/</id>
  
  <author>
    <name><![CDATA[熊凯]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[使用AndroidStudio进行NDK开发（一）]]></title>
    <link href="http://kevinhero.github.io/2016/04/09/Android%20Skills/%E4%BD%BF%E7%94%A8Android%20Studio%E8%BF%9B%E8%A1%8CNDK%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://kevinhero.github.io/2016/04/09/Android Skills/使用Android Studio进行NDK开发（一）/</id>
    <published>2016-04-09T05:12:17.000Z</published>
    <updated>2016-04-10T08:45:45.000Z</updated>
    <content type="html"><![CDATA[<p>在AndroidStudio中进行开发比起以往的Eclipse要方便的多，下面来介绍下如何使用AndroidStudio这个IDE工具实现相关开发工作。</p>
<ol>
<li>准备工作</li>
</ol>
<p>在实际写代码之前，首先我们还是需要做一些准备工作：</p>
<p>下载开发包：Android官方下载页面<br>配置系统环境变量<br>下载好开发包之后，直接解压到任意目录，然后需要配置一下系统环境变量，之所以要配置环境变量，是为了方便使用命令ndk-build脚本进行编译。配置参考如下：</p>
<pre><code># 在.bash_profile中配置如下代码
</code></pre><p>export ANDROID_NDK/Users/liangqi/android-ndk<br>export PATH$ANDROID_NDK$PATH</p>
<pre><code># 然后执行如下代码，更新配置文件
</code></pre><p>source .bash_profile<br>其实编译C/C++代码不一定在AndroidStudio中，如果配置好环境变量，直接使用进入项目中的目录执行ndk-build命令即可在当前目录下生成一个的目录，里面存放了不同 平台的包，当然运行这个命令的前提是，这个目录下至少得有一个Android.mk文件，如果需要指定具体的编译平台，那么还需要添加一个Application.mk文件，当然，如果命令行让你头疼，那么你可以采用gradle的方式来解决这些问题，接下来我们将分别介绍这些使用方式。<br><a id="more"></a></p>
<ol>
<li>项目配置</li>
</ol>
<p>使用AndroidStudio开发前我们也要做点额外工作，我们需要在项目根目录下local.properties中添加编译的路径：</p>
<p>ndkdirUsersliangqiandroidndk<br>如果这个文件不存在，你可以手动生成一个，然后再添加上述内容即可。完成这个步骤之后，我们就可以正式开始着手相关的开发工作了。之所以要配置这个目录，目的是让我们开发的项目在使用gradle编译时能够找到<code>NDK</code>相关编译路径</p>
<p>那么，接下来的工作也分为两种情况：</p>
<p>没有（C/C++）源码，别人已经提供好相应的文件，不需要编译代码<br>拥有（C/C++）源码，需要自己编译文件<br>2.1 已有.SO文件，不需要编译源码</p>
<p>这类情况是最简单的，文件以及被其他人员编译好，或者是第三方库来提供的，那么我们只需要把相应文件放到AndroidStudio目录src/main/jniLibs/下即可，当然，肯定需要按CPU架构分不同的子目录，例如，如下：</p>
<p><img src="https://p1.jscssimg.com/a61e938a106e7abf.png" alt=""><br>jniLibs是AndroidStudio默认提供的目录，用来存放已经编译好的文件，当然你也可以放在任意自定义目录下，例如src/main/libs，然后在build.gradle中指定相应的资源目录位置即可：</p>
<p>android<br>    sourceSetsmain<br>        // 你的.so库的实际路径<br>        jniLibssrcDir ‘src/main/libs’ </p>
<p>在导入文件完成之后，那么你可以在相应的类文件中，加载这个静态库，一般来说，文件如果由第三方提供，他在提供文件的同时也会提供相应的调用类文件，或者按之前双方定好的规则自己创建相应类文件，并生成相应的方法，之所以要约定好只因为，下的C/C++函数和桥接的函数命名是有约束的，规则如下：</p>
<p>Java_PackageName_ClassName_MethodName<br>双方必须按这个规则来实现或者调用此函数，否则不会成功，例如，我们现在有一个函数：String stringFromJNI()的函数，它在com.example.hellojni.HelloJni这个文件下，这个函数用来返回一个字符串，功能由底层来实现，那么相应的语言开发文件中就必须按上述规则命名一个Java_com_example_hellojni_HelloJni_stringFromJNI( JNIEnv* env, jobject thiz )的函数，并返回一个字符串结果：</p>
<p>#include </p>
<p>#include<br>// 函数名格式必须按规矩来<br>jstring Java_com_example_hellojni_HelloJni_stringFromJNI JNIEnv env jobject thiz </p>
<pre><code>return env-&gt;NewStringUTFenv &quot;Hello from JNI !  Compiled with ABI &quot; ABI 
</code></pre><p>同样对应的文件也必须：</p>
<p>文件必须在com.example.hellojni包名下<br>类文件名必须是HelloJni<br>方法名必须是stringFromJNI<br>package comexamplehellojni</p>
<p>class HelloJni<br>     public static native String stringFromJNI</p>
<pre><code>static 
    // 加载 hellojni.so静态块
    SystemloadLibrary&quot;hellojni&quot;
</code></pre><p>2.2 有源码，需要编译.so文件</p>
<p>如果有C/C++源码，没有文件，那么我们就得手动把源码文件编译成文件，编译的方式也分为两种：</p>
<p>手工执行命令经行编译<br>使用gradle脚本自动实现编译<br>AndroidStudio默认的源码存放目录是:</p>
<p>src/main/jni<br>如果你没发现此目录，那么你可以手动创建一个，把所有的C/C++源码放在此文件下，当然并非必须要放在此目录下，你可以自定义目录，然后在build.gradle中做一个资源路径指定即可：</p>
<p>// build.gradle<br>android<br>    sourceSetsmain<br>        // 你的源码目录<br>        jnisrcDir ‘src/main/otherDir’ </p>
<p>2.2.1 手工执行命令经行编译</p>
<p>在使用手工编译（C/C++）文件之前，我们要回到文章开头部分，我们需要配置好系统环境变量，这样我们才能在系统环境下执行ndk相关编译命令，如果您的环境变量还没有配置，那么可以参考下文章开头部分，如果已经做好这部分工作，那么咱们继续。</p>
<p>接下来，我们还要创建如下两个文件：</p>
<p>Android.mk<br>Applicatoin.mk (非必要)<br>2.2.1.1 创建Android.mk</p>
<p>Android.mk文件用来指定源码编译的配置信息，例如工作目录，编译模块的名称，参与编译的文件等，大致内容如下：</p>
<p>LOCAL_PATH         $call mydir<br>include              $CLEAR_VARS<br>LOCAL_MODULE       hello_jni<br>LOCAL_SRC_FILES    hello_jnic<br>include              $BUILD_SHARED_LIBRARY<br>LOCAL_PATH：设置工作目录，而my-dir则会返回Android.mk文件所在的目录。<br>CLEAR——VARS：清除几乎所有以LOCAL——PATH开头的变量（不包括LOCAL_PATH）。<br>LOCAL_MODULE：用来设置模块的名称。<br>LOCAL_SRC_FILES：用来指定参与模块编译的C/C++源文件名。<br>BUILD_SHARED_LIBRARY：作用是指定生成的静态库或者共享库在运行时依赖的共享库模块列表。<br>2.2.1.2 创建Application.mk</p>
<p>这个文件用来配置编译平台相关内容，我们最常用的估计只是APP_ABI字段，它用来指定我们需要基于哪些CPU架构的文件，当然你可以配置多个平台：</p>
<p>APP_ABI  armeabi armeabiv7a x86 mips<br>如果不创建Application.mk文件，那么手动编译的文件只有armeabi平台一个版本，其他平台的不会被编译。</p>
<p>假设我们配置好了Android.mk文件，那么接下来我们就可以执行如下命令来生成文件了，我们假设开发NDK的目录为默认目录：</p>
<p> src/main/jni/<br>ndk-build<br>如果顺利，那么你将会看到，在src/main/目录下会多了一个目录，这是使用命令编译文件的生成的默认目录，而AndroidSutdio默认加载的目录是jniLibs，那么你有两种解决方式：</p>
<p>配置build.gradle资源目录，参见文章2.1小节<br>使用 ndk-build NDK_LIBS_OUT=../jniLibs 指定具体的输出目录<br>当你得到了文件，那么接下来就是在文件中调用执行即可，如果想了解更多ndk-build命令内容，可参见：Android ndk-build 使用文档</p>
<p>2.2.2 使用gradle脚本</p>
<p>当然该机器做的事我们还是尽量让机器来做，因此，接下来我打算使用build.gradle来添加一些配置，让Gradle自动帮我完成编译工作，这简直就是爽歪歪啦！</p>
<p>使用gradle,你再也不用手动添加Android.mk和Application.mk文件，一切在build.gradle文件中就都能搞定，在这里我们直接贴出build.gradle中相关的配置：</p>
<pre><code>androidndk 
    // 模块名称
    moduleName  &quot;hello-jni&quot;

    // 指定编译平台，更多平台信息 参见https://developer.android.com/ndk/guides/abis.html#sa
    abiFilters &quot;armeabi&quot; &quot;armeabi-v7a&quot;
    /*
     * Other ndk flags configurable here are
     * cppFlags.add(&quot;-fno-rtti&quot;)
     * cppFlags.add(&quot;-fno-exceptions&quot;)
     * ldLibs.addAll([&quot;android&quot;, &quot;log&quot;])
     * stl       = &quot;system&quot;
     */
</code></pre><p>使用gradle的好处是，自动编译生成文件，并且把相关的文件打包到安装包中，一劳永逸。<br>MeasureMeasure</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在AndroidStudio中进行开发比起以往的Eclipse要方便的多，下面来介绍下如何使用AndroidStudio这个IDE工具实现相关开发工作。</p>
<ol>
<li>准备工作</li>
</ol>
<p>在实际写代码之前，首先我们还是需要做一些准备工作：</p>
<p>下载开发包：Android官方下载页面<br>配置系统环境变量<br>下载好开发包之后，直接解压到任意目录，然后需要配置一下系统环境变量，之所以要配置环境变量，是为了方便使用命令ndk-build脚本进行编译。配置参考如下：</p>
<pre><code># 在.bash_profile中配置如下代码
</code></pre><p>export ANDROID_NDK/Users/liangqi/android-ndk<br>export PATH$ANDROID_NDK$PATH</p>
<pre><code># 然后执行如下代码，更新配置文件
</code></pre><p>source .bash_profile<br>其实编译C/C++代码不一定在AndroidStudio中，如果配置好环境变量，直接使用进入项目中的目录执行ndk-build命令即可在当前目录下生成一个的目录，里面存放了不同 平台的包，当然运行这个命令的前提是，这个目录下至少得有一个Android.mk文件，如果需要指定具体的编译平台，那么还需要添加一个Application.mk文件，当然，如果命令行让你头疼，那么你可以采用gradle的方式来解决这些问题，接下来我们将分别介绍这些使用方式。<br>]]>
    
    </summary>
    
      <category term="RxJava" scheme="http://kevinhero.github.io/tags/RxJava/"/>
    
      <category term="技术" scheme="http://kevinhero.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入浅出RxJava(三：响应式的好处)]]></title>
    <link href="http://kevinhero.github.io/2016/04/04/RxJava/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BARxJava%E4%B8%89--%E5%93%8D%E5%BA%94%E5%BC%8F%E7%9A%84%E5%A5%BD%E5%A4%84/"/>
    <id>http://kevinhero.github.io/2016/04/04/RxJava/深入浅出RxJava三--响应式的好处/</id>
    <published>2016-04-04T05:12:17.000Z</published>
    <updated>2016-04-10T08:47:22.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p><a href="http://blog.danlew.net/2014/09/30/grokking-rxjava-part-3/" target="_blank" rel="external">英文原文</a> </p>
<p><a href="http://blog.csdn.net/lzyzsd/article/details/44891933" target="_blank" rel="external">译文原文</a></p>
</blockquote>
<p>在第一篇中，我介绍了RxJava的基础知识。第二篇中，我向你展示了操作符的强大。但是你可能仍然没被说服。这篇里面，我讲向你展示RxJava的其他的一些好处，相信这篇足够让你去使用Rxjava.</p>
<p>到目前为止，我们都没怎么介绍onComplete()和onError()函数。这两个函数用来通知订阅者，被观察的对象将停止发送数据以及为什么停止（成功的完成或者出错了）。</p>
<p>下面的代码展示了怎么使用这两个函数：</p>
<p><code>Observable.just(``&quot;Hello, world!&quot;``)</code></p>
<p><code>.map(s -&gt; potentialException(s))</code></p>
<p><code>.map(s -&gt; anotherPotentialException(s))</code></p>
<p><code>.subscribe(``new</code> <code>Subscriber&lt;String&gt;() {        @Override</code></p>
<p><code>public void onNext(String s) { System.out.println(s); }        @Override</code></p>
<p><code>public void onCompleted() { System.out.println(``&quot;Completed!&quot;``); }        @Override</code></p>
<p><code>public void onError(Throwable e) { System.out.println(``&quot;Ouch!&quot;``); }</code></p>
<p><code>});</code><br><a id="more"></a><br>代码中的potentialException() 和 anotherPotentialException()有可能会抛出异常。每一个Observerable对象在终结的时候都会调用 onCompleted()或者onError()方法，所以Demo中会打印”Completed!”或者”Ouch!”。</p>
<p>这种模式有以下几个优点：</p>
<p>1.只要有异常发生onError()一定会被调用</p>
<p>这极大的简化了错误处理。只需要在一个地方处理错误即可以。</p>
<p>2.操作符不需要处理异常</p>
<p>将异常处理交给订阅者来做，Observerable的操作符调用链中一旦有一个抛出了异常，就会直接执行onError()方法。</p>
<p>3.你能够知道什么时候订阅者已经接收了全部的数据。</p>
<p>知道什么时候任务结束能够帮助简化代码的流程。（虽然有可能Observable对象永远不会结束）</p>
<p>我觉得这种错误处理方式比传统的错误处理更简单。传统的错误处理中，通常是在每个回调中处理错误。这不仅导致了重复的代码，并且意味着每个回调都必须知道如何处理错误，你的回调代码将和调用者紧耦合在一起。</p>
<p>使用RxJava，Observable对象根本不需要知道如何处理错误！操作符也不需要处理错误状态-一旦发生错误，就会跳过当前和后续的操作符。所有的错误处理都交给订阅者来做。</p>
<p>假设你编写的Android app需要从网络请求数据（感觉这是必备的了，还有单机么？）。网络请求需要话费较长的时间，因此你打算在另外一个线程中加载数据。为问题来了！</p>
<p>编写多线程的Android应用程序是很难的，因为你必须确保代码在正确的线程中运行，否则的话可能会导致app崩溃。最常见的就是在非主线程更新UI。</p>
<p>使用RxJava，你可以使用subscribeOn()指定观察者代码运行的线程，使用observerOn()指定订阅者运行的线程：</p>
<p><code>myObservableServices.retrieveImage(url)</code></p>
<p><code>.subscribeOn(Schedulers.io())</code></p>
<p><code>.observeOn(AndroidSchedulers.mainThread())</code></p>
<p><code>.subscribe(bitmap -&gt; myImageView.setImageBitmap(bitmap));</code></p>
<p>是不是很简单？任何在我的Subscriber前面执行的代码都是在I/O线程中运行。最后，操作view的代码在主线程中运行.</p>
<p>最棒的是我可以把subscribeOn()和observerOn()添加到任何Observable对象上。这两个也是操作符！。我不需要关心Observable对象以及它上面有哪些操作符。仅仅运用这两个操作符就可以实现在不同的线程中调度。</p>
<p>如果使用AsyncTask或者其他类似的，我将不得不仔细设计我的代码，找出需要并发执行的部分。使用RxJava，我可以保持代码不变，仅仅在需要并发的时候调用这两个操作符就可以。</p>
<h2 id="u8BA2_u9605_uFF08Subscriptions_uFF09"><a href="#u8BA2_u9605_uFF08Subscriptions_uFF09" class="headerlink" title="订阅（Subscriptions）"></a>订阅（Subscriptions）</h2><p>当调用Observable.subscribe()，会返回一个Subscription对象。这个对象代表了被观察者和订阅者之间的联系。</p>
<p><code>ubscription subscription = Observable.just(``&quot;Hello, World!&quot;``)</code></p>
<p><code>.subscribe(s -&gt; System.out.println(s));</code></p>
<p>你可以在后面使用这个Subscription对象来操作被观察者和订阅者之间的联系.</p>
<p><code>subscription.unsubscribe();</code></p>
<p><code>System.out.println(``&quot;Unsubscribed=&quot;</code> <code>+ subscription.isUnsubscribed());</code></p>
<p><code>// Outputs &quot;Unsubscribed=true&quot;</code></p>
<p>RxJava的另外一个好处就是它处理unsubscribing的时候，会停止整个调用链。如果你使用了一串很复杂的操作符，调用unsubscribe将会在他当前执行的地方终止。不需要做任何额外的工作！</p>
<p>记住这个系列仅仅是对RxJava的一个入门介绍。RxJava中有更多的我没介绍的功能等你探索（比如backpressure）。当然我也不是所有的代码都使用响应式的方式–仅仅当代码复杂到我想将它分解成简单的逻辑的时候，我才使用响应式代码。</p>
<p>最初，我的计划是这篇文章作为这个系列的总结，但是我收到许多请求我介绍在Android中使用RxJava，所以你可以继续阅读第四篇了。我希望这个介绍能让你开始使用RxJava。如果你想学到更多，我建议你阅读RxJava的官方wiki。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p><a href="http://blog.danlew.net/2014/09/30/grokking-rxjava-part-3/">英文原文</a> </p>
<p><a href="http://blog.csdn.net/lzyzsd/article/details/44891933">译文原文</a></p>
</blockquote>
<p>在第一篇中，我介绍了RxJava的基础知识。第二篇中，我向你展示了操作符的强大。但是你可能仍然没被说服。这篇里面，我讲向你展示RxJava的其他的一些好处，相信这篇足够让你去使用Rxjava.</p>
<p>到目前为止，我们都没怎么介绍onComplete()和onError()函数。这两个函数用来通知订阅者，被观察的对象将停止发送数据以及为什么停止（成功的完成或者出错了）。</p>
<p>下面的代码展示了怎么使用这两个函数：</p>
<p><code>Observable.just(``&quot;Hello, world!&quot;``)</code></p>
<p><code>.map(s -&gt; potentialException(s))</code></p>
<p><code>.map(s -&gt; anotherPotentialException(s))</code></p>
<p><code>.subscribe(``new</code> <code>Subscriber&lt;String&gt;() {        @Override</code></p>
<p><code>public void onNext(String s) { System.out.println(s); }        @Override</code></p>
<p><code>public void onCompleted() { System.out.println(``&quot;Completed!&quot;``); }        @Override</code></p>
<p><code>public void onError(Throwable e) { System.out.println(``&quot;Ouch!&quot;``); }</code></p>
<p><code>});</code><br>]]>
    
    </summary>
    
      <category term="RxJava" scheme="http://kevinhero.github.io/tags/RxJava/"/>
    
      <category term="技术" scheme="http://kevinhero.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入浅出RxJava(二：操作符)]]></title>
    <link href="http://kevinhero.github.io/2016/04/02/RxJava/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BARxJava(%E4%BA%8C%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%AC%A6)/"/>
    <id>http://kevinhero.github.io/2016/04/02/RxJava/深入浅出RxJava(二：操作符)/</id>
    <published>2016-04-02T15:12:17.000Z</published>
    <updated>2016-04-10T08:45:02.000Z</updated>
    <content type="html"><![CDATA[<p>译文原文 <a href="http://blog.csdn.net/lzyzsd/article/details/44094895" target="_blank" rel="external">http://blog.csdn.net/lzyzsd/article/details/44094895</a> </p>
<p>英文原文 <a href="http://blog.danlew.net/2014/09/22/grokking-rxjava-part-2/" target="_blank" rel="external">Grokking RxJava, Part 2: Operator, Operator</a></p>
<p>在<a href="http://blog.csdn.net/lzyzsd/article/details/41833541" target="_blank" rel="external">第一篇blog</a>中， 我介绍了RxJava的一些基础知识，同时也介绍了map()操作符。当然如果你并没有意愿去使用RxJava我一点都不诧异，毕竟才接触了这么点。看完 这篇blog，我相信你肯定想立即在你的项目中使用RxJava了，这篇blog将介绍许多RxJava中的操作符，RxJava的强大性就来自于它所定 义的操作符。</p>
<p>首先先看一个例子：</p>
<p>假设我有这样一个方法：<br>这个方法根据输入的字符串返回一个网站的url列表（啊哈，搜索引擎）</p>
<p><code>Observable&lt;List&lt;String&gt;&gt; query(String text);</code></p>
<p>现在我希望构建一个健壮系统，它可以查询字符串并且显示结果。根据上一篇blog的内容，我们可能会写出下面的代码：</p>
<p><code>query(``&quot;Hello, world!&quot;``)</code><br><code>.subscribe(urls -&gt; {</code><br><code>for</code> <code>(String url : urls) {</code><br><code>System.out.println(url);</code><br><code>}</code><br><code>});</code><br><a id="more"></a><br>这种代码当然是不能容忍的，因为上面的代码使我们丧失了变化数据流的能力。一旦我们想要更改每一个URL，只能在Subscriber中来做。我们竟然没有使用如此酷的map()操作符！！！</p>
<p>当然，我可以使用map操作符，map的输入是urls列表，处理的时候还是要for each遍历，一样很蛋疼。</p>
<p>万幸，还有Observable.from()方法，它接收一个集合作为输入，然后每次输出一个元素给subscriber：</p>
<p><code>Observable.from(``&quot;url1&quot;``, ``&quot;url2&quot;``, ``&quot;url3&quot;``)</code></p>
<p><code>.subscribe(url -&gt; System.out.println(url));</code></p>
<p>我们来把这个方法使用到刚才的场景：</p>
<p><code>query(``&quot;Hello, world!&quot;``)</code></p>
<p><code>.subscribe(urls -&gt; {</code></p>
<p><code>Observable.from(urls)</code></p>
<p><code>.subscribe(url -&gt; System.out.println(url));</code></p>
<p><code>});</code></p>
<p>虽然去掉了for each循环，但是代码依然看起来很乱。多个嵌套的subscription不仅看起来很丑，难以修改，更严重的是它会破坏某些我们现在还没有讲到的RxJava的特性。</p>
<p>救星来了,他就是flatMap()。<br>Observable.flatMap()接收一个Observable的输出作为输入，同时输出另外一个Observable。直接看代码：</p>
<p><code>query(``&quot;Hello, world!&quot;``)</code></p>
<p><code>.flatMap(``new</code> <code>Func1&lt;List&lt;String&gt;, Observable&lt;String&gt;&gt;() {</code></p>
<p><code>@Override</code></p>
<p><code>public Observable&lt;String&gt; call(List&lt;String&gt; urls) {</code></p>
<p><code>return</code> <code>Observable.from(urls);</code></p>
<p><code>}</code></p>
<p><code>})</code></p>
<p><code>.subscribe(url -&gt; System.out.println(url));</code></p>
<p>这里我贴出了整个的函数代码，以方便你了解发生了什么，使用lambda可以大大简化代码长度：</p>
<p><code>query(``&quot;Hello, world!&quot;``)</code></p>
<p><code>.flatMap(urls -&gt; Observable.from(urls))</code></p>
<p><code>.subscribe(url -&gt; System.out.println(url));</code></p>
<p>flatMap()是不是看起来很奇怪？为什么它要返回另外一个Observable呢？理解flatMap的关键点在于，flatMap输出的新的 Observable正是我们在Subscriber想要接收的。现在Subscriber不再收到List\<string\>，而是收到一些 列单个的字符串，就像Observable.from()的输出一样。</string\></p>
<p>这部分也是我当初学RxJava的时候最难理解的部分，一旦我突然领悟了，RxJava的很多疑问也就一并解决了。</p>
<h2 id="u8FD8_u53EF_u4EE5_u66F4_u597D"><a href="#u8FD8_u53EF_u4EE5_u66F4_u597D" class="headerlink" title="还可以更好"></a>还可以更好</h2><p>flatMap()实在不能更赞了，它可以返回任何它想返回的Observable对象。<br>比如下面的方法：</p>
<p><code>// 返回网站的标题，如果404了就返回null</code></p>
<p><code>Observable&lt;String&gt; getTitle(String URL);</code></p>
<p>接着前面的例子，现在我不想打印URL了，而是要打印收到的每个网站的标题。问题来了，我的方法每次只能传入一个URL，并且返回值不是一个String，而是一个输出String的Observabl对象。使用flatMap()可以简单的解决这个问题。</p>
<p><code>query(``&quot;Hello, world!&quot;``)</code></p>
<p><code>.flatMap(urls -&gt; Observable.from(urls))</code></p>
<p><code>.flatMap(``new</code> <code>Func1&lt;String, Observable&lt;String&gt;&gt;() {</code></p>
<p><code>@Override</code></p>
<p><code>public Observable&lt;String&gt; call(String url) {</code></p>
<p><code>return</code> <code>getTitle(url);</code></p>
<p><code>}</code></p>
<p><code>})</code></p>
<p><code>.subscribe(title -&gt; System.out.println(title));</code></p>
<p>使用lambda:</p>
<p><code>query(``&quot;Hello, world!&quot;``)</code></p>
<p><code>.flatMap(urls -&gt; Observable.from(urls))</code></p>
<p><code>.flatMap(url -&gt; getTitle(url))</code></p>
<p><code>.subscribe(title -&gt; System.out.println(title));</code></p>
<p>是不是感觉很不可思议？我竟然能将多个独立的返回Observable对象的方法组合在一起！帅呆了！<br>不止这些，我还将两个API的调用组合到一个链式调用中了。我们可以将任意多个API调用链接起来。大家应该都应该知道同步所有的API调用，然后将所有 API调用的回调结果组合成需要展示的数据是一件多么蛋疼的事情。这里我们成功的避免了callback hell（多层嵌套的回调，导致代码难以阅读维护）。现在所有的逻辑都包装成了这种简单的响应式调用。</p>
<h2 id="u4E30_u5BCC_u7684_u64CD_u4F5C_u7B26"><a href="#u4E30_u5BCC_u7684_u64CD_u4F5C_u7B26" class="headerlink" title="丰富的操作符"></a>丰富的操作符</h2><p>目前为止，我们已经接触了两个操作符，RxJava中还有更多的操作符，那么我们如何使用其他的操作符来改进我们的代码呢？<br>getTitle()返回null如果url不存在。我们不想输出”null”，那么我们可以从返回的title列表中过滤掉null值！</p>
<p><code>query(``&quot;Hello, world!&quot;``)</code></p>
<p><code>.flatMap(urls -&gt; Observable.from(urls))</code></p>
<p><code>.flatMap(url -&gt; getTitle(url))</code></p>
<p><code>.filter(title -&gt; title != ``null``)</code></p>
<p><code>.subscribe(title -&gt; System.out.println(title));</code></p>
<p>filter()输出和输入相同的元素，并且会过滤掉那些不满足检查条件的。</p>
<p>如果我们只想要最多5个结果：</p>
<p><code>query(``&quot;Hello, world!&quot;``)</code></p>
<p><code>.flatMap(urls -&gt; Observable.from(urls))</code></p>
<p><code>.flatMap(url -&gt; getTitle(url))</code></p>
<p><code>.filter(title -&gt; title != ``null``)</code></p>
<p><code>.take(5)</code></p>
<p><code>.subscribe(title -&gt; System.out.println(title));</code></p>
<p>take()输出最多指定数量的结果。</p>
<p>如果我们想在打印之前，把每个标题保存到磁盘：</p>
<p><code>query(``&quot;Hello, world!&quot;``)</code></p>
<p><code>.flatMap(urls -&gt; Observable.from(urls))</code></p>
<p><code>.flatMap(url -&gt; getTitle(url))</code></p>
<p><code>.filter(title -&gt; title != ``null``)</code></p>
<p><code>.take(5)</code></p>
<p><code>.doOnNext(title -&gt; saveTitle(title))</code></p>
<p><code>.subscribe(title -&gt; System.out.println(title));</code></p>
<p>doOnNext()允许我们在每次输出一个元素之前做一些额外的事情，比如这里的保存标题。</p>
<p>看到这里操作数据流是多么简单了么。你可以添加任意多的操作，并且不会搞乱你的代码。</p>
<p>RxJava包含了大量的操作符。操作符的数量是有点吓人，但是很值得你去挨个看一下，这样你可以知道有哪些操作符可以使用。弄懂这些操作符可能会花一些时间，但是一旦弄懂了，你就完全掌握了RxJava的威力。</p>
<p>你甚至可以编写自定义的操作符！这篇blog不打算将自定义操作符，如果你想的话，清自行Google吧。</p>
<h2 id="u611F_u89C9_u5982_u4F55_uFF1F"><a href="#u611F_u89C9_u5982_u4F55_uFF1F" class="headerlink" title="感觉如何？"></a>感觉如何？</h2><p>好吧，你是一个怀疑主义者，并且还很难被说服，那为什么你要关心这些操作符呢？</p>
<p>因为操作符可以让你对数据流做任何操作。</p>
<p>将一系列的操作符链接起来就可以完成复杂的逻辑。代码被分解成一系列可以组合的片段。这就是响应式函数编程的魅力。用的越多，就会越多的改变你的编程思维。</p>
<p>另外，RxJava也使我们处理数据的方式变得更简单。在最后一个例子里，我们调用了两个API，对API返回的数据进行了处理，然后保存到磁盘。 但是我们的Subscriber并不知道这些，它只是认为自己在接收一个Observable\<string\>对象。良好的封装性也带来了编 码的便利！</string\></p>
<p>在第三部分中，我将介绍RxJava的另外一些很酷的特性，比如错误处理和并发，这些特性并不会直接用来处理数据。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>译文原文 <a href="http://blog.csdn.net/lzyzsd/article/details/44094895">http://blog.csdn.net/lzyzsd/article/details/44094895</a> </p>
<p>英文原文 <a href="http://blog.danlew.net/2014/09/22/grokking-rxjava-part-2/">Grokking RxJava, Part 2: Operator, Operator</a></p>
<p>在<a href="http://blog.csdn.net/lzyzsd/article/details/41833541">第一篇blog</a>中， 我介绍了RxJava的一些基础知识，同时也介绍了map()操作符。当然如果你并没有意愿去使用RxJava我一点都不诧异，毕竟才接触了这么点。看完 这篇blog，我相信你肯定想立即在你的项目中使用RxJava了，这篇blog将介绍许多RxJava中的操作符，RxJava的强大性就来自于它所定 义的操作符。</p>
<p>首先先看一个例子：</p>
<p>假设我有这样一个方法：<br>这个方法根据输入的字符串返回一个网站的url列表（啊哈，搜索引擎）</p>
<p><code>Observable&lt;List&lt;String&gt;&gt; query(String text);</code></p>
<p>现在我希望构建一个健壮系统，它可以查询字符串并且显示结果。根据上一篇blog的内容，我们可能会写出下面的代码：</p>
<p><code>query(``&quot;Hello, world!&quot;``)</code><br><code>.subscribe(urls -&gt; {</code><br><code>for</code> <code>(String url : urls) {</code><br><code>System.out.println(url);</code><br><code>}</code><br><code>});</code><br>]]>
    
    </summary>
    
      <category term="RxJava" scheme="http://kevinhero.github.io/tags/RxJava/"/>
    
      <category term="技术" scheme="http://kevinhero.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Q2季度目标]]></title>
    <link href="http://kevinhero.github.io/2016/04/01/%E9%9A%8F%E7%AC%94/Q2%E5%AD%A3%E5%BA%A6%E7%9B%AE%E6%A0%87/"/>
    <id>http://kevinhero.github.io/2016/04/01/随笔/Q2季度目标/</id>
    <published>2016-04-01T03:33:45.000Z</published>
    <updated>2016-04-06T10:49:36.000Z</updated>
    <content type="html"><![CDATA[<p>1、完成GankAPP，并上线</p>
<pre><code>未完成的部分
1、上啦下拉更新 
2、替换历史上今天的API
3、优化webview的显示
4、优化代码结构（网络请求**）
</code></pre>   <a id="more"></a>
<p>2、阅读《深入理解Android卷I》 并写下不少于10篇的技术读后感</p>
<p><a href="http://i4.piimg.com/e5dcc5c08841a359.jpg" title="点击显示原始图片" target="_blank" rel="external"><img src="http://i4.piimg.com/e5dcc5c08841a359t.jpg"></a></p>
<p>3、使用RxJava 完成知乎日报客户端，并使用sketch设计原型</p>
<p>4、攒钱攒钱攒钱 </p>
<p><img src="http://i.gtimg.cn/open/app_icon/04/72/41/14/1104724114_p1.png" width="300"></p>
<p>5、戒烟!戒烟!戒烟!</p>
<p><img src="https://d24.usercdn.com/i/04036/7yqf33h4fw6q.jpeg" width="300"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>1、完成GankAPP，并上线</p>
<pre><code>未完成的部分
1、上啦下拉更新 
2、替换历史上今天的API
3、优化webview的显示
4、优化代码结构（网络请求**）
</code></pre>]]>
    
    </summary>
    
      <category term="目标" scheme="http://kevinhero.github.io/tags/%E7%9B%AE%E6%A0%87/"/>
    
      <category term="随笔" scheme="http://kevinhero.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入浅出RxJava(一：基础篇)]]></title>
    <link href="http://kevinhero.github.io/2016/03/29/RxJava/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BARxJava%EF%BC%88%E4%B8%80%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89/"/>
    <id>http://kevinhero.github.io/2016/03/29/RxJava/深入浅出RxJava（一：基础篇）/</id>
    <published>2016-03-29T13:12:17.000Z</published>
    <updated>2016-04-10T08:47:16.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://blog.danlew.net/2014/09/15/grokking-rxjava-part-1/" target="_blank" rel="external">英文原文</a> </p>
<p><a href="http://blog.csdn.net/lzyzsd/article/details/41833541" target="_blank" rel="external">译文原文</a> </p>
<p><a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="external">RxJava</a>正在Android开发者中变的越来越流行。唯一的问题就是上手不容易，尤其是大部分人之前都是使用命令式编程语言。但是一旦你弄明白了，你就会发现RxJava真是太棒了。<br>这里仅仅是帮助你了解RxJava，整个系列共有四篇文章，希望你看完这四篇文章之后能够了解RxJava背后的思想，并且喜欢上RxJava。</p>
<p>RxJava最核心的两个东西是Observables（被观察者，事件源）和 Subscribers（观察者）。Observables发出一系列事件，Subscribers处理这些事件。这里的事件可以是任何你感兴趣的东西 （触摸事件，web接口调用返回的数据。。。）</p>
<p>一个Observable可以发出零个或者多个事件，知道结束或者出错。每发出一个事件，就会调用它的Subscriber的onNext方法，最后调用Subscriber.onNext()或者Subscriber.onError()结束。</p>
<p>Rxjava的看起来很想设计模式中的观察者模式，但是有一点明显不同，那就是如果一个Observerble没有任何的的Subscriber，那么这个Observable是不会发出任何事件的。</p>
<h1 id="Hello_World"><a href="#Hello_World" class="headerlink" title="Hello World"></a>Hello World</h1><a id="more"></a>
<p>创建一个Observable对象很简单，直接调用Observable.create即可</p>
<p><code>Observable&lt;String&gt; myObservable = Observable.create(</code></p>
<p><code>new</code> <code>Observable.OnSubscribe&lt;String&gt;() {</code></p>
<p><code>@Override</code></p>
<p><code>public void call(Subscriber&lt;? ``super</code> <code>String&gt; sub) {</code></p>
<p><code>sub.onNext(``&quot;Hello, world!&quot;``);</code></p>
<p><code>sub.onCompleted();</code></p>
<p><code>}</code></p>
<p><code>}</code></p>
<p><code>);</code></p>
<p>这里定义的Observable对象仅仅发出一个Hello World字符串，然后就结束了。接着我们创建一个Subscriber来处理Observable对象发出的字符串。</p>
<p><code>Subscriber&lt;String&gt; mySubscriber = ``new</code> <code>Subscriber&lt;String&gt;() {</code></p>
<p><code>@Override</code></p>
<p><code>public void onNext(String s) { System.out.println(s); }</code></p>
<p><code>@Override</code></p>
<p><code>public void onCompleted() { }</code></p>
<p><code>@Override</code></p>
<p><code>public void onError(Throwable e) { }</code></p>
<p><code>};</code></p>
<p>这里subscriber仅仅就是打印observable发出的字符串。通过subscribe函数就可以将我们定义的myObservable对象和mySubscriber对象关联起来，这样就完成了subscriber对observable的订阅。</p>
<p><code>myObservable.subscribe(mySubscriber);</code></p>
<p>一旦mySubscriber订阅了myObservable，myObservable就是调用mySubscriber对象的onNext和onComplete方法，mySubscriber就会打印出Hello World！</p>
<h2 id="u66F4_u7B80_u6D01_u7684_u4EE3_u7801"><a href="#u66F4_u7B80_u6D01_u7684_u4EE3_u7801" class="headerlink" title="更简洁的代码"></a>更简洁的代码</h2><p>是不是觉得仅仅为了打印一个hello world要写这么多代码太啰嗦？我这里主要是为了展示RxJava背后的原理而采用了这种比较啰嗦的写法，RxJava其实提供了很多便捷的函数来帮助我们减少代码。</p>
<p>首先来看看如何简化Observable对象的创建过程。RxJava内置了很多简化创建Observable对象的函数，比如 Observable.just就是用来创建只发出一个事件就结束的Observable对象，上面创建Observable对象的代码可以简化为一行</p>
<p><code>Observable&lt;String&gt; myObservable = Observable.just(``&quot;Hello, world!&quot;``);</code></p>
<p>接下来看看如何简化Subscriber，上面的例子中，我们其实并不关心OnComplete和OnError，我们只需要在onNext的时候做一些处理，这时候就可以使用Action1类。</p>
<p><code>Action1&lt;String&gt; onNextAction = ``new</code> <code>Action1&lt;String&gt;() {</code></p>
<p><code>@Override</code></p>
<p><code>public void call(String s) {</code></p>
<p><code>System.out.println(s);</code></p>
<p><code>}</code></p>
<p><code>};</code></p>
<p>subscribe方法有一个重载版本，接受三个Action1类型的参数，分别对应OnNext，OnComplete， OnError函数。</p>
<p><code>myObservable.subscribe(onNextAction, onErrorAction, onCompleteAction);</code></p>
<p>这里我们并不关心onError和onComplete，所以只需要第一个参数就可以</p>
<p><code>myObservable.subscribe(onNextAction);</code></p>
<p><code>// Outputs &quot;Hello, world!&quot;</code></p>
<p>上面的代码最终可以写成这样</p>
<p><code>Observable.just(``&quot;Hello, world!&quot;``)</code></p>
<p><code>.subscribe(``new</code> <code>Action1&lt;String&gt;() {</code></p>
<p><code>@Override</code></p>
<p><code>public void call(String s) {</code></p>
<p><code>System.out.println(s);</code></p>
<p><code>}</code></p>
<p><code>});</code></p>
<p>使用java8的lambda可以使代码更简洁</p>
<p><code>Observable.just(``&quot;Hello, world!&quot;``)</code></p>
<p><code>.subscribe(s -&gt; System.out.println(s));</code></p>
<p>Android开发中，强烈推荐使用<a href="https://github.com/evant/gradle-retrolambda" target="_blank" rel="external">retrolambda</a>这个gradle插件，这样你就可以在你的代码中使用lambda了。</p>
<p>让我们做一些更有趣的事情吧！<br>比如我想在hello world中加上我的签名，你可能会想到去修改Observable对象：</p>
<p><code>Observable.just(``&quot;Hello, world! -Dan&quot;``)</code></p>
<p><code>.subscribe(s -&gt; System.out.println(s));</code></p>
<p>如果你能够改变Observable对象，这当然是可以的，但是如果你不能修改Observable对象呢？比如Observable对象是第三方库提供的？比如我的Observable对象被多个Subscriber订阅，但是我只想在对某个订阅者做修改呢？<br>那么在Subscriber中对事件进行修改怎么样呢？比如下面的代码：</p>
<p><code>Observable.just(``&quot;Hello, world!&quot;``)</code></p>
<p><code>.subscribe(s -&gt; System.out.println(s + ``&quot; -Dan&quot;``));</code></p>
<p>这种方式仍然不能让人满意，因为我希望我的Subscribers越轻量越好，因为我有可能会在mainThread中运行subscriber。另外， 根据响应式函数编程的概念，Subscribers更应该做的事情是“响应”，响应Observable发出的事件，而不是去修改。如果我能在某些中间步 骤中对“Hello World！”进行变换是不是很酷？</p>
<h2 id="u64CD_u4F5C_u7B26_uFF08Operators_uFF09"><a href="#u64CD_u4F5C_u7B26_uFF08Operators_uFF09" class="headerlink" title="操作符（Operators）"></a>操作符（Operators）</h2><p>操作符就是为了解决对Observable对象的变换的问题，操作符用于在Observable和最终的Subscriber之间修改Observable发出的事件。RxJava提供了很多很有用的操作符。<br>比如map操作符，就是用来把把一个事件转换为另一个事件的。</p>
<p><code>Observable.just(``&quot;Hello, world!&quot;``)</code></p>
<p><code>.map(``new</code> <code>Func1&lt;String, String&gt;() {</code></p>
<p><code>@Override</code></p>
<p><code>public String call(String s) {</code></p>
<p><code>return</code> <code>s + ``&quot; -Dan&quot;``;</code></p>
<p><code>}</code></p>
<p><code>})</code></p>
<p><code>.subscribe(s -&gt; System.out.println(s));</code></p>
<p>使用lambda可以简化为</p>
<p><code>Observable.just(``&quot;Hello, world!&quot;``)</code></p>
<p><code>.map(s -&gt; s + ``&quot; -Dan&quot;``)</code></p>
<p><code>.subscribe(s -&gt; System.out.println(s));</code></p>
<p>是不是很酷？map()操作符就是用于变换Observable对象的，map操作符返回一个Observable对象，这样就可以实现链式调用，在一个Observable对象上多次使用map操作符，最终将最简洁的数据传递给Subscriber对象。</p>
<h2 id="map_u64CD_u4F5C_u7B26_u8FDB_u9636"><a href="#map_u64CD_u4F5C_u7B26_u8FDB_u9636" class="headerlink" title="map操作符进阶"></a>map操作符进阶</h2><p>map操作符更有趣的一点是它不必返回Observable对象返回的类型，你可以使用map操作符返回一个发出新的数据类型的observable对象。<br>比如上面的例子中，subscriber并不关心返回的字符串，而是想要字符串的hash值</p>
<p><code>Observable.just(``&quot;Hello, world!&quot;``)</code></p>
<p><code>.map(``new</code> <code>Func1&lt;String, Integer&gt;() {</code></p>
<p><code>@Override</code></p>
<p><code>public Integer call(String s) {</code></p>
<p><code>return</code> <code>s.hashCode();</code></p>
<p><code>}</code></p>
<p><code>})</code></p>
<p><code>.subscribe(i -&gt; System.out.println(Integer.toString(i)));</code></p>
<p>很有趣吧？我们初始的Observable返回的是字符串，最终的Subscriber收到的却是Integer，当然使用lambda可以进一步简化代码：</p>
<p><code>Observable.just(``&quot;Hello, world!&quot;``)</code></p>
<p><code>.map(s -&gt; s.hashCode())</code></p>
<p><code>.subscribe(i -&gt; System.out.println(Integer.toString(i)));</code></p>
<p>前面说过，Subscriber做的事情越少越好，我们再增加一个map操作符</p>
<p><code>Observable.just(``&quot;Hello, world!&quot;``)</code></p>
<p><code>.map(s -&gt; s.hashCode())</code></p>
<p><code>.map(i -&gt; Integer.toString(i))</code></p>
<p><code>.subscribe(s -&gt; System.out.println(s));</code></p>
<p>是不是觉得我们的例子太简单，不足以说服你？你需要明白下面的两点:</p>
<p>1.Observable和Subscriber可以做任何事情<br>Observable可以是一个数据库查询，Subscriber用来显示查询结果；Observable可以是屏幕上的点击事件，Subscriber用来响应点击事件；Observable可以是一个网络请求，Subscriber用来显示请求结果。</p>
<p>2.Observable和Subscriber是独立于中间的变换过程的。<br>在Observable和Subscriber中间可以增减任何数量的map。整个系统是高度可组合的，操作数据是一个很简单的过程。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://blog.danlew.net/2014/09/15/grokking-rxjava-part-1/">英文原文</a> </p>
<p><a href="http://blog.csdn.net/lzyzsd/article/details/41833541">译文原文</a> </p>
<p><a href="https://github.com/ReactiveX/RxJava">RxJava</a>正在Android开发者中变的越来越流行。唯一的问题就是上手不容易，尤其是大部分人之前都是使用命令式编程语言。但是一旦你弄明白了，你就会发现RxJava真是太棒了。<br>这里仅仅是帮助你了解RxJava，整个系列共有四篇文章，希望你看完这四篇文章之后能够了解RxJava背后的思想，并且喜欢上RxJava。</p>
<p>RxJava最核心的两个东西是Observables（被观察者，事件源）和 Subscribers（观察者）。Observables发出一系列事件，Subscribers处理这些事件。这里的事件可以是任何你感兴趣的东西 （触摸事件，web接口调用返回的数据。。。）</p>
<p>一个Observable可以发出零个或者多个事件，知道结束或者出错。每发出一个事件，就会调用它的Subscriber的onNext方法，最后调用Subscriber.onNext()或者Subscriber.onError()结束。</p>
<p>Rxjava的看起来很想设计模式中的观察者模式，但是有一点明显不同，那就是如果一个Observerble没有任何的的Subscriber，那么这个Observable是不会发出任何事件的。</p>
<h1 id="Hello_World"><a href="#Hello_World" class="headerlink" title="Hello World"></a>Hello World</h1>]]>
    
    </summary>
    
      <category term="RxJava" scheme="http://kevinhero.github.io/tags/RxJava/"/>
    
      <category term="技术" scheme="http://kevinhero.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[谷歌官方出的一套关于 Android 架构的实例参考]]></title>
    <link href="http://kevinhero.github.io/2016/03/29/%E8%B0%B7%E6%AD%8C%E5%AE%98%E6%96%B9%E5%87%BA%E7%9A%84%E4%B8%80%E5%A5%97%E5%85%B3%E4%BA%8E%20Android%20%E6%9E%B6%E6%9E%84%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8F%82%E8%80%83/"/>
    <id>http://kevinhero.github.io/2016/03/29/谷歌官方出的一套关于 Android 架构的实例参考/</id>
    <published>2016-03-29T05:12:17.000Z</published>
    <updated>2016-04-10T08:44:24.000Z</updated>
    <content type="html"><![CDATA[<p>原文 <a href="https://github.com/googlesamples/android-architecture" target="_blank" rel="external">github.com</a></p>
<p>The Android framework offers a lot of flexibility when it comes to defining how to organize and <em>architect</em> an Android app. This freedom, whilst very valuable, can also result in apps with large classes, inconsistent naming and architectures (or lack of) that can make testing, maintaining and extending difficult.</p>
<p>Android Architecture Blueprints is meant to demonstrate possible ways to help with these common problems. In this project we offer the same application implemented using different architectural concepts and tools.</p>
<p>You can use these samples as a reference or as a starting point for creating your own apps. The focus here is on code structure, architecture, testing and maintainability. However, bear in mind that there are many ways to build apps with these architectures and tools, depending on your priorities, so these shouldn’t be considered canonical examples. The UI is deliberately kept simple.</p>
<p><strong>What does <em>*</em></strong>beta<strong>*</strong> mean?**</p>
<p>We’re still making decisions that could affect all samples so we’re keeping the initial number of variants low before the stable release.</p>
<p><strong>Samples</strong></p>
<p>All projects are released in their own branch. Check each project’s README for more information.<br><a id="more"></a><br>In progress:</p>
<ul>
<li>todo-mvp-contentproviders - Based on todo-mvp-loaders, uses Content Providers</li>
<li>todo-mvp-clean - Based on todo-mvp, uses concepts from Clean Architecture.</li>
<li>todo-mvp-dagger - Based on todo-mvp, uses Dagger2 for Dependency Injection</li>
</ul>
<p>Also, see <a href="https://github.com/googlesamples/android-architecture/issues?q=is%3Aissue+is%3Aopen+label%3A%22New+sample%22" target="_blank" rel="external">“New sample” issues</a> for planned samples.</p>
<p><strong>Why a to-do application?</strong></p>
<p>The aim of the app is to be simple enough that it’s understood quickly, but complex enough to showcase difficult design decisions and testing scenarios. Check out the <a href="https://github.com/googlesamples/android-architecture/wiki/To-do-app-specification" target="_blank" rel="external">app’s specification</a>.</p>
<p><a href="https://github.com/googlesamples/android-architecture/wiki/images/tasks2.png" target="_blank" rel="external"><img src="https://raw.githubusercontent.com/wiki/googlesamples/android-architecture/images/tasks2.png" alt="Screenshot"></a></p>
<p>Also, a similar project exists to compare JavaScript frameworks, called <a href="https://github.com/tastejs/todomvc" target="_blank" rel="external">TodoMVC</a>.</p>
<p><strong>Which sample should I choose for my app?</strong></p>
<p>That’s for you to decide: each sample has a README where you’ll find metrics and subjective assessments. Your mileage may vary depending on the size of the app, the size and experience of your team, the amount of maintenance that you foresee, whether you need a tablet layout or support multiple platforms, how compact you like your codebase, etc.</p>
<p><strong>Who is behind this project?</strong></p>
<p>This project is made by the <a href="https://github.com/googlesamples/android-architecture/graphs/contributors" target="_blank" rel="external">community</a> and curated by Google and core maintainers. Each sample has a group of owners that look after it keeping it up to date and handling issues and pull requests.</p>
<p>Want to be part of it? Read <a href="https://github.com/googlesamples/android-architecture/blob/master/CONTRIBUTING.md" target="_blank" rel="external">how to become a contributor</a> and the <a href="https://github.com/googlesamples/android-architecture/wiki/Contributions" target="_blank" rel="external">contributor’s guide</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文 <a href="https://github.com/googlesamples/android-architecture">github.com</a></p>
<p>The Android framework offers a lot of flexibility when it comes to defining how to organize and <em>architect</em> an Android app. This freedom, whilst very valuable, can also result in apps with large classes, inconsistent naming and architectures (or lack of) that can make testing, maintaining and extending difficult.</p>
<p>Android Architecture Blueprints is meant to demonstrate possible ways to help with these common problems. In this project we offer the same application implemented using different architectural concepts and tools.</p>
<p>You can use these samples as a reference or as a starting point for creating your own apps. The focus here is on code structure, architecture, testing and maintainability. However, bear in mind that there are many ways to build apps with these architectures and tools, depending on your priorities, so these shouldn’t be considered canonical examples. The UI is deliberately kept simple.</p>
<p><strong>What does <em>*</em></strong>beta<strong>*</strong> mean?**</p>
<p>We’re still making decisions that could affect all samples so we’re keeping the initial number of variants low before the stable release.</p>
<p><strong>Samples</strong></p>
<p>All projects are released in their own branch. Check each project’s README for more information.<br>]]>
    
    </summary>
    
      <category term="架构的实例" scheme="http://kevinhero.github.io/tags/%E6%9E%B6%E6%9E%84%E7%9A%84%E5%AE%9E%E4%BE%8B/"/>
    
      <category term="技术" scheme="http://kevinhero.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从案例学习RxAndroid]]></title>
    <link href="http://kevinhero.github.io/2016/03/25/RxJava/RxAndroid/"/>
    <id>http://kevinhero.github.io/2016/03/25/RxJava/RxAndroid/</id>
    <published>2016-03-25T13:01:45.000Z</published>
    <updated>2016-04-07T03:37:12.000Z</updated>
    <content type="html"><![CDATA[<p><a herf="https://medium.com/@kurtisnusbaum/rxandroid-basics-part-1-c0d5edcf6850">原文链接</a></p>
<p>如果你在阅读这篇文章，相信你一定很想了解RxJava以及如何在Android应用中使用它。可能你已经见过RxJava的代码了，但仍然有些疑惑，愿你能在这篇文章里找到答案。</p>
<p>当我第一次使用RxJava的时候我只是在照搬代码，这些代码能跑起来，但是我对RxJava的基础部分仍然存在误解，而且我找不到好的源码来学习。所以为了理解RxJava，我不得不一点一点学习，踩了不少坑。</p>
<p>为了不让你把我踩过的坑再踩一遍，我会基于我的学习成果写一些例子出来，目的就是让你能够对RxJava有足够的了解，并能在你的Android应用中使用它。</p>
<p>源码可以在这里找到。在每个例子的开始，我会写清每个代码段是属于哪个Activity的。我会将本文分为两个部分，在前三个例子里，我会着重讲解如何用RxJava异步加载数据；在后三个例子里，我会探索一些更高级的用法。</p>
<p>在开始说代码之前，先澄清几个概念。RxJava最核心的东西就是Observable和Observer。Observable会发出数据，而与之相对的Observer则会通过订阅Observable来进行观察。</p>
<p>Observer可以在Observable发出数据、报错或者声明没有数据可以发送时进行相应的操作。这三个操作被封装在Observer接口中，相应的方法为onNext()，onError()和onCompleted()。</p>
<p>明确了这些概念以后，让我们来看一些例子。<br><a id="more"></a><br>案例1：基础</p>
<p>现在要写一个用来展示一个颜色列表的Activity。我们要写一个能发送一个字符串列表、然后结束的Observeable。而后我们会通过这个字符串列表来填充颜色列表，这里要使用到Observable.just()方法。由这个方法创建的Observable对象的特点是：所有Observer一旦订阅这个Observable就会立即调用onNext()方法并传入Observable.just()的参数，而后因为Observable没有数据可以发送了，onComplete()方法会被调用。</p>
<p>Observable<list<string>&gt; listObservable = Observable.just(getColorList());</list<string></p>
<p>注意这里的getColorList()是一个不耗时的方法。虽然现在看来这个方法无足轻重，但一会我们会回到这个方法。</p>
<p>下一步，我们写一个Observer来观察Observable。</p>
<p>listObservable.subscribe(new Observer<list<string>&gt;() {</list<string></p>
<pre><code>@Override
public void onCompleted() { }

@Override
public void onError(Throwable e) { }

@Override
public void onNext(List&lt;String&gt; colors) {
    mSimpleStringAdapter.setStrings(colors);
}
</code></pre><p>});</p>
<p>而后神奇的事情就发生了。如我刚才所说，一旦通过subscribe()方法订阅Observable，就会发生一系列事情：</p>
<ul>
<li><p>onNext()方法被调用，被发送的颜色列表会作为参数传入。</p>
</li>
<li><p>既然不再有数据可以发送（我们在Observable.just()中只让Observable发送一个数据），onComplete()方法会被调用。</p>
</li>
</ul>
<p>请记住：通过Observable被订阅后的行为来区分它们。</p>
<p>在这个例子中我们不关心Observable何时完成数据的传输，所以我们不用在onComplete()方法里写代码。而且在这里不会有异常抛出，所以我们也不用管onError()方法。</p>
<p>写了这么多你可能觉得很多余，毕竟我们本可以在adapter中直接设置作为数据源的颜色列表。请带着这个疑问，和我看下面这个更有趣一些的例子。</p>
<p>案例2：异步加载</p>
<p>在这里我们要写一个显示电视剧列表的Activity。在Android中RxJava的主要用途就在于异步数据加载。首先让我们写一个Observable：</p>
<p>Observable<list<string>&gt; tvShowObservable = Observable.fromCallable(new Callable<list<string>&gt;() {</list<string></list<string></p>
<pre><code>@Override
public List&lt;String&gt; call() {
    return mRestClient.getFavoriteTvShows();
}
</code></pre><p>});</p>
<p>在刚才的例子中，我们使用Observable.just()来创建Observable，你可能认为在这里可以通过Observable.just(mRestClient.getFavoriteTvShows())来创建Observable。</p>
<p>但在这里我们不能这么做，因为mRestClient.getFavoriteTvShows()会发起网络请求。如果在这里我们使用Observable.just()，mRestClient.getFavoriteTvShows()会被立即执行并阻塞UI线程。</p>
<p>使用Observable.fromCallable()方法有两点好处：</p>
<ul>
<li><p>获取要发送的数据的代码只会在有Observer订阅之后执行。</p>
</li>
<li><p>获取数据的代码可以在子线程中执行。</p>
</li>
</ul>
<p>这两点好处有时可能非常重要。现在让我们订阅这个Observable。</p>
<p>mTvShowSubscription = tvShowObservable<br>    .subscribeOn(Schedulers.io())<br>    .observeOn(AndroidSchedulers.mainThread())<br>    .subscribe(new Observer<list<string>&gt;() {</list<string></p>
<pre><code>    @Override
    public void onCompleted() { }

    @Override
    public void onError(Throwable e) { }

    @Override
    public void onNext(List&lt;String&gt; tvShows){
        displayTvShows(tvShows);
    }
});
</code></pre><p>让我们一个方法一个方法地来看这段代码。subscribeOn会修改我们刚刚创建的Observable。在默认情况下Observable的所有代码，包括刚才说到的只有在被订阅之后才会执行的代码，都会在执行subscribe()方法的线程中运行。而通过subscribeOn()方法，这些代码可以在其他线程中执行。但具体是哪个线程呢？</p>
<p>在这个例子中我们让代码在”IO Scheduler”中执行（Schedulers.io()）。现在我们可以只把Scheduler当做一个可以工作的子线程，这个描述对于现在的我们已经足够了，不过这其中还有更深层次的内容。</p>
<p>不过我们的确遇到了一个小障碍。既然Observable会在IO Scheduler中运行，那么它与Observer的连接也会在IO Scheduler中完成。这就意味着Observer的onNext()方法也会在IO Scheduler中运行，而onNext()方法会操作UI中的View，但View只能在UI主线程中操作。</p>
<p>事实上解决这个问题也很简单，我们可以告诉RxJava我们要在UI线程中观察这个Observable，也就是，我们想让onNext()方法在UI线程中执行。这一点我们可以通过在observeOn()方法中指定另一个Scheduler来完成，在这里也就是AndroidSchedules.mainThread()所返回的Scheduler(UI线程的Scheduler)。</p>
<p>而后我们调用subscribe()方法。这个方法最重要，因为Callable只会在有Observer订阅后运行。还记得刚才我说Observable通过其被订阅后的行为来区分吗？这就是一个很好的例子。</p>
<p>还有最后一件事。这个mTvShowSubscription到底是什么？每当Observer订阅Observable时就会生成一个Subscription对象。一个Subscription代表了一个Observer与Observable之间的连接。有时我们需要操作这个连接，这里拿在Activity的onDestroy()方法中的代码举个例子：</p>
<p>if (mTvShowSubscription != null &amp;&amp; !mTvShowSubscription.isUnsubscribed()) {<br>    mTvShowSubscription.unsubscribe();<br>}</p>
<p>如果你与多线程打过交道，你肯定会意识到一个大坑：当Activity执行onDestroy()后线程才结束（甚至永不结束）的话，就有可能发生内存泄漏与NullPointerException空指针异常。</p>
<p>Subscription就可以解决这个问题，我们可以通过调用unsubscribe()方法告诉Observable它所发送的数据不再被Observer所接收。在调用unsubscribe()方法后，我们创建的Observer就不再会收到数据了，同时也就解决了刚才说的问题。</p>
<p>说到这里难点已经过去，让我们来总结一下：</p>
<ul>
<li><p>Observable.fromCallable()方法可以拖延Observable获取数据的操作，这一点在数据需要在其他线程获取时尤其重要。</p>
</li>
<li><p>subscribeOn()让我们在指定线程中运行获取数据的代码，只要不是UI线程就行。</p>
</li>
<li><p>observeOn()让我们在合适的线程中接收Observable发送的数据，在这里是UI主线程。</p>
</li>
<li><p>记住要让Observer取消订阅以免Observable异步加载数据时发生意外。</p>
</li>
</ul>
<p>案例3：使用Single</p>
<p>这次我们还是写一个展示电视剧列表的Activity，但这次我们走一种更简单的风格。Observable挺好用的，但在某些情况下过于重量级。比如说，你可能一经发现在过去的两个方法中我们只是让Observable发送一个数据，而且我们从来也没写过onComplete()回调方法。</p>
<p>其实呢，Observable还有一个精简版，叫做Single。Single几乎和Observable一模一样，但其回调方法不是onComplete()/onNext()/onError()，而是onSuccess()/onError()。</p>
<p>我们现在把刚才写过的Observable用Single重写一遍。首先我们要创建一个Single:</p>
<p>Single<list<string>&gt; tvShowSingle = Single.fromCallable(new Callable<list<string>&gt;() {<br>    @Override<br>    public List<string> call() throws Exception {<br>        mRestClient.getFavoriteTvShows();<br>    }<br>});</string></list<string></list<string></p>
<p>然后订阅一下：</p>
<p>mTvShowSubscription = tvShowSingle<br>    .subscribeOn(Schedulers.io())<br>    .observeOn(AndroidSchedulers.mainThread())<br>    .subscribe(new SingleSubscriber<list<string>&gt;() {</list<string></p>
<pre><code>    @Override
    public void onSuccess(List&lt;String&gt; tvShows) {
        displayTvShows(tvShows);
    }

    @Override
    public void onError(Throwable error) {
        displayErrorMessage();
    }
});
</code></pre><p>这段代码和刚才很像，我们调用subscribeOn()方法以确保getFavoriteTvShows()在子线程中执行。而后我们调用observeOn()以确保Single的数据被发送到UI线程。</p>
<p>但这次我们不再使用Observer，而是使用一个叫SingleSubscriber的类。这个类和Observer非常像，只不过它只有上述两个方法：onSuccess()和onError()。SingleSubscriber之于Single就如Observer之于Observable。</p>
<p>订阅一个Single的同时也会自动创建一个Subscription对象。这里的Subscription和案例2中没有区别，一定要在onDestroy()中解除订阅。</p>
<p>最后一点：在这里我们添加了处理异常的代码，所以如果mRestClient出了问题，onError()就会被调用。建议你亲手写一个案例玩一玩，体验一下有异常时程序是怎么运行的。</p>
<p>案例4：Subjects</p>
<p>现在我们写一个Activity，里面要展示一个数字并有一个自增按钮。在看代码之前，先介绍另一个有关RxJava的概念，Subject。Subject这个对象既是Observable又是Observer，我会把Subject想象成一个管道：从一端把数据注入，结果就会从另一端输出。</p>
<p>Subject有好几类，在这里我们使用最简单的：PublishSubject。使用PublishSubject时，一旦数据从一端注入，结果会立即从另一端输出。</p>
<p>首先我们要写这个管道的输出端。刚才说了Subject也是Observable，也就是说我们可以像观察任何一个Observable一样观察它。这段代码的功能就是观察管道的输出端到底输出了什么。我们在这里写一个很简单的Observer来更新mCounterDisplay控件。</p>
<p>mCounterEmitter = PublishSubject.create();<br>mCounterEmitter.subscribe(new Observer<integer>() {</integer></p>
<pre><code>@Override
public void onCompleted() { }

@Override
public void onError(Throwable e) { }

@Override
public void onNext(Integer integer) {
    mCounterDisplay.setText(String.valueOf(integer));
}
</code></pre><p>});</p>
<p>与前面的几个例子不同，在这个例子中onNext()会被调用多次。每次发送新的数据时，mCounterDisplay都会展示新的数据。但是PublishSubject怎么发送数据呢？让我们看一下mIncrementButton的监听代码。</p>
<p>mIncrementButton.setOnClickListener(new View.OnClickListener() {</p>
<pre><code>@Override
public void onClick(View v) {
    mCounter++;
    mCounterEmitter.onNext(mCounter);
}
</code></pre><p>});</p>
<p>可以看到mIncrementButton在onClick()回调方法中做了两件事情：</p>
<ul>
<li><p>让mCounter变量自增。</p>
</li>
<li><p>调用mCounterEmitter的onNext()方法并传入mCounter。</p>
</li>
</ul>
<p>由于Subject同时也是Observer，所以它也有onNext()方法，因此我们可以通过调用onNext()方法把数据注入管道的输入端，可以理解为同我们在一端中观察自增按钮是否被点击，然后把信息告知管道另一端的Observer。</p>
<p>案例5：Map()</p>
<p>我们现在要写一个只显示一个数字的Activity。这将是一个很简单的Activity，因为我们要在这里使用map方法。如果你接触过函数式编程，你可能对map并不陌生。你可以把map当做一个方法，它接收一个数据，然后输出另一个数据，当然输入输出的两个数据之间是有联系的。</p>
<p>我们先写一个只发送一个数字4的Single对象。</p>
<p>Single.just(4).map(new Func1<integer, string="">() {</integer,></p>
<pre><code>@Override
public String call(Integer integer) {
    return String.valueOf(integer);
}
</code></pre><p>}).subscribe(new SingleSubscriber<string>() {</string></p>
<pre><code>@Override
public void onSuccess(String value) {
    mValueDisplay.setText(value);
}

@Override
public void onError(Throwable error) { }
</code></pre><p>});</p>
<p>我们最终要显示Single所发送的数据，但首先我们需要将这个数据从Integer转为String，而这里的解决方法就是使用map()函数。正如刚才所说，map接收一个数据，进行处理而后输出它，这正是我们需要的。现在Single会发送数字4，我们使用map()方法将其转为String，而后交给Observer去展示它。</p>
<p>这个例子中对于map方法的使用很轻量，不过map可是非常强大的，在下一个例子中你可以看到，map可以被用来执行任意代码，在处理数据方面起到很重要的作用。</p>
<p>案例6：综合使用</p>
<p>现在我们要写一个用来根据名字搜索城市的Activity。在这个Activity中，我们要使用在这两篇文章中所学的所有知识并写一个比较大的例子。同时还要介绍一个新的概念：deboundce。开始。</p>
<p>现在我们要写一个PublishSubject，并能接收用书输入进输入框的数据，而后根据输入获取符合的列表，并展示。</p>
<p>mTextWatchSubscription = mSearchResultsSubject<br>    .debounce(400, TimeUnit.MILLISECONDS)<br>    .observeOn(Schedulers.io())<br>    .map(new Func1<string, list<string="">&gt;() {</string,></p>
<pre><code>    @Override
    public List&lt;String&gt; call(String s) {
        return mRestClient.searchForCity(s);
    }
})
.observeOn(AndroidSchedulers.mainThread())
.subscribe(new Observer&lt;List&lt;String&gt;&gt;() {

    @Override
    public void onCompleted() { }

    @Override
    public void onError(Throwable e) { }

    @Override
    public void onNext(List&lt;String&gt; cities) {
        handleSearchResults(cities);
    }
});
</code></pre><p>mSearchInput.addTextChangedListener(new TextWatcher() {</p>
<pre><code>@Override
public void beforeTextChanged(CharSequence s, int start, int count, int after) { }

@Override
public void onTextChanged(CharSequence s, int start, int before, int count) {
    mSearchResultsSubject.onNext(s.toString());
}

@Override
public void afterTextChanged(Editable s) { }
</code></pre><p>});</p>
<p>这段代码有不少内容，让我们一点一点分析。</p>
<p>首先你会看到debounce()方法。这是啥？有啥用？如果你看一下我们是如何给输入框添加监听器的，你会发现每当输入的内容改变时都会有输入发送到mSearchResultsSubject，不过我们不想让用户每点一个键都向服务器请求一次。我们想等一会，等用户停止输入（代表差不多输完）的时候再请求服务器。</p>
<p>而debounce()方法就是做这个的。这个方法告诉mSearchResultsSubject在没有数据传入达400毫秒时才发送数据。意思就是，仅当用户400ms都没有改变输入内容时，Subject才会发送最新的搜索字符串。这样以来我们就不会进行无意义的网络请求了，UI也不会每输入一个字符都更新。</p>
<p>我们想通过RestClient来访问服务器，而因为RestClient涉及IO操作，我们需要在IO Scheduler中进行这个操作，所以要写observeOn(Schedulers.io())。</p>
<p>好了，现在我们会把搜索字段发送到IO Scheduler中，在这里map就要发挥作用了，我们在map方法中通过关键字获取搜索结果的列表。在map中我们可以调用任意外部方法，在这里使用RestClient获取搜索结果。</p>
<p>因为map方法会在IO Scheduler中运行，而我们又要用其返回值填充View，所以要重新切换到UI线程，所以要写observeOn(AndroidSchedulers.mainThread())。现在搜索结果会被发送到UI线程。要注意两个observeOn()方法的顺序，这一点至关重要。现在我们总结一下数据发送的顺序。</p>
<p>mSearchResultsSubject<br>            |<br>            |<br>            V<br>        debounce<br>          |||<br>          |||<br>          V<br>          map<br>          |<br>          |<br>          V<br>        observer</p>
<p>一个竖杠代表数据在UI线程中发送，三个竖杠代表数据在IO Scheduler中发送。</p>
<p>最终，我们获得搜索结果，并展示给用户。</p>
<p>有关RxJava就说这么多了，希望这篇文章能帮你了解RxJava的基础。强烈建议你自己探索有关RxJava的其他方面。如果你有问题或者只是想说点什么，欢迎在下方留言。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a herf="https://medium.com/@kurtisnusbaum/rxandroid-basics-part-1-c0d5edcf6850">原文链接</a></p>
<p>如果你在阅读这篇文章，相信你一定很想了解RxJava以及如何在Android应用中使用它。可能你已经见过RxJava的代码了，但仍然有些疑惑，愿你能在这篇文章里找到答案。</p>
<p>当我第一次使用RxJava的时候我只是在照搬代码，这些代码能跑起来，但是我对RxJava的基础部分仍然存在误解，而且我找不到好的源码来学习。所以为了理解RxJava，我不得不一点一点学习，踩了不少坑。</p>
<p>为了不让你把我踩过的坑再踩一遍，我会基于我的学习成果写一些例子出来，目的就是让你能够对RxJava有足够的了解，并能在你的Android应用中使用它。</p>
<p>源码可以在这里找到。在每个例子的开始，我会写清每个代码段是属于哪个Activity的。我会将本文分为两个部分，在前三个例子里，我会着重讲解如何用RxJava异步加载数据；在后三个例子里，我会探索一些更高级的用法。</p>
<p>在开始说代码之前，先澄清几个概念。RxJava最核心的东西就是Observable和Observer。Observable会发出数据，而与之相对的Observer则会通过订阅Observable来进行观察。</p>
<p>Observer可以在Observable发出数据、报错或者声明没有数据可以发送时进行相应的操作。这三个操作被封装在Observer接口中，相应的方法为onNext()，onError()和onCompleted()。</p>
<p>明确了这些概念以后，让我们来看一些例子。<br>]]>
    
    </summary>
    
      <category term="RxAndroid" scheme="http://kevinhero.github.io/tags/RxAndroid/"/>
    
      <category term="技术" scheme="http://kevinhero.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android开发代码片段]]></title>
    <link href="http://kevinhero.github.io/2016/03/21/%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/android%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/"/>
    <id>http://kevinhero.github.io/2016/03/21/小知识点/android代码片段/</id>
    <published>2016-03-21T12:33:02.000Z</published>
    <updated>2016-04-06T04:04:15.000Z</updated>
    <content type="html"><![CDATA[<h3 id="1_u3001_u83B7_u53D6_u7535_u6E90_u9501"><a href="#1_u3001_u83B7_u53D6_u7535_u6E90_u9501" class="headerlink" title="1、获取电源锁"></a>1、获取电源锁</h3><pre><code>public static void acquireWakeLock() {
    unlockKeyBoard();
    try {
        if (null == mWakeLock) {
            PowerManager pm = (PowerManager) BaseApplication.getInstance()
                    .getSystemService(Context.POWER_SERVICE);
            try {
                mWakeLock = pm.newWakeLock(PowerManager.FULL_WAKE_LOCK
                        | PowerManager.ACQUIRE_CAUSES_WAKEUP
                        | PowerManager.ON_AFTER_RELEASE, &quot;PushMessageReceiver&quot;); // |
                                                                                    // PowerManager.ON_AFTER_RELEASE
            } catch (Exception e) {
                DbUtils.exceptionHandler(e);
            }
        }
        if (null != mWakeLock) {
            mWakeLock.acquire();
        }
    } catch (Exception e) {
        DbUtils.exceptionHandler(e);
    }
}
</code></pre><a id="more"></a>
<h3 id="2_u3001_u91CA_u653E_u8BBE_u5907_u7535_u6E90_u9501"><a href="#2_u3001_u91CA_u653E_u8BBE_u5907_u7535_u6E90_u9501" class="headerlink" title="2、释放设备电源锁"></a>2、释放设备电源锁</h3><pre><code>public static void releaseWakeLock() {
    try {
        if (null != mWakeLock) {
            mWakeLock.release();
            mWakeLock = null;
        }
    } catch (Exception e) {
        DbUtils.exceptionHandler(e);
    }
}
</code></pre><h3 id="3_u3001_u89E3_u9501_u952E_u76D8"><a href="#3_u3001_u89E3_u9501_u952E_u76D8" class="headerlink" title="3、解锁键盘"></a>3、解锁键盘</h3><pre><code>public static void unlockKeyBoard () {
    KeyguardManager km = (KeyguardManager)ApplicationContext.getInstance().getContext().getSystemService(Context.KEYGUARD_SERVICE);
    km.newKeyguardLock(&quot;Tag For Debug&quot;).disableKeyguard();
}
</code></pre><p>4、获取当前程序版本名</p>
<pre><code>/**  
* 返回当前程序版本名  
*/    
public static String getAppVersionName(Context context) {    
    String versionName = &quot;&quot;;    
    try {    
        // ---get the package info---    
        PackageManager pm = context.getPackageManager();    

        PackageInfo pi = pm.getPackageInfo(context.getPackageName(), 0);    
        versionName = pi.versionName;    //版本名称
        versioncode = pi.versionCode;  //版本号
        if (versionName == null || versionName.length() &lt;= 0) {    
            return &quot;&quot;;    
        }    
    } catch (Exception e) {    
        Log.e(&quot;VersionInfo&quot;, &quot;Exception&quot;, e);    
    }    
    return versionName;    
} 
</code></pre><h3 id="5_u3001_u83B7_u53D6_u5F53_u524D_u5E94_u7528_u7684_u7248_u672C_u53F7"><a href="#5_u3001_u83B7_u53D6_u5F53_u524D_u5E94_u7528_u7684_u7248_u672C_u53F7" class="headerlink" title="5、获取当前应用的版本号"></a>5、获取当前应用的版本号</h3><pre><code>public static String getVersionName() throws Exception  
{  
        // 获取packagemanager的实例  
        PackageManager packageManager = getPackageManager();  
        // getPackageName()是你当前类的包名，0代表是获取版本信息  
        PackageInfo packInfo = packageManager.getPackageInfo(getPackageName(),0);  
        String version = packInfo.versionName;  
        return version;  
}
</code></pre><h3 id="6_u3001_u83B7_u53D6_u5F53_u524D_u7CFB_u7EDF_u7684_u7248_u672C_u53F7"><a href="#6_u3001_u83B7_u53D6_u5F53_u524D_u7CFB_u7EDF_u7684_u7248_u672C_u53F7" class="headerlink" title="6、获取当前系统的版本号"></a>6、获取当前系统的版本号</h3><pre><code>/** 
 * 手机系统版本 
 */  
 public static String getSdkVersion() {  
     return android.os.Build.VERSION.RELEASE;  
 }  
</code></pre><h3 id="7_u3001_u5F53_u6211_u4EEC_u70B9_u51FB_u67D0_u4E2A_u8BDD_u9898_u7684_u9009_u9879_u5361_uFF0C_u4F1A_u5F39_u51FA_u4E00_u4E2Apopupwindow_uFF0C_u91CC_u9762_u6709_u8BF8_u5982__u8BC4_u8BBA_u3001_u56DE_u590D_u7684_u9009_u9879_uFF0C_u4F60_u70B9_u51FB_u8FD9_u4E2A_u9009_u9879_u7684_u65F6_u5019_uFF0C_u9700_u8981_u5B9A_u4F4D_u5230EditText_u7F16_u8F91_u6846_uFF0C_u5E76_u4E14_u81EA_u52A8_u5F39_u51FA_u8F93_u5165_u6CD5_u3002_u53EF_u4EE5_u8003_u8651_u5982_u4E0B_u65B9_u6CD5_uFF1A"><a href="#7_u3001_u5F53_u6211_u4EEC_u70B9_u51FB_u67D0_u4E2A_u8BDD_u9898_u7684_u9009_u9879_u5361_uFF0C_u4F1A_u5F39_u51FA_u4E00_u4E2Apopupwindow_uFF0C_u91CC_u9762_u6709_u8BF8_u5982__u8BC4_u8BBA_u3001_u56DE_u590D_u7684_u9009_u9879_uFF0C_u4F60_u70B9_u51FB_u8FD9_u4E2A_u9009_u9879_u7684_u65F6_u5019_uFF0C_u9700_u8981_u5B9A_u4F4D_u5230EditText_u7F16_u8F91_u6846_uFF0C_u5E76_u4E14_u81EA_u52A8_u5F39_u51FA_u8F93_u5165_u6CD5_u3002_u53EF_u4EE5_u8003_u8651_u5982_u4E0B_u65B9_u6CD5_uFF1A" class="headerlink" title="7、当我们点击某个话题的选项卡，会弹出一个popupwindow，里面有诸如 评论、回复的选项，你点击这个选项的时候，需要定位到EditText编辑框，并且自动弹出输入法。可以考虑如下方法："></a>7、当我们点击某个话题的选项卡，会弹出一个popupwindow，里面有诸如 评论、回复的选项，你点击这个选项的时候，需要定位到EditText编辑框，并且自动弹出输入法。可以考虑如下方法：</h3><pre><code>// 获取编辑框焦点
editText.setFocusable(true);
//打开软键盘
InputMethodManager imm = (InputMethodManager) ctx
.getSystemService(Context.INPUT_METHOD_SERVICE);
imm.toggleSoftInput(0, InputMethodManager.HIDE_NOT_ALWAYS);

//关闭软键盘
imm.hideSoftInputFromWindow(editText.getWindowToken(), 0);
</code></pre><h3 id="8_u3001EditText_u8F6F_u952E_u76D8"><a href="#8_u3001EditText_u8F6F_u952E_u76D8" class="headerlink" title="8、EditText软键盘"></a>8、EditText软键盘</h3><pre><code>//打开软键盘
et_feedback_content.setFocusable(true);
getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_VISIBLE);
//关闭软键盘
((InputMethodManager)getSystemService(Context.INPUT_METHOD_SERVICE)).hideSoftInputFromWindow(input.getWindowToken(), 0); 
</code></pre><h3 id="9_u3001_u8BBE_u7F6E_u5168_u5C4F_u7684Dialog"><a href="#9_u3001_u8BBE_u7F6E_u5168_u5C4F_u7684Dialog" class="headerlink" title="9、设置全屏的Dialog"></a>9、设置全屏的Dialog</h3><pre><code>//在代码里设置Dialog的Theme
Dialog dialog = new Dialog(this, R.style.Dialog_Fullscreen);  
dialog.setContentView(R.layout.main);  
dialog.show(); 

//设置style
 &lt;style name=&quot;Dialog_Fullscreen&quot;&gt; 
   &lt;item name=&quot;android:windowFullscreen&quot;&gt;true&lt;/item&gt; 
   &lt;item name=&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt;  
&lt;/style&gt;   
</code></pre><h3 id="10_u3001_u8BBE_u7F6E_u5168_u5C4F_u7684Dialog_uFF08_u4E8C_uFF09"><a href="#10_u3001_u8BBE_u7F6E_u5168_u5C4F_u7684Dialog_uFF08_u4E8C_uFF09" class="headerlink" title="10、设置全屏的Dialog（二）"></a>10、设置全屏的Dialog（二）</h3><p>我们也可以自定义Dialog，首先继承Dialig，然后再构造函数中添加</p>
<pre><code>super(context, android.R.style.Theme); 
setOwnerActivity((Activity)context);  
</code></pre><h3 id="11_u3001_u8BBE_u7F6E_u5168_u5C4FDialog_uFF08_u4E09_uFF09"><a href="#11_u3001_u8BBE_u7F6E_u5168_u5C4FDialog_uFF08_u4E09_uFF09" class="headerlink" title="11、设置全屏Dialog（三）"></a>11、设置全屏Dialog（三）</h3><p>首先介绍一个方法：getDecorView()</p>
<p>decorView是window中的最顶层view，可以从window中获取到decorView，然后decorView有个getWindowVisibleDisplayFrame方法可以获取到程序显示的区域，包括标题栏，但不包括状态栏。 于是，我们就可以算出状态栏的高度了。</p>
<pre><code>Rect frame = new Rect();
getWindow().getDecorView().getWindowVisibleDisplayFrame(frame);
int statusBarHeight = frame.top;
</code></pre><p>同样我们获取标题栏的高度</p>
<pre><code>getWindow().findViewById(Window.ID_ANDROID_CONTENT)这个方法获取到的view就是程序不包括标题栏的部分，然后就可以知道标题栏的高度了，代码如下：
int contentTop = getWindow().findViewById(Window.ID_ANDROID_CONTENT).getTop();         
int titleBarHeight = contentTop - statusBarHeight; //statusBarHeight是上面所求的状态栏的高度
</code></pre><p>最后：知道上述原理，我们就可以设置我们的Dialog和activity一样大了，Java代码如下：</p>
<pre><code>final Dialog dialog = new Dialog(WenDetailActivity.this, R.style.popupDialog);
        dialog.requestWindowFeature(Window.FEATURE_NO_TITLE);
        dialog.setContentView(R.layout.wen_cover_pager);
        dialog.setCanceledOnTouchOutside(false);
        dialog.setCancelable(false);
        WindowManager.LayoutParams lay = dialog.getWindow().getAttributes();
        DisplayMetrics dm = new DisplayMetrics();
        getWindowManager().getDefaultDisplay().getMetrics(dm);
        Rect rect = new Rect();
        View view = getWindow().getDecorView();//decorView是window中的最顶层view，可以从window中获取到decorView
        view.getWindowVisibleDisplayFrame(rect);
        lay.height = dm.heightPixels - rect.top;
        lay.width = dm.widthPixels;
</code></pre><p>style.xml如下：</p>
<pre><code>&lt;style name=&quot;popupDialog&quot; parent=&quot;@android:style/Theme.Dialog&quot;&gt;
        &lt;item name=&quot;android:windowBackground&quot;&gt;@drawable/filled_activity_bg&lt;/item&gt;
        &lt;item name=&quot;android:backgroundDimEnabled&quot;&gt;false&lt;/item&gt;
        &lt;item name=&quot;android:windowIsFloating&quot;&gt;true&lt;/item&gt;
        &lt;item name=&quot;android:windowIsTranslucent&quot;&gt;true&lt;/item&gt;
        &lt;item name=&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt;
        &lt;item name=&quot;android:windowContentOverlay&quot;&gt;@null&lt;/item&gt;
        &lt;!--&lt;item name=&quot;android:windowAnimationStyle&quot;&gt;@style/dialog_animation&lt;/item&gt;--&gt;
        &lt;item name=&quot;android:colorBackgroundCacheHint&quot;&gt;@null&lt;/item&gt;
        &lt;item name=&quot;android:backgroundDimAmount&quot;&gt;0.6&lt;/item&gt;&lt;!-- 灰度 --&gt;
        &lt;!--&lt;item name=&quot;android:windowFullscreen&quot;&gt;true&lt;/item&gt;--&gt;
 &lt;/style&gt;
</code></pre><h3 id="12_u3001_u5229_u7528_u4EE3_u7801_u6E05_u9664App_u7684_u6570_u636E"><a href="#12_u3001_u5229_u7528_u4EE3_u7801_u6E05_u9664App_u7684_u6570_u636E" class="headerlink" title="12、利用代码清除App的数据"></a>12、利用代码清除App的数据</h3><pre><code>/** 
* 利用代码清除App的数据 
* 平常我们在清除App的数据时,多半在设置中找到对应的App 
* 然后选择其清除数据.下面给出代码实现. 
*  
* 注意事项: 
* 1 设备需要root 
* 2 该示例中删除的是系统级应用 
* 2 注意在命令的末尾需要加上换行\n 
*   这就相当于我们平时在Dos中输入命令后再换行一样. 
*   否则命令不会被执行. 
*/  
private void cleanData(String packageName){  
    try {  
        Process su= Runtime.getRuntime().exec(&quot;su&quot;);  
        String cmd = &quot;cd /data/data/&quot;+packageName+&quot;;&quot;+&quot;rm -r `ls|grep -v lib`&quot;;  
        System.out.println(&quot;------cmd=&quot;+cmd);  
        cmd = cmd + &quot;\n exit\n&quot;;  
        su.getOutputStream().write(cmd.getBytes());  
        if ((su.waitFor() != 0)) {  
            throw new SecurityException();  
        }  
    } catch (Exception e) {  
        System.out.println(&quot;---&gt; 9527 清除数据时 e=&quot;+e.toString());  
    }  

} 
</code></pre><h3 id="13_u3001_u6E05_u9664_u5185/_u5916_u7F13_u5B58_uFF0C_u6E05_u9664_u6570_u636E_u5E93_uFF0C_u6E05_u9664sharedPreference_uFF0C_u6E05_u9664files_u548C_u6E05_u9664_u81EA_u5B9A_u4E49_u76EE_u5F55"><a href="#13_u3001_u6E05_u9664_u5185/_u5916_u7F13_u5B58_uFF0C_u6E05_u9664_u6570_u636E_u5E93_uFF0C_u6E05_u9664sharedPreference_uFF0C_u6E05_u9664files_u548C_u6E05_u9664_u81EA_u5B9A_u4E49_u76EE_u5F55" class="headerlink" title="13、清除内/外缓存，清除数据库，清除sharedPreference，清除files和清除自定义目录"></a>13、清除内/外缓存，清除数据库，清除sharedPreference，清除files和清除自定义目录</h3><pre><code>/** 文 件 名:  DataCleanManager.java  * 描    述:  主要功能有清除内/外缓存，清除数据库，清除sharedPreference，清除files和清除自定义目录  */
import java.io.File;
import android.content.Context;
import android.os.Environment;

/** * 本应用数据清除管理器 */
public class DataCleanManager {
/** * 清除本应用内部缓存(/data/data/com.xxx.xxx/cache) * * @param context */
public static void cleanInternalCache(Context context) {
    deleteFilesByDirectory(context.getCacheDir());
}

/** * 清除本应用所有数据库(/data/data/com.xxx.xxx/databases) * * @param context */
public static void cleanDatabases(Context context) {
    deleteFilesByDirectory(new File(&quot;/data/data/&quot;
            + context.getPackageName() + &quot;/databases&quot;));
}

/**
 * * 清除本应用SharedPreference(/data/data/com.xxx.xxx/shared_prefs) * * @param
 * context
 */
public static void cleanSharedPreference(Context context) {
    deleteFilesByDirectory(new File(&quot;/data/data/&quot;
            + context.getPackageName() + &quot;/shared_prefs&quot;));
}

/** * 按名字清除本应用数据库 * * @param context * @param dbName */
public static void cleanDatabaseByName(Context context, String dbName) {
    context.deleteDatabase(dbName);
}

/** * 清除/data/data/com.xxx.xxx/files下的内容 * * @param context */
public static void cleanFiles(Context context) {
    deleteFilesByDirectory(context.getFilesDir());
}

/**
 * * 清除外部cache下的内容(/mnt/sdcard/android/data/com.xxx.xxx/cache) * * @param
 * context
 */
public static void cleanExternalCache(Context context) {
    if (Environment.getExternalStorageState().equals(
            Environment.MEDIA_MOUNTED)) {
        deleteFilesByDirectory(context.getExternalCacheDir());
    }
}

/** * 清除自定义路径下的文件，使用需小心，请不要误删。而且只支持目录下的文件删除 * * @param filePath */
public static void cleanCustomCache(String filePath) {
    deleteFilesByDirectory(new File(filePath));
}

/** * 清除本应用所有的数据 * * @param context * @param filepath */
public static void cleanApplicationData(Context context, String... filepath) {
    cleanInternalCache(context);
    cleanExternalCache(context);
    cleanDatabases(context);
    cleanSharedPreference(context);
    cleanFiles(context);
    for (String filePath : filepath) {
        cleanCustomCache(filePath);
    }
}

/** * 删除方法 这里只会删除某个文件夹下的文件，如果传入的directory是个文件，将不做处理 * * @param directory */
private static void deleteFilesByDirectory(File directory) {
    if (directory != null &amp;&amp; directory.exists() &amp;&amp; directory.isDirectory()) {
        for (File item : directory.listFiles()) {
            item.delete();
        }
    }
}
}
</code></pre><h3 id="14_u3001Listview_u6D4B_u91CF_u9AD8_u5EA6__uFF08_u653E_u5728_u8BBE_u7F6E_u5B8C_u9002_u914D_u5668_u4E4B_u540E_u8FDB_u884C_u6D4B_u91CF_uFF0C_u653E_u5728_u4E4B_u524D_uFF0C_u6CA1_u6709_u6548_u679C_uFF09"><a href="#14_u3001Listview_u6D4B_u91CF_u9AD8_u5EA6__uFF08_u653E_u5728_u8BBE_u7F6E_u5B8C_u9002_u914D_u5668_u4E4B_u540E_u8FDB_u884C_u6D4B_u91CF_uFF0C_u653E_u5728_u4E4B_u524D_uFF0C_u6CA1_u6709_u6548_u679C_uFF09" class="headerlink" title="14、Listview测量高度 （放在设置完适配器之后进行测量，放在之前，没有效果）"></a>14、Listview测量高度 （放在设置完适配器之后进行测量，放在之前，没有效果）</h3><pre><code>/**
 * 设置高度
 */
 private void setHeight(ListView listView) {
     // 获取listView的适配器
     ListAdapter adapter = listView.getAdapter();
     // 获取视图的个数
     int count = adapter.getCount();
     // 总高度
     int totalHeight = 0;
     // 循环获取视图
     for (int i = 0; i &lt; count; i++) {
         // 通过i获取每个视图
         View view = adapter.getView(i, null, listView);
         // 重新测量view的高度
         view.measure(MeasureSpec.UNSPECIFIED, MeasureSpec.UNSPECIFIED);
         // 获取测量后的高度添加到总高度
         totalHeight += view.getMeasuredHeight();
     }
     // 总高度加上所有分割线的总高度
     totalHeight += listView.getDividerHeight() * (count - 1);
     // 获取listView的布局属性
     LayoutParams params = listView.getLayoutParams();
     // 设置高度
     params.height = totalHeight;
     // 重新设置布局属性
     listView.setLayoutParams(params);
 }
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1_u3001_u83B7_u53D6_u7535_u6E90_u9501"><a href="#1_u3001_u83B7_u53D6_u7535_u6E90_u9501" class="headerlink" title="1、获取电源锁"></a>1、获取电源锁</h3><pre><code>public static void acquireWakeLock() {
    unlockKeyBoard();
    try {
        if (null == mWakeLock) {
            PowerManager pm = (PowerManager) BaseApplication.getInstance()
                    .getSystemService(Context.POWER_SERVICE);
            try {
                mWakeLock = pm.newWakeLock(PowerManager.FULL_WAKE_LOCK
                        | PowerManager.ACQUIRE_CAUSES_WAKEUP
                        | PowerManager.ON_AFTER_RELEASE, &quot;PushMessageReceiver&quot;); // |
                                                                                    // PowerManager.ON_AFTER_RELEASE
            } catch (Exception e) {
                DbUtils.exceptionHandler(e);
            }
        }
        if (null != mWakeLock) {
            mWakeLock.acquire();
        }
    } catch (Exception e) {
        DbUtils.exceptionHandler(e);
    }
}
</code></pre>]]>
    
    </summary>
    
      <category term="写作" scheme="http://kevinhero.github.io/tags/%E5%86%99%E4%BD%9C/"/>
    
      <category term="技术" scheme="http://kevinhero.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android开发工作中的细节]]></title>
    <link href="http://kevinhero.github.io/2016/03/02/%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/Android%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C%E4%B8%AD%E7%9A%84%E7%BB%86%E8%8A%82/"/>
    <id>http://kevinhero.github.io/2016/03/02/小知识点/Android开发工作中的细节/</id>
    <published>2016-03-01T18:33:45.000Z</published>
    <updated>2016-04-05T06:44:02.000Z</updated>
    <content type="html"><![CDATA[<ol>
<li><p>全部 Activity 可继承自 BaseActivity，便于统一风格与处理公共事件，构建对话框统一构建器的建立，万一需要整体变动，一处修改到处有效。</p>
</li>
<li><p>数据库表段字段常量和 SQL 逻辑分离，更清晰，建议使用 Lite 系列框架 LiteOrm 库，超级清晰且重心可以放在业务上不用关心数据库细节。</p>
</li>
<li><p>全局变量放全局类中，模块私有放自己的管理类中，让常量清晰且集中.</p>
</li>
<li><p>不要相信庞大的管理类的东西会带来什么好处，可能是一场灾难，而要时刻注意单一职责原则，一个类专心做好一件事情更为清晰。</p>
<a id="more"></a></li>
<li><p>如果数据没有必要加载，数据请务必延迟初始化，谨记为用户节省内存，总不会有坏处。</p>
</li>
<li><p>异常抛出，在合适的位置处理或者集中处理，不要搞的到处是 catch，混乱且性能低，尽量不要在循环体中捕获异常，以提升性能。</p>
</li>
<li><p>地址引用链长时（3 个以上指向）小心内存泄漏，和警惕堆栈地址指向，典型的易发事件是：数据更新了，ListView 视图却没有刷新，这时 Adapter 很可能指向并的并不是你更新的数据容器地址（一般为 List）。</p>
</li>
<li><p>信息同步：不管是数据库还是网网络操作，新插入的数据注意返回 ID（如果没有赋予唯一 ID），否则相当于没有同步。</p>
</li>
<li><p>多线程操作数据库时，db 关闭了会报错，也很可能出现互锁的问题，推荐使用事务，推荐使用自动化的 LiteOrm 库操作。</p>
</li>
<li><p>做之前先考虑那些可以公用，资源，layout，类，做一个结构、架构分析以加快开发，提升代码可复用度。</p>
</li>
<li><p>有序队列操作 add、delete 操作时注意保持排序，否则你会比较难堪喔。</p>
</li>
<li><p>数据库删除数据时，要注意级联操作避免出现永远删不掉的脏数据喔。</p>
</li>
<li><p>关于形参实参：调用函数时参数为基本类型传的是值，即传值；参数为对象传递的是引用，即传址。</p>
</li>
<li><p>listview 在数据未满一屏时，setSelection 函数不起作用；ListView 批量操作时各子项和视图正确对应，可见即所选。</p>
</li>
</ol>
<p>15 控制 Activity 的代码量，保持主要逻辑清晰。其他类遵守 SRP（单一职能），ISP（接口隔离）原则。</p>
<ol>
<li><p>arraylist 执行 remove 时注意移除 int 和 Integer 的区别。你懂得。</p>
</li>
<li><p>Log 请打上 Tag，调试打印一定要做标记，能定位打印位置，否则尴尬是：不知道是哪里在打印。</p>
</li>
<li><p>码块/常量/资源可以集中公用的一定共用，即使共用逻辑稍复杂一点也会值得，修改起来很轻松，修改一种，到处有效。</p>
</li>
<li><p>setSelection 不起作用，尝试 smoothScrollToPosition。ListView 的 LastVisiblePosition（最后一个可见子项）会随着 getView 方法执行位置不同变动而变。</p>
</li>
<li><p>与 Activity 通讯使用 Handler 更方便； 如果你的框架回调链变长，考虑监听者模式简化回调。</p>
</li>
<li><p>监听者模式不方便使用时，推荐 EventBus 框架库，使用时间总线，没接触过的同学可以自行脑补一下哦。</p>
</li>
<li><p>Handler 在子线程线程使用 Looper.prepare，或者 new 的时候给构造函数传入 MainLooper 来确保在主线程 run。</p>
</li>
<li><p>timepicker 点击确定后需要 clearFocus 才能获取手动输入的时间。</p>
</li>
<li><p>构造函数里面极度不推荐启动异步线程，会埋下隐患。比如：异步线程调用了本例的示例，就会悲剧等着崩溃吧。</p>
</li>
<li><p>千万不要理所当然的以为一个对象不会为空，充分的做好容错处理；另外注意 null 也可以插入 ArrayList 等容器中。</p>
</li>
<li><p>ExpandableListView 的子列表不能点击（禁用）要把 Adapter 的 isChildSelectable 方法返回 true。</p>
</li>
<li><p>UI 显示注意内容过长的情形要提前使用 ScrollView 否则在小手机上尴尬你懂得。</p>
</li>
<li><p>注意按钮的感应范围不小于 9mm 否则不易点击；输入框注意光标的位置更易用户输入。</p>
</li>
<li><p>服务器和客户端尽量统一唯一标识（有可能是 ID），否则多少会有歧义和问题。</p>
</li>
<li><p>注释，尽量去写足够的注释，去描述一下思路，达到看了可以明白某一块代码的效果。</p>
</li>
<li><p>完整型数据一定要用 Sqlite 的 Transaction，大数据一定要用。粗略测试插入 100 个数据有 20 倍的提速，插入 1000 个数据就有 100 多倍的提速。</p>
</li>
<li><p>避免 String=”null”的情况出现 String = null,=””都可以。避免出现 title=”无主题”这样的数据提交到数据库浪费空间。</p>
</li>
<li><p>存在多个不同的 dbhelper 实例情况下，sqlitedatabase 对象必然存在不同的实例，多线程同时写入数据，轮流写入数据时会不定时的报 db is locked，引起崩溃，不管是操作同张表还是异表。读和写可以同时并发，轮流无规律的交替执行。同时写入数据时解决方案是用并发的每个线程都用事 务，db 则不会 lock，按次整体写入。</p>
</li>
<li><p>建议整个应用维护一个 dbhelper 实例，只要 db 没有关闭，全局就只有一个 db 实例，多线程并发写入 db 不会 lock，严格交替进行写入：123123123。。。（123 代表不同线程，轮流插入一个记录），读和写均不会锁住 db，读写交替并没有规律，执行次数和程度看 cpu 分配给哪个线程的时间片长。</p>
</li>
<li><p>一个任务使用事务嵌套N个事务，N个事务中有一个失败，这个任务整体失败，全部成功后，数据才写入，具有安全性，整体性。并且事务写入大批量数据的效率经 实际测试成百上千倍的高于一般的单个写入。数据库大量数据、多线程操作建议使用 LiteOrm 数据库框架，更稳定简单。</p>
</li>
<li><p>经常需要用 ListView 或者其它显示大量 Items 的控件实时跟踪或者查看信息，并且希望最新的条目可以自动滚动到可视范围内。通过设置的控件 transcriptMode 属性可以将 Android 平台的控件（支持 ScrollBar）自动滑动到最底部。</p>
</li>
<li><p>Long a; 判断a有没有赋值，if (a == 0) 在a没有赋值情况下会报错。应该 if (a == null)，Integer、Floag 等也一样，原因你懂，只是提醒你要小心喔。</p>
</li>
<li><p>编码遇到读写、出入等逻辑要双向考虑，文件导入导出，字符字节相互转换都要两边转码。</p>
</li>
<li><p>一个 int 值与一个 Integer 对象（能包含 int 值的最小对象）的大小比率约为 1:4（32 位和 64 位机器有不同）。额外的开销源于 JVM 用于描述 Java 对象的元数据也就是 Integer，（Long、Double 等也是）。</p>
</li>
<li><p>对象由元数据和数据组成。元数据包括类（指向类的指针，描述了类的类型），标记（描述了对象状态，如散列码、形状等），锁（对象同步信息）。数组对象还包括大小的元数据。</p>
</li>
<li><p>一个在 32 位 Java 运行时中使用 1GB  Java 堆的 Java 应用程序在迁移到 64 位 Java 运行时之后，通常需要使用 1.7GB 的 Java 堆。</p>
</li>
<li><p>Hash 集合的访问性能比任何 List 的性能都要高，但每条目的成本也要更高。由于访问性能方面的原因，如果您正在创建大集合（例如，用于实现缓存），那么最好使用基于 Hash 的集合，而不必考虑额外的开销。</p>
</li>
<li><p>对于并不那么注重访问性能的较小集合而言，List 则是合理的选择。ArrayList 和 LinkedList 集合的性能大体相同，但其内存占用完全不同：ArrayList 的每条目大小要比 LinkedList 小得多，但它不是准确设置大小的。List 要使用的正确实现是 ArrayList 还是 LinkedList 取决于 List 长度的可预测性。如果长度未知，那么正确的选择可能是 LinkedList，因为集合包含的空白空间更少。如果大小已知或可预知或比较小，那么 ArrayList 的内存开销会更低一些。</p>
</li>
<li><p>选择正确的集合类型使你能够在集合性能与内存占用之间达到合理的平衡。除此之外，你可以通过正确调整集合大小来最大化填充率、最小化未得到利用的空间，从而最大限度地减少内存占用。</p>
</li>
<li><p>充分利用封装（提供接口类来控制访问数据）和委托（helper 对象来实施任务）两种理念。</p>
</li>
<li><p>延迟分配 Hashtable：如果 Hashtable 为空是经常发生的普遍现象，那么仅在存在需要存储的数据时分配 Hashtable 应该是一种合理的做法。将 Hashtable 分配为准确的大小：虽然会有默认大小，但建议使用更为准确的初始大小。</p>
</li>
<li><p>EditText 在 setText 时不要忘记是否需要 setSelection。在大多数情况下是需要设置的。</p>
</li>
<li><p>XML 两种情况要注意：1 属性名字时候有重复；2 注意文本是否包含非法字符，注意使用 CDATA 包裹。</p>
</li>
<li><p>当逻辑没有明显问题时考虑对象属性、函数参数、网络传输参数是否全部了解，是否设置正确。</p>
</li>
<li><p>当出现编译或者运行时错误，别人那没问题时，考虑你的编译环境和环境版本是否有问题。</p>
</li>
<li><p>由于 String 类的 immutable 性质，当 String 变量需要经常变换其值时，应该考虑使用 StringBuilder 提升性能，多线程使用 StringBuffer 操作 string 提高程序效率。</p>
</li>
<li><p>java 栈的优势是比堆速度快，可共享，主要存放临时变量、参数等，堆的优势是可动态分配内存大小。</p>
</li>
<li><p>只要是用 new ()来新建对象的，都会在堆中创建，而且其数据是单独存值的，即使与栈中的数据（值）相同，也不会与栈中的数据共享。</p>
</li>
<li><p>基本数据类型定义的变量称自动变量，存的是‘字面值’，存在于栈中，可共享（存在即不新建）。</p>
</li>
<li><p>多个 RandomAccessFile 对象指向同一个文件，可使用多个线程一起写入无需再自己加锁，经试验结论：三个线程分别写入 100 万次数据，使用锁约 12 秒，不使用约 8.5 秒。100 个线程分别写入 1 万次数据使用锁耗时约 4.2 秒，不使用锁耗时约 3 秒。</p>
</li>
<li><p>XmlPullParser 解析慎用 nextText ()方法，xml 比较复杂，含有空标签、重复名字标签时容易出现异常问题；TEXT 中使用 getText ()方法代替 START_TAG 中使用 nextText ()方法；START_TAG，TEXT，END_TAG 三个事件配合使用。注意每个 xml 节点之间（不管是开始节点还是结束节点）都会出现 TEXT 事件。</p>
</li>
<li><p>改变逻辑的时候考虑全部用到这项功能的地方，分散的地方多了，容易大意。</p>
</li>
<li><p>当系统原生组件出现问题时，查看错误栈信息，自己写一个该组件的子类，并在合适的地方将出错方法复写一下，加上 try catch 保证不崩溃掉。不要扰乱了该系统控件的正常逻辑。</p>
</li>
<li><p>输入控件注意对空格、换行等符号的控制；输入框里内容注意和左右控件的空间，防止误点击。</p>
</li>
<li><p>注意函数参数里的++或者–操作。是++c 还是 c++，区别很大。</p>
</li>
<li><p>各种地方、永远的不要小看 null 指针问题，甚至有些场合宁可错杀（try catch），不可放过。</p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<ol>
<li><p>全部 Activity 可继承自 BaseActivity，便于统一风格与处理公共事件，构建对话框统一构建器的建立，万一需要整体变动，一处修改到处有效。</p>
</li>
<li><p>数据库表段字段常量和 SQL 逻辑分离，更清晰，建议使用 Lite 系列框架 LiteOrm 库，超级清晰且重心可以放在业务上不用关心数据库细节。</p>
</li>
<li><p>全局变量放全局类中，模块私有放自己的管理类中，让常量清晰且集中.</p>
</li>
<li><p>不要相信庞大的管理类的东西会带来什么好处，可能是一场灾难，而要时刻注意单一职责原则，一个类专心做好一件事情更为清晰。</p>]]>
    
    </summary>
    
      <category term="知识库" scheme="http://kevinhero.github.io/tags/%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    
      <category term="技术" scheme="http://kevinhero.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[日常使用到的梯子]]></title>
    <link href="http://kevinhero.github.io/2016/03/01/%E9%9A%8F%E7%AC%94/%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E5%88%B0%E7%9A%84%E6%A2%AF%E5%AD%90/"/>
    <id>http://kevinhero.github.io/2016/03/01/随笔/日常使用到的梯子/</id>
    <published>2016-03-01T04:33:45.000Z</published>
    <updated>2016-04-05T08:47:20.000Z</updated>
    <content type="html"><![CDATA[<p>日常生活中,由于天朝的局域网的限制,很多网站都无法进行使用,虽然国内也有替代的网站,但是作为开发人员来讲,这些事远远不够的,现在就讲我个人在生活工作中使用到梯子,进行总结一下</p>
<h2 id="PC_u7AEF"><a href="#PC_u7AEF" class="headerlink" title="PC端"></a>PC端</h2><p>##全局梯子<br>目前在PC上(window)使用到的全局的梯子 就是 赛风和VPN Gate</p>
<h3 id="u8D5B_u98CE"><a href="#u8D5B_u98CE" class="headerlink" title="赛风"></a>赛风</h3><p>如果能够直接访问 <a herf="http://www.psiphon3.net/zh/index.html"> 直达</a></p>
<h4 id="u7B80_u5355_u4ECB_u7ECD"><a href="#u7B80_u5355_u4ECB_u7ECD" class="headerlink" title="简单介绍"></a>简单介绍</h4><p>赛风是赛风公司的一款新翻墙工具，利用VPN, SSH和HTTP代理软件提供未经审查的访问互联网。赛风的客户端将自动寻找新的接入点，力求最大限度的绕过网络审查。<br><a id="more"></a><br>赛风旨在为您提供在线内容的开放访问。赛风不会增加暴露您的在线隐私，也不应被用作是在线安全工具。</p>
<p><a herf="https://github.com/Psiphon-Labs">源码地址</a></p>
<h3 id="VPN_Gate"><a href="#VPN_Gate" class="headerlink" title="VPN Gate"></a>VPN Gate</h3><h4 id="u7EFC_u8FF0"><a href="#u7EFC_u8FF0" class="headerlink" title="综述"></a>综述</h4><p>VPN Gate 学术实验项目是一个在线服务，由日本国立筑波大学研究生院为学术研究目的运营。本研究的目的是推广 “全球分布式公共 VPN 中继服务器” 的知识。</p>
<h4 id="u4EAE_u70B9"><a href="#u4EAE_u70B9" class="headerlink" title="亮点"></a>亮点</h4><p>VPN 可以绕过防火墙。VPN 可以隐藏你的真实 IP 地址。VPN 可以防止在本地网络上的窃听</p>
<h4 id="u4F7F_u7528"><a href="#u4F7F_u7528" class="headerlink" title="使用"></a>使用</h4><p>这里提供一个<a herf="http://39.118.148.162:33281/cn/">daily链接</a>,不能保证能否使用,如果不能使用,自己又搜索不到,可以邮件给我</p>
<p>##浏览器梯子 </p>
<h3 id="Lantern"><a href="#Lantern" class="headerlink" title="Lantern"></a>Lantern</h3><p>自己用的 最出名的就是<a href="https://getlantern.org/" target="_blank" rel="external">Lantern</a>,配合Chrome使用,安装完成,打开lantern即可访问Google<br><a herf="https://github.com/getlantern">源码地址</a></p>
<h3 id="u4E09_u65B9_u5C01_u88C5_u7684"><a href="#u4E09_u65B9_u5C01_u88C5_u7684" class="headerlink" title="三方封装的"></a>三方封装的</h3><p><a href="http://www.ccav1.me/chromegae.html" target="_blank" rel="external">ChromeGAE</a></p>
<h4 id="u4ECB_u7ECD"><a href="#u4ECB_u7ECD" class="headerlink" title="介绍"></a>介绍</h4><p>ChromeGAE 是基于 Google Chrome 制作的免费浏览器。</p>
<p>集成多个实用的扩展，可以过滤 视频广告、网页广告 等等。</p>
<p>内置科学上网工具，可畅游 Youtube Facebook Twitter 等网站！</p>
<h2 id="u624B_u673A_u68AF_u5B50"><a href="#u624B_u673A_u68AF_u5B50" class="headerlink" title="手机梯子"></a>手机梯子</h2><p>赛风 lantern</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>日常生活中,由于天朝的局域网的限制,很多网站都无法进行使用,虽然国内也有替代的网站,但是作为开发人员来讲,这些事远远不够的,现在就讲我个人在生活工作中使用到梯子,进行总结一下</p>
<h2 id="PC_u7AEF"><a href="#PC_u7AEF" class="headerlink" title="PC端"></a>PC端</h2><p>##全局梯子<br>目前在PC上(window)使用到的全局的梯子 就是 赛风和VPN Gate</p>
<h3 id="u8D5B_u98CE"><a href="#u8D5B_u98CE" class="headerlink" title="赛风"></a>赛风</h3><p>如果能够直接访问 <a herf="http://www.psiphon3.net/zh/index.html"> 直达</a></p>
<h4 id="u7B80_u5355_u4ECB_u7ECD"><a href="#u7B80_u5355_u4ECB_u7ECD" class="headerlink" title="简单介绍"></a>简单介绍</h4><p>赛风是赛风公司的一款新翻墙工具，利用VPN, SSH和HTTP代理软件提供未经审查的访问互联网。赛风的客户端将自动寻找新的接入点，力求最大限度的绕过网络审查。<br>]]>
    
    </summary>
    
      <category term="VPN" scheme="http://kevinhero.github.io/tags/VPN/"/>
    
      <category term="随笔" scheme="http://kevinhero.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android小知识库]]></title>
    <link href="http://kevinhero.github.io/2016/03/01/%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/Android%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"/>
    <id>http://kevinhero.github.io/2016/03/01/小知识点/Android开发中的小知识点汇总/</id>
    <published>2016-02-29T18:33:45.000Z</published>
    <updated>2016-04-07T03:26:16.000Z</updated>
    <content type="html"><![CDATA[<p>这份是我工作以来，总结的小知识库，有些知识点现在看来太LOW了，把还觉得有用的分享出来！</p>
<h3 id="Genymotion_u4E0B_u8F7D_u865A_u62DF_u955C_u50CFConnection_timeout"><a href="#Genymotion_u4E0B_u8F7D_u865A_u62DF_u955C_u50CFConnection_timeout" class="headerlink" title="Genymotion下载虚拟镜像Connection timeout"></a>Genymotion下载虚拟镜像Connection timeout</h3><p>Add new device出现的问题：</p>
<p>Failed to deploy virtual device.<br>Unable to create virtual device.Connection timeout occurred.</p>
<p>解决方案：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#24403;&#36873;&#25321;Google Nexus 5 - 6.0.0 - API 23 - 1080x1920&#19979;&#36733;device&#22833;&#36133;&#21518;&#65292;&#21040;C:\Users\&#29992;&#25143;&#20027;&#30446;&#24405;\AppData\Local\Genymobile\Genymotion\ova&#19979;&#30475;&#21040;genymotion_vbox86p_6.0_160114_090449.ova&#65292;&#22823;&#23567;&#21364;&#26159;0KB&#65292;&#22312;C:\Users\&#29992;&#25143;&#20027;&#30446;&#24405;\AppData\Local\Genymobile\genymotion.log&#65292;&#25171;&#24320;&#35813;&#25991;&#20214;&#65292;&#25214;&#21040;&#31867;&#20284;&#10;    &#10;    &#8220;http://files2.genymotion.com/dists/6.0.0/ova/genymotion_vbox86p_6.0_160114_090449.ova&#8221;&#36335;&#24452;&#65292;&#21363;&#24744;&#24819;&#35201;&#19979;&#36733;&#30340;&#38236;&#20687;&#25991;&#20214;URL&#65307;`&#10;&#10;&#29992;&#36805;&#38647;&#21435;&#19979;&#36733;&#65292;&#19979;&#36733;&#23436;&#25104;&#21518;&#25918;&#21040;C:\Users\&#29992;&#25143;&#20027;&#30446;&#24405;\AppData\Local\Genymobile\Genymotion\ova&#65307;&#10;&#37325;&#26032;&#28857;&#20987;Google Nexus 5 - 6.0.0 - API 23 - 1080x1920&#21435;&#19979;&#36733;&#65292;&#39564;&#35777;&#23433;&#35013;&#21518;&#21363;&#20250;&#26174;&#31034;&#22312;&#35774;&#22791;&#21015;&#34920;&#20013;&#12290;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h3 id="Android_Studio__u5982_u4F55Debug"><a href="#Android_Studio__u5982_u4F55Debug" class="headerlink" title="Android Studio 如何Debug"></a>Android Studio 如何Debug</h3><p>单击F5(Step Over)，单行一个个方法执行<br>单击F6(Step Into)，单行执行<br>单击F7(Step Out)，不往下执行，回到上一行<br>单击F8(Resume Program)，跳出当前断点</p>
<h3 id="Android_Studio_u8BBE_u7F6E_u9ED8_u8BA4_u7684_u7B7E_u540D_u6587_u4EF6"><a href="#Android_Studio_u8BBE_u7F6E_u9ED8_u8BA4_u7684_u7B7E_u540D_u6587_u4EF6" class="headerlink" title="Android Studio设置默认的签名文件"></a>Android Studio设置默认的签名文件</h3><p>新浪微博SSO登录，微信分享这些都需要签名打包，才能看到效果，设置默认签名文件为自己的签名jks，这样就不需要打包了。<br>在app目录下添加你的.jks，然后app的build.gradle文件中的增加以下内容：<br>第一种：</p>
<pre><code>android {  
    signingConfigs {  
        debug {  
            storeFile file(&quot;你的.jks&quot;)
            storePassword &apos;android&apos;
            keyAlias &apos;android&apos;
            keyPassword &apos;android&apos;
        }          
    }      
}
</code></pre><p>第二种：</p>
<pre><code>android {  
    signingConfigs {  
        release {  
            storeFile file(&quot;你的.jks&quot;)
            storePassword &apos;android&apos;
            keyAlias &apos;android&apos;
            keyPassword &apos;android&apos;
        }          
    }  
    buildTypes {
        debug {
            signingConfig signingConfigs.release
        }        
    }
}
</code></pre><p>这样编译出来的debug版本直接用的是你的正式签名</p>
<h3 id="Fragment_u61D2_u52A0_u8F7D"><a href="#Fragment_u61D2_u52A0_u8F7D" class="headerlink" title="Fragment懒加载"></a>Fragment懒加载</h3><pre><code>protected boolean isVisible;

@Override
public void setUserVisibleHint(boolean isVisibleToUser) {
    super.setUserVisibleHint(isVisibleToUser);
    if (getUserVisibleHint()) {
        isVisible = true;
        onVisible();
    } else {
        isVisible = false;
        onInvisible();
    }
}

protected void onVisible() {
    lazyLoad();
}

protected void lazyLoad() {
    if (!isVisible) {
        return;
    }
    getData();
}

protected void onInvisible() {
}
</code></pre><h3 id="Android_studio_u5934_u6CE8_u91CA_u548C_u65B9_u6CD5_u6CE8_u91CA"><a href="#Android_studio_u5934_u6CE8_u91CA_u548C_u65B9_u6CD5_u6CE8_u91CA" class="headerlink" title="Android studio头注释和方法注释"></a>Android studio头注释和方法注释</h3><blockquote>
<p>File | Settings | Editor|File and Code Templates|Includes|File Header</p>
</blockquote>
<pre><code>/**
* Created by ${USER} on ${DATE}.
*/
</code></pre><p>输入我们想要设置的注释模板</p>
<pre><code>adapter.getPositionForSelection()和getSectionForPosition()
getPositionForSection()根据分类列的索引号获得该序列的首个位置
getSectionForPosition()通过该项的位置，获得所在分类组的索引号

getResources().getColor(R.color.color_name) is deprecated和drawableTop

textView.setTextColor(Color.parseColor(&quot;#FFFFFF&quot;));
//或者
ContextCompat.getColor(context, R.color.color_name)

private void showPopupMenu(View v) {
    final View bgView = View.inflate(DemoApplication.getContext(), R.layout.demo_popup_window_bg, null);
    bgView.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            hidePopupWindow();
        }
    });
    if (mPopupBackground == null) {
        mPopupBackground = new PopupWindow(bgView, ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);
    }
    mPopupBackground.showAtLocation(v, Gravity.BOTTOM, 0, 0);
}
</code></pre><p>v：父布局<br>    demo_popup_window_bg.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:background=&quot;@color/aliwx_common_alpha_black&quot;&gt;

&lt;/LinearLayout&gt;
</code></pre><h3 id="onFinishInflate_28_29"><a href="#onFinishInflate_28_29" class="headerlink" title="onFinishInflate()"></a>onFinishInflate()</h3><p>view的onFinishInflate()何时调用的？</p>
<p>当View中所有的子控件均被映射成xml后触发；</p>
<pre><code>MyView mv = (MyView)View.inflate (context,R.layout.my_view,null);
</code></pre><p>当加载完成xml后，就会执行那个方法；</p>
<p>我们一般使用View的流程是在onCreate中使用setContentView来设置要显示Layout文件或直接创建一个View，在当设置了ContentView之后系统会对这个View进行解析，然后回调当前视图View中的onFinishInflate方法。只有解析了这个View我们才能在这个View容器中获取到拥有Id的组件，同样因为系统解析完View之后才会调用onFinishInflate方法，所以我们自定义组件时可以onFinishInflate方法中获取指定子View的引用。</p>
<h3 id="Fragment_u8BBE_u7F6E_u9690_u85CF_u6216_u663E_u793A_u67D0_u4E2AFragment"><a href="#Fragment_u8BBE_u7F6E_u9690_u85CF_u6216_u663E_u793A_u67D0_u4E2AFragment" class="headerlink" title="Fragment设置隐藏或显示某个Fragment"></a>Fragment设置隐藏或显示某个Fragment</h3><h4 id="MainFragment_u70B9_u51FB"><a href="#MainFragment_u70B9_u51FB" class="headerlink" title="MainFragment点击"></a>MainFragment点击</h4><pre><code>public void onItemClick(AdapterView&lt;?&gt; adapterView, View view,
                            int position, long id) {

        ((MainActivity) getActivity()).showImageFragment(true, mData.get(position).get(&quot;title&quot;).toString(), mData.get(position).get(&quot;imgUrl&quot;).toString());

    }
</code></pre><h4 id="MainActivity"><a href="#MainActivity" class="headerlink" title="MainActivity"></a>MainActivity</h4><pre><code>public void showImageFragment(boolean show, String imgTxt, String imgUrl) {
        // showActionbarWithTabs(!show);
        if (show) {
            getSupportFragmentManager().beginTransaction()
                    .show(imageDetailFragment).commit();
            imageDetailFragment.setImgData(imgTxt, imgUrl);
        } else {
            getSupportFragmentManager().beginTransaction()
                    .hide(imageDetailFragment).commit();
        }

    }
</code></pre><h3 id="u83B7_u53D6arrt_u7684_u503C"><a href="#u83B7_u53D6arrt_u7684_u503C" class="headerlink" title="获取arrt的值"></a>获取arrt的值</h3><p>不同主题下需要把颜色，数值写成attr属性<br>xml里，我们可以简单的引用attr属性值</p>
<pre><code>android:background=&quot;?attr/colorPrimary&quot;
</code></pre><h4 id="u4EE3_u7801_u83B7_u53D6"><a href="#u4EE3_u7801_u83B7_u53D6" class="headerlink" title="代码获取"></a>代码获取</h4><pre><code>TypedValue typedValue = new TypedValue();
mContext.getTheme().resolveAttribute(R.attr.colorPrimary, typedValue, true);
int colorPrimary = typedValue.data;//value.data里面存储着的就是获取到的colorPrimary的值
</code></pre><h3 id="u62E8_u53F7_u76D8_u62E8_u6253_u7535_u8BDD"><a href="#u62E8_u53F7_u76D8_u62E8_u6253_u7535_u8BDD" class="headerlink" title="拨号盘拨打电话"></a>拨号盘拨打电话</h3><pre><code>Intent intent = new Intent(Intent.ACTION_CALL,
Uri.parse(&quot;tel:&quot; + &quot;400-036-1977&quot;));
// intent.setAction(Intent.ACTION_CALL);// 直接拨号
intent.setAction(Intent.ACTION_DIAL);// 拨号盘
startActivity(intent);
</code></pre><h3 id="Drawable_/Bitmap_u3001String/InputStream_u3001Bitmap/byte_5B_5D_u4E92_u8F6C"><a href="#Drawable_/Bitmap_u3001String/InputStream_u3001Bitmap/byte_5B_5D_u4E92_u8F6C" class="headerlink" title="Drawable /Bitmap、String/InputStream、Bitmap/byte[]互转"></a>Drawable /Bitmap、String/InputStream、Bitmap/byte[]互转</h3><pre><code>http://wuxiaolong.me/2015/08/10/Drawable-to-Bitmap/
</code></pre><h3 id="ProgressDialog"><a href="#ProgressDialog" class="headerlink" title="ProgressDialog"></a>ProgressDialog</h3><pre><code>final ProgressDialog progress = new ProgressDialog(LoginActivity.this);
        progress.setMessage(&quot;请稍等...&quot;);
        progress.setCanceledOnTouchOutside(false);
        progress.show();
progress.dismiss();
</code></pre><h3 id="u6BEB_u79D2"><a href="#u6BEB_u79D2" class="headerlink" title="毫秒"></a>毫秒</h3><p>毫秒Calendar.getInstance().getTimeInMillis()和System.currentTimeMillis()</p>
<h3 id="Fragment_setUserVisibleHint_28boolean_isVisibleToUser_29"><a href="#Fragment_setUserVisibleHint_28boolean_isVisibleToUser_29" class="headerlink" title="Fragment setUserVisibleHint(boolean isVisibleToUser)"></a>Fragment setUserVisibleHint(boolean isVisibleToUser)</h3><pre><code>@Override
public void setUserVisibleHint(boolean isVisibleToUser) {
    super.setUserVisibleHint(isVisibleToUser);
    if (isVisibleToUser) {
        //相当于Fragment的onResume
    } else {
        //相当于Fragment的onPause
    }
}
</code></pre><h3 id="Fragment_onActivityResult"><a href="#Fragment_onActivityResult" class="headerlink" title="Fragment onActivityResult"></a>Fragment onActivityResult</h3><pre><code>public void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        getActivity();
        if (resultCode == Activity.RESULT_OK
                &amp;&amp; requestCode == AppUtils.REQUEST_CODE_ISLOGIN) {
            // 检查是否完善资料

            if (AppUtils.getSharedPreferences(getActivity()).getBoolean(
                    &quot;hasPersonalData&quot;, false)) {
                // 取本地存取是否完善资料,完善直接提示咨询对话框
                consultationDialog();
            } else {
                getCheckPersonalData();
            }

        }
    } 

startActivityForResult(intent,AppConfig.REQUEST_CODE_DIALOGUE);// 不是调用 getActivity().startActivityForResult()。
</code></pre><h3 id="dimen_u4EE3_u7801_u53D6_u503C"><a href="#dimen_u4EE3_u7801_u53D6_u503C" class="headerlink" title="dimen代码取值"></a>dimen代码取值</h3><p>getDimension方法获取到资源文件中定义的dimension值。</p>
<pre><code>Resources res = getResources();
float fontSize = res.getDimension(R.dimen.font_size);
</code></pre><h3 id="u6570_u7EC4_u521D_u59CB_u5316_u8D4B_u503C"><a href="#u6570_u7EC4_u521D_u59CB_u5316_u8D4B_u503C" class="headerlink" title="数组初始化赋值"></a>数组初始化赋值</h3><p>1、创建数组后，通过循环对数组赋值。<br>例如代码：</p>
<pre><code>int [] nums = new int [100];
for(int i=0;i&lt;10;i++){
nums[i] = i;
}
</code></pre><p>2、例如代码：</p>
<pre><code>int [] nums = {0,1,2,3,4,5,6,7,8,9};
</code></pre><p>3、</p>
<pre><code>int [] nums = new int[]{0,1,2,3,4,5,6,7,8,9};
</code></pre><h3 id="Fragment-isAdded_28_29"><a href="#Fragment-isAdded_28_29" class="headerlink" title="Fragment.isAdded()"></a>Fragment.isAdded()</h3><pre><code>Fragment mBeforeFragment = new Fragment();
public void switchFragment(Fragment currentFragment) {
if (currentFragment.isAdded()) {
getSupportFragmentManager().beginTransaction().hide(mBeforeFragment).show(currentFragment).commit();
} else {
getSupportFragmentManager().beginTransaction().hide(mBeforeFragment).add(R.id.container, currentFragment).commit();
}
mBeforeFragment = currentFragment;
}
</code></pre><p>调用：</p>
<pre><code>switchFragment(HomeFragment.newInstance());
HomeFragment


public static HomeFragment homeFragment = null;

public static HomeFragment newInstance() {
if (homeFragment == null) {
homeFragment = new HomeFragment();
}
return homeFragment;
}
</code></pre><h3 id="android_u4E4BinputType_u5C5E_u6027"><a href="#android_u4E4BinputType_u5C5E_u6027" class="headerlink" title="android之inputType属性"></a>android之inputType属性</h3><pre><code>&lt;EditText android:layout_width=&quot;fill_parent&quot; 
android:layout_height=&quot;wrap_content&quot; 
android:inputType=&quot;phone&quot; /&gt;
</code></pre><p>//文本类型，多为大写、小写和数字符号。</p>
<pre><code>android:inputType=&quot;none&quot;
android:inputType=&quot;text&quot;
android:inputType=&quot;textCapCharacters&quot; 字母大写
android:inputType=&quot;textCapWords&quot; 首字母大写
android:inputType=&quot;textCapSentences&quot; 仅第一个字母大写
android:inputType=&quot;textAutoCorrect&quot; 自动完成
android:inputType=&quot;textAutoComplete&quot; 自动完成
android:inputType=&quot;textMultiLine&quot; 多行输入
android:inputType=&quot;textImeMultiLine&quot; 输入法多行（如果支持）
android:inputType=&quot;textNoSuggestions&quot; 不提示
android:inputType=&quot;textUri&quot; 网址
android:inputType=&quot;textEmailAddress&quot; 电子邮件地址
android:inputType=&quot;textEmailSubject&quot; 邮件主题
android:inputType=&quot;textShortMessage&quot; 短讯
android:inputType=&quot;textLongMessage&quot; 长信息
android:inputType=&quot;textPersonName&quot; 人名
android:inputType=&quot;textPostalAddress&quot; 地址
android:inputType=&quot;textPassword&quot; 密码
android:inputType=&quot;textVisiblePassword&quot; 可见密码
android:inputType=&quot;textWebEditText&quot; 作为网页表单的文本
android:inputType=&quot;textFilter&quot; 文本筛选过滤
android:inputType=&quot;textPhonetic&quot; 拼音输入
</code></pre><p>//数值类型</p>
<pre><code>android:inputType=&quot;number&quot; 数字
android:inputType=&quot;numberSigned&quot; 带符号数字格式
android:inputType=&quot;numberDecimal&quot; 带小数点的浮点格式
android:inputType=&quot;phone&quot; 拨号键盘
android:inputType=&quot;datetime&quot; 时间日期
android:inputType=&quot;date&quot; 日期键盘
android:inputType=&quot;time&quot; 时间键盘
</code></pre><h3 id="ImageView-ScaleType"><a href="#ImageView-ScaleType" class="headerlink" title="ImageView.ScaleType"></a>ImageView.ScaleType</h3><pre><code>（1）ImageView.ScaleType.center:图片位于视图中间，但不执行缩放。
（2）ImageView.ScaleType.CENTER_CROP 按统一比例缩放图片（保持图片的尺寸比例）便于图片的两维（宽度和高度）等于或者大于相应的视图的维度
（3）ImageView.ScaleType.CENTER_INSIDE按统一比例缩放图片（保持图片的尺寸比例）便于图片的两维（宽度和高度）等于或者小于相应的视图的维度
（4）ImageView.ScaleType.FIT_CENTER缩放图片使用center
（5）ImageView.ScaleType.FIT_END缩放图片使用END
（6）ImageView.ScaleType.FIT_START缩放图片使用START
（7）ImageView.ScaleType.FIT_XY缩放图片使用XY
（8）ImageView.ScaleType.MATRIX当绘制时使用图片矩阵缩放
</code></pre><h3 id="u8C03_u7528_u7CFB_u7EDF_u53D1_u9001_u77ED_u4FE1_u754C_u9762"><a href="#u8C03_u7528_u7CFB_u7EDF_u53D1_u9001_u77ED_u4FE1_u754C_u9762" class="headerlink" title="调用系统发送短信界面"></a>调用系统发送短信界面</h3><pre><code>/**
* 发送短信
* @param smsBody
*/
private void sendSMS(String smsBody)
{
//Uri smsToUri = Uri.parse(&quot;smsto:10000&quot;); //如果想指定发送人
Uri smsToUri = Uri.parse(&quot;smsto:&quot;);
Intent intent = new Intent(Intent.ACTION_SENDTO, smsToUri);
intent.putExtra(&quot;sms_body&quot;, smsBody);
startActivity(intent);
}
</code></pre><h3 id="u8DF3_u8F6C_u5E02_u573A_u641C_u7D22_u67D0_u6B3E_u8F6F_u4EF6"><a href="#u8DF3_u8F6C_u5E02_u573A_u641C_u7D22_u67D0_u6B3E_u8F6F_u4EF6" class="headerlink" title="跳转市场搜索某款软件"></a>跳转市场搜索某款软件</h3><pre><code>Intent intent = new Intent(
                &quot;android.intent.action.VIEW&quot;);
        intent.setData(Uri
                .parse(&quot;market://details?id=com.adobe.flashplayer&quot;));
        startActivity(intent);
</code></pre><h3 id="u68C0_u6D4B_u7CFB_u7EDF_u4E2D_u662F_u5426_u5B89_u88C5_u67D0_u6B3E_u8F6F_u4EF6"><a href="#u68C0_u6D4B_u7CFB_u7EDF_u4E2D_u662F_u5426_u5B89_u88C5_u67D0_u6B3E_u8F6F_u4EF6" class="headerlink" title="检测系统中是否安装某款软件"></a>检测系统中是否安装某款软件</h3><pre><code>//检测系统中是否已经安装了adobe flash player插件，插件的packageName是com.adobe.flashplayer：
private boolean check() {
        PackageManager pm = getPackageManager();
        List&lt;PackageInfo&gt; infoList = pm
                .getInstalledPackages(PackageManager.GET_SERVICES);
        for (PackageInfo info : infoList) {
            if (&quot;com.adobe.flashplayer&quot;.equals(info.packageName)) {
                return true;
            }
        }
        return false;
}

private void isAvilible(String packageName) {

        PackageInfo packageInfo;
        try {
            packageInfo = this.getPackageManager().getPackageInfo(packageName,
                    0);

        } catch (NameNotFoundException e) {
            packageInfo = null;
            e.printStackTrace();
        }
        if (packageInfo != null) {

        //1、通过包名
        Intent intent = new Intent();
        intent = getPackageManager().getLaunchIntentForPackage(packageName);
        startActivity(intent);

        //2、通过类名： 
        Intent intent=new Intent();  
        intent.setComponent(new ComponentName(packageName, &quot;com.joe.internet.Main&quot;));  
        startActivity(intent);  
            } 

        }
</code></pre><h3 id="u5BF9_u8BDD_u6846_u83DC_u5355"><a href="#u5BF9_u8BDD_u6846_u83DC_u5355" class="headerlink" title="对话框菜单"></a>对话框菜单</h3><pre><code>new AlertDialog.Builder(this)
                    .setTitle(&quot;choice&quot;)
                    .setItems(new String[] { &quot;选择1&quot;, &quot;选择2&quot;, &quot;选择3&quot;, &quot;选择4&quot; },
                            new DialogInterface.OnClickListener() {

                                @Override
                                public void onClick(DialogInterface dialog,
                                        int which) {
                                    Toast.makeText(MyContentActivity.this,
                                            which + &quot;&quot;, Toast.LENGTH_SHORT)
                                            .show();

                                }
                            }).show();
</code></pre><h3 id="u5B9A_u4E49ProgressBar"><a href="#u5B9A_u4E49ProgressBar" class="headerlink" title="定义ProgressBar"></a>定义ProgressBar</h3><pre><code>&lt;ProgressBar
        android:id=&quot;@+id/mProgress&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;          
        android:indeterminateDrawable=&quot;@drawable/progress_rotate&quot; /&gt;
</code></pre><p>progress_rotate：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt;
    &lt;item&gt;
        &lt;rotate
            android:drawable=&quot;@drawable/progressbar&quot;
            android:duration=&quot;300&quot;
            android:fromDegrees=&quot;0.0&quot;
            android:pivotX=&quot;50.0%&quot;
            android:pivotY=&quot;50.0%&quot;
            android:toDegrees=&quot;360.0&quot; /&gt;
    &lt;/item&gt;
&lt;/layer-list&gt;
</code></pre><h3 id="u5E7B_u706F_u7247_u6548_u679C"><a href="#u5E7B_u706F_u7247_u6548_u679C" class="headerlink" title="幻灯片效果"></a>幻灯片效果</h3><p>xml</p>
<pre><code>&lt;ProgressBar
        android:id=&quot;@+id/ProgressBar01&quot;
        style=&quot;@style/animStyle&quot;
        android:layout_width=&quot;fill_parent&quot;
        android:layout_height=&quot;fill_parent&quot;
        android:layout_centerInParent=&quot;true&quot; /&gt;
</code></pre><p>style</p>
<pre><code>&lt;style name=&quot;animStyle&quot; parent=&quot;@android:style/Widget.ProgressBar.Large&quot;&gt;
        &lt;item name=&quot;android:indeterminateDrawable&quot;&gt;@anim/test&lt;/item&gt;
&lt;/style&gt;
</code></pre><p>anim</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:oneshot=&quot;false&quot; &gt;

    &lt;item
        android:drawable=&quot;@drawable/t1&quot;
        android:duration=&quot;500&quot;/&gt;
    &lt;item
        android:drawable=&quot;@drawable/t2&quot;
        android:duration=&quot;500&quot;/&gt;
    &lt;item
        android:drawable=&quot;@drawable/t3&quot;
        android:duration=&quot;500&quot;/&gt;
    &lt;item
        android:drawable=&quot;@drawable/t4&quot;
        android:duration=&quot;500&quot;/&gt;
    &lt;item
        android:drawable=&quot;@drawable/t5&quot;
        android:duration=&quot;500&quot;/&gt;

&lt;/animation-list&gt;
</code></pre><h3 id="MD5_u52A0_u5BC6"><a href="#MD5_u52A0_u5BC6" class="headerlink" title="MD5加密"></a>MD5加密</h3><pre><code>public String Md5(String plainText) {
        String result = &quot;&quot;;
        try {
            MessageDigest md = MessageDigest.getInstance(&quot;MD5&quot;);
            md.update(plainText.getBytes());
            byte b[] = md.digest();

            int i;

            StringBuffer buf = new StringBuffer(&quot;&quot;);
            for (int offset = 0; offset &lt; b.length; offset++) {
                i = b[offset];
                if (i &lt; 0)
                    i += 256;
                if (i &lt; 16)
                    buf.append(&quot;0&quot;);
                buf.append(Integer.toHexString(i));
            }
            result = buf.toString().toUpperCase();// 32位的加密（转成大写）

            buf.toString().substring(8, 24);// 16位的加密

        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
        return result;
    }
</code></pre><h3 id="u8BBE_u7F6E_u81EA_u52A8_u8DF3_u8F6C_u9875_u9762"><a href="#u8BBE_u7F6E_u81EA_u52A8_u8DF3_u8F6C_u9875_u9762" class="headerlink" title="设置自动跳转页面"></a>设置自动跳转页面</h3><p>Timer</p>
<pre><code>Timer timer = new Timer();
        timer.schedule(new TimerTask() {
            @Override
            public void run() {
                // TODO Auto-generated method stub
                Intent goIntent = new Intent();
                goIntent.setClass(LauncherActivity.this, DemoActivity.class);
                startActivity(goIntent);
            }
        }, 3 * 1000);
    }
</code></pre><h3 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h3><pre><code>new Handler().postDelayed(new Runnable() {
            @Override
            public void run() {
                startActivity(new Intent(SplashScreen.this,
                        DomobSampleActivity.class));
                finish();
            }
        }, 1000);
</code></pre><h3 id="u968F_u673A_u53D6_u6570"><a href="#u968F_u673A_u53D6_u6570" class="headerlink" title="随机取数"></a>随机取数</h3><pre><code>List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
        for (int i = 0; i &lt; 10; i++) {
            list.add(i);
        }
        Collections.shuffle(list);
        for (int v : list) {
            Log.d(&quot;wxl&quot;, &quot;V===&quot; + v);
        }
</code></pre><p>或：</p>
<pre><code>Random random = new Random();
int ran = random.nextInt(keywordsList.size());
String tmp = keywordsList.get(ran).get(&quot;keyword&quot;).toString();
</code></pre><h3 id="selector_u4E0B_u7684_u5C5E_u6027_u503C"><a href="#selector_u4E0B_u7684_u5C5E_u6027_u503C" class="headerlink" title="selector下的属性值"></a>selector下的属性值</h3><pre><code>android:state_pressed
如果是true，当被点击时显示该图片，如果是false没被按下时显示默认。
android:state_focused
true，获得焦点时显示；false，没获得焦点显示默认。
android:state_selected
true，当被选择时显示该图片；false，当未被选择时显示该图片。
android:state_checkable
true，当 能使用时显示该图片；false，当CheckBox不能使用时显示该图片。
android:state_checked
true，当CheckBox选中时显示该图片；false，当CheckBox为选中时显示该图片。
android:state_enabled
true，当该组件能使用时显示该图片；false，当该组件不能使用时显示该图片。
android:state_window_focused
true，当此activity获得焦点在最前面时显示该图片；false，当没在最前面时显示该图片。


&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
    &lt;item android:state_pressed=&quot;true&quot;
        android:drawable=&quot;@drawable/button_pressed&quot;/&gt;&lt;!-- pressed --&gt;
    &lt;item android:state_focused=&quot;true&quot;
        android:drawable=&quot;@drawable/button_focused&quot;/&gt;&lt;!-- focused --&gt;
    &lt;item android:drawable=&quot;@drawable/button_normal&quot;/&gt;&lt;!-- default --&gt;
&lt;/selector&gt;
</code></pre><h3 id="u5E26_u4E0B_u5212_u7EBF_u7684EditText"><a href="#u5E26_u4E0B_u5212_u7EBF_u7684EditText" class="headerlink" title="带下划线的EditText"></a>带下划线的EditText</h3><pre><code>public class LinedEditText extends EditText {
    private Paint linePaint;
    private float margin;
    private int paperColor;

    public LinedEditText(Context paramContext, AttributeSet paramAttributeSet) {
        super(paramContext, paramAttributeSet);
        this.linePaint = new Paint();
    }
    @Override
    protected void onDraw(Canvas paramCanvas) {
        paramCanvas.drawColor(this.paperColor);
        int i = getLineCount();// 得到总的行數
        int j = getHeight();// 获得TextView的高度
        int k = getLineHeight();// 获得TextView的行高
        int m = j / k + 1;// 总的线数
        if (i &lt; m)
            i = m;
        int n = getCompoundPaddingTop();
        Log.d(&quot;wxl&quot;, &quot;n----&quot; + n);
        paramCanvas.drawLine(0.0F, n, getRight(), n, this.linePaint);
        for (int i2 = 0;; i2++) {
            if (i2 &gt;= i) {
                setPadding(10 + (int) this.margin, 0, 0, 0);
                super.onDraw(paramCanvas);
                paramCanvas.restore();
                return;
            }
            n += k;
            paramCanvas.drawLine(0.0F, n, getRight(), n, this.linePaint);
            paramCanvas.save();
        }
    }
}
</code></pre><p>主要工作就是重载onDraw方法，利用从TextView继承下来的getLineCount函数获取文本所占的行数，以及getLineBounds来获取特定行的基准高度值，而且这个函数第二个参数会返回此行的“外包装”值。再利用这些值绘制这一行的线条。为了让界面的View使用自定义的EditText类，必须在配置文件中进行设置</p>
<h3 id="u5173_u95ED_u952E_u76D8"><a href="#u5173_u95ED_u952E_u76D8" class="headerlink" title="关闭键盘"></a>关闭键盘</h3><pre><code>public static void hideSoftInput(Activity activity) {
        if (activity.getCurrentFocus() != null)
            ((InputMethodManager) activity
                    .getSystemService(Context.INPUT_METHOD_SERVICE))
                    .hideSoftInputFromWindow(activity.getCurrentFocus()
                            .getWindowToken(), InputMethodManager.HIDE_NOT_ALWAYS);
    }
</code></pre><p>界面不被弹出的键盘盖住<br>一进入activity就弹出键盘</p>
<pre><code>android:windowSoftInputMode=&quot;adjustResize&quot; 
android:windowSoftInputMode=&quot;adjustPan|stateAlwaysVisible&quot;
</code></pre><p>第一个软键盘和输入框会完全分离，而第二个输入框还是会被软键盘盖住一点点<br>而且第二个要把两个属性叠加起来，为什么要叠加起来呢，因为如果只用adjustPan 的话需要点击输入框才会弹出软键盘</p>
<p>在 AndroidMainfest.xml中选择哪个activity，设置windowSoftInputMode属性为</p>
<pre><code>adjustUnspecified|stateHidden
android:windowSoftInputMode=&quot;adjustUnspecified|stateHidden&quot;
</code></pre><h3 id="windowSoftInputMode_u5404_u503C_u7684_u542B_u4E49_uFF1A"><a href="#windowSoftInputMode_u5404_u503C_u7684_u542B_u4E49_uFF1A" class="headerlink" title="windowSoftInputMode各值的含义："></a>windowSoftInputMode各值的含义：</h3><pre><code>stateUnspecified：软键盘的状态并没有指定，系统将选择一个合适的状态或依赖于主题的设置
stateUnchanged：当这个activity出现时，软键盘将一直保持在上一个activity里的状态，无论是隐藏还是显示
stateHidden：用户选择activity时，软键盘总是被隐藏
stateAlwaysHidden：当该Activity主窗口获取焦点时，软键盘也总是被隐藏的
stateVisible：软键盘通常是可见的
stateAlwaysVisible：用户选择activity时，软键盘总是显示的状态
adjustUnspecified：默认设置，通常由系统自行决定是隐藏还是显示
adjustResize：该Activity总是调整屏幕的大小以便留出软键盘的空间
adjustPan：当前窗口的内容将自动移动以便当前焦点从不被键盘覆盖和用户能总是看到输入内容的部分
</code></pre><h3 id="u63A7_u4EF6_u7F8E_u5316Shape"><a href="#u63A7_u4EF6_u7F8E_u5316Shape" class="headerlink" title="控件美化Shape"></a>控件美化Shape</h3><p><a href="http://wuxiaolong.me/2013/07/09/shape/" target="_blank" rel="external">http://wuxiaolong.me/2013/07/09/shape/</a></p>
<h3 id="u83B7_u53D6_u7248_u672C_u540D_u79F0_VersionName"><a href="#u83B7_u53D6_u7248_u672C_u540D_u79F0_VersionName" class="headerlink" title="获取版本名称 VersionName"></a>获取版本名称 VersionName</h3><pre><code>public String getVersionName(Context context) {
        PackageManager manager = context.getPackageManager();
        String packageName = context.getPackageName();
        try {
            PackageInfo info = manager.getPackageInfo(packageName, 0);
            return info.versionName;
        } catch (NameNotFoundException e) {
            return &quot;1.0&quot;;
        }
    }
</code></pre><h3 id="u83B7_u53D6Android_u624B_u673A_u8BBE_u5907_u7684IMSI_/_IMEI__u4FE1_u606F"><a href="#u83B7_u53D6Android_u624B_u673A_u8BBE_u5907_u7684IMSI_/_IMEI__u4FE1_u606F" class="headerlink" title="获取Android手机设备的IMSI / IMEI 信息"></a>获取Android手机设备的IMSI / IMEI 信息</h3><pre><code>TelephonyManager mTelephonyMgr = (TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE);
String imsi = mTelephonyMgr.getSubscriberId(); 
String imei = mTelephonyMgr.getDeviceId(); 
Log.i(&quot;wxl&quot;, &quot;imsi=&quot;+imsi);为null
Log.i(&quot;wxl&quot;, &quot;imei=&quot;+imei); 
</code></pre><p> 另外不要忘了在AndroidManifest.xml中加上读取手机状态的权限</p>
<pre><code>&lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot;/&gt;
</code></pre><h3 id="u81EA_u5B9A_u4E49Log_u662F_u5426_u663E_u793A"><a href="#u81EA_u5B9A_u4E49Log_u662F_u5426_u663E_u793A" class="headerlink" title="自定义Log是否显示"></a>自定义Log是否显示</h3><pre><code>public class Log {
    private static final String TAG = &quot;wxl&quot;;
    private static final boolean LOG = true;
    public static void i(String msg) {
        if (LOG)
            android.util.Log.i(TAG , msg);
    }
    public static void d(String msg) {
        if (LOG)
            android.util.Log.d(TAG , msg);
    }
    public static void w(String msg) {
        if (LOG)
            android.util.Log.w(TAG , msg);
    }
    public static void w(String msg, Throwable throwable) {
        if (LOG)
            android.util.Log.w(TAG , msg, throwable);
    }
    public static void v(String msg) {
        if (LOG)
            android.util.Log.v(TAG , msg);
    }
    public static void e(String msg) {
        android.util.Log.e(TAG , msg);
    }
    public static void e(String msg, Throwable throwable) {
        android.util.Log.e(TAG , msg, throwable);
    }
}
</code></pre><h3 id="u5F02_u6B65_u64CD_u4F5CAsyncTask"><a href="#u5F02_u6B65_u64CD_u4F5CAsyncTask" class="headerlink" title="异步操作AsyncTask"></a>异步操作AsyncTask</h3><pre><code>//参数1：向后台任务的执行方法传递参数的类型 ； 
//参数2：在后台任务执行过程中，要求主UI线程处理中间状态，通常是一些UI处理中传递的参数类型；
//参数3：后台任务执行完返回时的参数类型。
private class MyAsyncTask extends AsyncTask&lt;Integer, String, Void&gt; {

        // 实现抽象方法doInBackground()，代码将在后台线程中执行，由execute()触发
        protected Void doInBackground(Integer... params) {
            return null;
        }

        // 任务启动，可以在这里显示一个对话框，这里简单处理
        protected void onPreExecute() {
            super.onPreExecute();
        }

        // 取消
        protected void onCancelled() {
            super.onCancelled();
        }

        // 定义后台进程执行完后的处理
        protected void onPostExecute(Void result) {
            super.onPostExecute(result);
            Toast.makeText(MainActivity.this, &quot;OK&quot;, Toast.LENGTH_SHORT).show();
        }

        // 更新进度,在UI主线程执行的内容，将item加入list中。方法中的参数为范式方式，实质为数组，由于我们只传递了item一个String，要获取，为values[0]
        protected void onProgressUpdate(String... values) {
            super.onProgressUpdate(values);
        }

    }
</code></pre><p>调用：</p>
<pre><code>new MyAsyncTask().execute(参数1);// 创建后台任务的对象
</code></pre><p>检查网络状态</p>
<pre><code>public boolean checkNetworkInfo() {
        ConnectivityManager conMan = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);
        // mobile 3G Data Network
        State mobile = conMan.getNetworkInfo(ConnectivityManager.TYPE_MOBILE)
                .getState();
        // wifi
        State wifi = conMan.getNetworkInfo(ConnectivityManager.TYPE_WIFI)
                .getState();
        // 如果3G网络和wifi网络都未连接，且不是处于正在连接状态 则进入Network Setting界面 由用户配置网络连接
        if (mobile == State.CONNECTED || mobile == State.CONNECTING)
            return true;
        if (wifi == State.CONNECTED || wifi == State.CONNECTING)
            return true;
        AlertDialog.Builder builder = new AlertDialog.Builder(this);
        builder.setMessage(getResources().getString(R.string.no_network))
                .setCancelable(false)
                .setPositiveButton(
                        getResources().getString(R.string.configuration),
                        new DialogInterface.OnClickListener() {
                            public void onClick(DialogInterface dialog, int id) {

                                // 进入无线网络配置界面
                                startActivity(new Intent(
                                        Settings.ACTION_WIRELESS_SETTINGS));
                                MainActivity.this.finish();
                            }
                        })
                .setNegativeButton(getResources().getString(R.string.quit),
                        new DialogInterface.OnClickListener() {
                            public void onClick(DialogInterface dialog, int id) {
                                MainActivity.this.finish();
                            }
                        });
        builder.show();
        return false;
    }
</code></pre><p>代码判断调用：</p>
<pre><code>// 检查网络状态
if (!checkNetworkInfo()) {
    return;
}
</code></pre><h3 id="u8BA9_u6570_u636E_u63A5_u53D7_u7F51_u9875_u7684_u683C_u5F0F"><a href="#u8BA9_u6570_u636E_u63A5_u53D7_u7F51_u9875_u7684_u683C_u5F0F" class="headerlink" title="让数据接受网页的格式"></a>让数据接受网页的格式</h3><pre><code>Html.fromHtml（）

URLEncoder.encode(String s); 网址请求中文解析
&amp;#8230;代表省略号
URLEncoder.encode
网址请求带中文

URLEncoder.encode(content, &quot;utf-8&quot;)
</code></pre><p>Android中字体加粗<br>在xml文件中使用</p>
<pre><code>android:textStyle=”bold”
</code></pre><p>Java 代码<br>（网上查XML不能将中文设置成粗体，只能通过Java code。Android 2.2 可以通过XML将中文设置成粗体）</p>
<pre><code>TextView tv = (TextView)findViewById(R.id.TextView01); 
TextPaint tp = tv.getPaint();
tp.setFakeBoldText(true);
Html.fromHtml(“\&lt;\b&gt;”)


(1)viewHolder.title.setText(Html.fromHtml(&quot;&lt;b&gt;&quot;+ listTitle.get(position).get(&quot;title&quot;) + &quot;&lt;/b&gt;&quot;));
(2)TextView.setText(Html.fromHtml(&quot;&lt;font color=#FF0000&gt;hello&lt;/font&gt;&quot;));
</code></pre><h3 id="u4EE3_u7801_u8BBE_u7F6E_u80CC_u666F_u56FEsetImageResource/setBackgroundResource"><a href="#u4EE3_u7801_u8BBE_u7F6E_u80CC_u666F_u56FEsetImageResource/setBackgroundResource" class="headerlink" title="代码设置背景图setImageResource/setBackgroundResource"></a>代码设置背景图setImageResource/setBackgroundResource</h3><pre><code>textView.setBackgroundResource(R.drawable.bg_menu_1);设置背景图片
textView.setBackgroundColor(0xffffffff);
setImageResource與xml中的src的屬性才是相匹配的，而setBackgroundResource是與xml中的background屬性相匹配
的
holder.chat_sound_iv_right.setBackgroundResource(0);//没有图片
</code></pre><h3 id="android_u4E2D_u7684ellipsize"><a href="#android_u4E2D_u7684ellipsize" class="headerlink" title="android中的ellipsize"></a>android中的ellipsize</h3><p>用法如下：<br>在xml中</p>
<pre><code>android:ellipsize = &quot;end&quot;　　  省略号在结尾
android:ellipsize = &quot;start&quot; 　　省略号在开头
android:ellipsize = &quot;middle&quot;     省略号在中间
android:ellipsize = &quot;marquee&quot;  跑马灯
</code></pre><p>最好加一个约束android:singleline = “true”<br>跑马灯</p>
<pre><code>android:singleLine=&quot;true&quot;
android:ellipsize=&quot;marquee&quot;
android:focusableInTouchMode=&quot;true&quot;
android:focusable=&quot;true&quot;
android:marqueeRepeatLimit=&quot;marquee_forever&quot;
android:singleLine=true 表示使用单行文字，多行文字也就无所谓使用Marquee效果了。
android:marqueeRepeatLimit，设置走马灯滚动的次数。
android:ellipsize，设置了文字过长时如何切断文字，可以有none, start,middle, end, 如果使用走马灯效果则设为marquee.
android:focusable，Android的缺省行为是在控件获得Focus时才会显示走马灯效果
</code></pre><p>###控件点击效果</p>
<pre><code>&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
    &lt;item android:state_focused=&quot;true&quot; android:state_pressed=&quot;false&quot; android:drawable=&quot;@drawable/professional_1&quot;/&gt;
    &lt;item android:state_focused=&quot;false&quot; android:state_pressed=&quot;true&quot; android:drawable=&quot;@drawable/professional_1&quot;/&gt;
    &lt;item android:drawable=&quot;@drawable/professional&quot;/&gt;
&lt;/selector&gt;
</code></pre><p>###保留小数点<br>方法一：</p>
<pre><code>private DecimalFormat df;
df = new DecimalFormat(&quot;0.0&quot;);
float data;
df.format(data);//返回值
</code></pre><p>方法二：</p>
<pre><code>double juli = 1569;
String result = String.format(&quot;%.1f&quot;, juli/1000);
</code></pre><h3 id="RadioGroup"><a href="#RadioGroup" class="headerlink" title="RadioGroup"></a>RadioGroup</h3><pre><code>&lt;RadioGroup
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:orientation=&quot;vertical&quot; &gt;

    &lt;RadioButton
        android:id=&quot;@+id/open&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_marginLeft=&quot;10dip&quot;
        android:layout_marginTop=&quot;10dip&quot;
        android:button=&quot;@drawable/radiobutton&quot;
        android:checked=&quot;true&quot;
        android:text=&quot;@string/open_album&quot;
        android:textColor=&quot;#000000&quot;
        android:textSize=&quot;16dip&quot; /&gt;

    &lt;RadioButton
        android:id=&quot;@+id/secrecy&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_marginLeft=&quot;10dip&quot;
        android:button=&quot;@drawable/radiobutton&quot;
        android:text=&quot;@string/secrecy_album&quot;
        android:textColor=&quot;#000000&quot;
        android:textSize=&quot;16dip&quot; /&gt;
&lt;/RadioGroup&gt;
</code></pre><p>android:button=”@null” 去除RadioButton前面的圆点<br>android:background=”@drawable/radio” 使用定义的样式</p>
<h3 id="u5360_u4F4D_u7B26_25s_u66FF_u6362"><a href="#u5360_u4F4D_u7B26_25s_u66FF_u6362" class="headerlink" title="占位符%s替换"></a>占位符%s替换</h3><pre><code>%d （表示整数）
%f （表示浮点数）
%s （表示字符串）
</code></pre><p>txt.setText(String.format (“被替换%1$s”,”替换内容”));</p>
<h3 id="TextView_u4E2D_u5D4C_u5957_u56FE_u7247Drawable"><a href="#TextView_u4E2D_u5D4C_u5957_u56FE_u7247Drawable" class="headerlink" title="TextView中嵌套图片Drawable"></a>TextView中嵌套图片Drawable</h3><pre><code>Drawable drawable = getResources().getDrawable(R.drawable.ji_dot_nor);
drawable.setBounds(0, 0, drawable.getIntrinsicWidth(),drawable.getIntrinsicHeight());
textView.setCompoundDrawablesWithIntrinsicBounds(null, drawable, null, null); 
</code></pre><p>说明：<code>setCompoundDrawablesWithIntrinsicBounds(left, top, right, bottom)</code><br>意思是设置Drawable显示在text的左、上、右、下位置。(Textview、Button都可以)</p>
<p>TextView做成分割线</p>
<pre><code>&lt;TextView
    android:id=&quot;@id/textView2&quot;
    android:layout_width=&quot;fill_parent&quot;
    android:layout_height=&quot;2.0px&quot;
android:background=&quot;@color/orange&quot; /&gt;
</code></pre><h3 id="SpannableString_u5355_u51FB_u6587_u5B57_u94FE_u63A5"><a href="#SpannableString_u5355_u51FB_u6587_u5B57_u94FE_u63A5" class="headerlink" title="SpannableString单击文字链接"></a>SpannableString单击文字链接</h3><pre><code>SpannableString spannableString = new SpannableString(str);
        spannableString.setSpan(new ClickableSpan() {
            public void onClick(View view) {
                // Intent intent = new Intent(ApkTest.this, Apk.class);
                Intent intent = new Intent(Intent.ACTION_CALL, Uri.parse(&quot;tel:&quot;
                        + &quot;15261589767&quot;));
                startActivity(intent);
            }
        }, 0, str.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        TextView.setText(spannableString);
        TextView.setMovementMethod(LinkMovementMethod.getInstance());
</code></pre><p>TextView中文字通过SpannableString来设置超链接、颜色、字体等属性</p>
<pre><code>String  title =”123456”;
SpannableString titleStr = new SpannableString(title);
titleStr.setSpan(new ForegroundColorSpan(Color.RED), 0,
                        titleStr.length(), 0);
textView.setText(titleStr);
</code></pre><h3 id="android_3AdrawableTop_u5C5E_u6027"><a href="#android_3AdrawableTop_u5C5E_u6027" class="headerlink" title="android:drawableTop属性"></a>android:drawableTop属性</h3><pre><code>写在TextView里，实现图片+文字
</code></pre><h3 id="u83B7_u53D6_u5206_u8FA8_u7387"><a href="#u83B7_u53D6_u5206_u8FA8_u7387" class="headerlink" title="获取分辨率"></a>获取分辨率</h3><pre><code>DisplayMetrics displayMetrics = new DisplayMetrics();
getWindowManager().getDefaultDisplay().getMetrics(displayMetrics);

displayMetrics.widthPixels + &quot;x&quot;+ displayMetrics.heightPixels;
</code></pre><h3 id="u4EE3_u7801_u5B8C_u6210_u63A7_u4EF6"><a href="#u4EE3_u7801_u5B8C_u6210_u63A7_u4EF6" class="headerlink" title="代码完成控件"></a>代码完成控件</h3><p>Button</p>
<pre><code>linearLayout = (LinearLayout) findViewById(R.id.linearLayout2);
LayoutParams layoutParams = new LinearLayout.LayoutParams(0,
                LinearLayout.LayoutParams.WRAP_CONTENT, 1);//1均分属性
layoutParams.setMargins(10, 10, 10, 10);

Button button = new Button(MainActivity.this);
button.setLayoutParams(layoutParams);
linearLayout.addView(button);
</code></pre><p>TextView</p>
<pre><code>private TextView overlay;
private void initOverlay() {
        LayoutInflater inflater = LayoutInflater.from(this);
        overlay = (TextView) inflater.inflate(R.layout.overlay, null);
        overlay.setVisibility(View.INVISIBLE);
        WindowManager.LayoutParams lp = new WindowManager.LayoutParams(
                LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT,
                WindowManager.LayoutParams.TYPE_APPLICATION,
                WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE
                        | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE,
                PixelFormat.TRANSLUCENT);
        WindowManager windowManager = (WindowManager) this
                .getSystemService(Context.WINDOW_SERVICE);
        windowManager.addView(overlay, lp);
    }
</code></pre><p> xml：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;TextView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:background=&quot;#ffffff&quot;
    android:gravity=&quot;center&quot;
    android:maxWidth=&quot;80dip&quot;
    android:minWidth=&quot;80dip&quot;
    android:padding=&quot;5dip&quot;
    android:textColor=&quot;#3399ff&quot;
    android:textSize=&quot;70sp&quot; /&gt;
</code></pre><p>代码：</p>
<pre><code>private LinearLayout.LayoutParams layoutParams = null;
        private LinearLayout.LayoutParams btnParmas;

layoutParams = new LinearLayout.LayoutParams(
                            LinearLayout.LayoutParams.WRAP_CONTENT,
                            LinearLayout.LayoutParams.WRAP_CONTENT);
                    layoutParams.setMargins(
                            (int) getResources().getDimension(
                                    R.dimen.lable_left), 0, 0, 0);
                    btnParmas = new LinearLayout.LayoutParams(
                            LinearLayout.LayoutParams.WRAP_CONTENT,
                            (int) getResources().getDimension(
                                    R.dimen.lable_height));

                    for (int i = 0; i &lt; lables.length; i++) {
                        LinearLayout linearLayout = new LinearLayout(activity);
                        lableColor = random.nextInt(lableColors.length);
                        Button lable = new Button(activity);
                        lable.setText(lables[i]);
                        lable.setGravity(Gravity.CENTER_HORIZONTAL
                                | Gravity.CENTER_VERTICAL);
                        lable.setTextSize(getResources().getDimension(
                                R.dimen.lable));
                        lable.setTextColor(getResources().getColor(
                                R.color.white));
                        lable.setBackgroundResource(lableColors[i]);
                        linearLayout.addView(lable, btnParmas);
                        holder.play_lables.addView(linearLayout, layoutParams);
                    }
</code></pre><h3 id="TextWatcher"><a href="#TextWatcher" class="headerlink" title="TextWatcher"></a>TextWatcher</h3><pre><code>editText1.addTextChangedListener(watcher);
TextWatcher watcher = new TextWatcher() {
        public void onTextChanged(CharSequence arg0, int arg1, int arg2,
                int arg3) {
        }
        public void beforeTextChanged(CharSequence arg0, int arg1, int arg2,
                int arg3) {
        }
        public void afterTextChanged(Editable arg0) {            
        }
    };
</code></pre><h3 id="u5C4F_u5E55_u65CB_u8F6C_u65F6_u4E0D_u9500_u6BC1"><a href="#u5C4F_u5E55_u65CB_u8F6C_u65F6_u4E0D_u9500_u6BC1" class="headerlink" title="屏幕旋转时不销毁"></a>屏幕旋转时不销毁</h3><p>AndroidManifest加入</p>
<pre><code>android:configChanges=&quot;orientation|keyboardHidden&quot;
</code></pre><p>###获取屏幕方向</p>
<pre><code>Configuration newConfig = getResources().getConfiguration();    
        if (newConfig.orientation == Configuration.ORIENTATION_LANDSCAPE){    
            //横屏    
        }else if(newConfig.orientation == Configuration.ORIENTATION_PORTRAIT){    
            //竖屏    
        }else if(newConfig.hardKeyboardHidden == Configuration.KEYBOARDHIDDEN_NO){    
            //键盘没关闭。屏幕方向为横屏    
        }else if(newConfig.hardKeyboardHidden == Configuration.KEYBOARDHIDDEN_YES){    
            //键盘关闭。屏幕方向为竖屏    
        }
</code></pre><h3 id="List_u589E_u52A0_u6570_u636E"><a href="#List_u589E_u52A0_u6570_u636E" class="headerlink" title="List增加数据"></a>List增加数据</h3><p>简单</p>
<pre><code>private List&lt;String&gt; getData() {
        List&lt;String&gt; data = new ArrayList&lt;String&gt;();
        data.add(&quot;123&quot;);
        data.add(&quot;345&quot;);
        data.add(&quot;456&quot;);
        data.add(&quot;567&quot;);
        return data;
    }
</code></pre><p>键值对</p>
<pre><code>private List&lt;Map&lt;String, Object&gt;&gt; getData() {
        List&lt;Map&lt;String, Object&gt;&gt; list = new ArrayList&lt;Map&lt;String, Object&gt;&gt;();

        Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();
        map.put(&quot;title&quot;, &quot;G1&quot;);
        map.put(&quot;info&quot;, &quot;google 1&quot;);
        map.put(&quot;img&quot;, R.drawable.i1);
        list.add(map);

        map = new HashMap&lt;String, Object&gt;();
        map.put(&quot;title&quot;, &quot;G2&quot;);
        map.put(&quot;info&quot;, &quot;google 2&quot;);
        map.put(&quot;img&quot;, R.drawable.i2);
        list.add(map);

        map = new HashMap&lt;String, Object&gt;();
        map.put(&quot;title&quot;, &quot;G3&quot;);
        map.put(&quot;info&quot;, &quot;google 3&quot;);
        map.put(&quot;img&quot;, R.drawable.i3);
        list.add(map);

        return list;
    }
</code></pre><p>清除数据：</p>
<pre><code>data.clear();
listView.setAdapter(new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_expandable_list_item_1,getData()));
</code></pre><p>LinkedList</p>
<pre><code>LinkedList&lt;String&gt; list = new LinkedList&lt;String&gt;();
list.addFirst(&quot;000&quot;);
</code></pre><h3 id="u9A8C_u8BC1_u662F_u5426_u624B_u673A_u53F7_u7801"><a href="#u9A8C_u8BC1_u662F_u5426_u624B_u673A_u53F7_u7801" class="headerlink" title="验证是否手机号码"></a>验证是否手机号码</h3><pre><code>public boolean isMobileNO(String mobiles) {
        String expression = &quot;((^(13|15|18)[0-9]{9}$)|(^0[1,2]{1}\\d{1}-?\\d{8}$)|(^0[3-9] {1}\\d{2}-?\\d{7,8}$)|(^0[1,2]{1}\\d{1}-?\\d{8}-(\\d{1,4})$)|(^0[3-9]{1}\\d{2}-? \\d{7,8}-(\\d{1,4})$))&quot;;
        Pattern pattern = Pattern.compile(expression);
        Matcher matcher = pattern.matcher(mobiles);
        Log.d(&quot;wxl&quot;, matcher.matches() + &quot;&quot;);
        return matcher.matches();
    }
</code></pre><p>正则表达式数字验证</p>
<pre><code>public boolean isNumber(String str)
    {
        java.util.regex.Pattern pattern=java.util.regex.Pattern.compile(&quot;[0-9]*&quot;);
        java.util.regex.Matcher match=pattern.matcher(str);
        if(match.matches()==false)
        {
            return false;
        }
        else
        {
            return true;
        }
    }
</code></pre><h3 id="SharedPreferences"><a href="#SharedPreferences" class="headerlink" title="SharedPreferences"></a>SharedPreferences</h3><p>SharedPreferences存数据</p>
<pre><code>SharedPreferences sharedPreferences = getSharedPreferences(&quot;test&quot;, Context.MODE_PRIVATE);
Editor editor = sharedPreferences.edit();//获取编辑器
editor.putString(&quot;name&quot;, &quot;张三&quot;);
editor.putInt(&quot;age&quot;, 24);
editor.putBoolean(&quot;AutoLogin&quot;, false);
editor.commit();//提交修改
</code></pre><p>SharedPreferences取数据</p>
<pre><code>SharedPreferences sharedPreferences = getSharedPreferences(&quot;test&quot;, Context.MODE_PRIVATE);
//getString()第二个参数为缺省值,如果preference中不存在该key,将返回缺省值
String name = sharedPreferences.getString(&quot;name&quot;, &quot;&quot;);
int age = sharedPreferences.getInt(&quot;age&quot;, 1);
boolean autoLogin= sharedPreferences. getBoolean(&quot;AutoLogin&quot;, false);
</code></pre><h3 id="Intent__u4F20_u503C"><a href="#Intent__u4F20_u503C" class="headerlink" title="Intent 传值"></a>Intent 传值</h3><p>简单传值<br>ActivityPage</p>
<pre><code>Intent intent = new Intent(ActivityPage.this, Player.class);
            //保存信息
            Bundle mBundle = new Bundle();
            mBundle.putString(&quot;realname &quot;, realname);
            intent.putExtras(mBundle);
</code></pre><p>Player接受</p>
<pre><code>realname = this.getIntent().getStringExtra(&quot;realname&quot;);
Intent intent = new Intent();
intent.setClass(HomeActivity.this, CompanyActivity.class);
intent.putExtra(&quot;mCompanySupply&quot;, mCompanySupply);
                startActivity(intent);
CompanyActivity.class:
ArrayList&lt;ClassifySub3Bean&gt;  mCompanySupply = (ArrayList&lt;ClassifySub3Bean&gt;) getIntent()
                .getSerializableExtra(&quot;mCompanySupply&quot;);
</code></pre><p>复杂传值<br>A页面：</p>
<pre><code>private static final int REQUEST_CODE_A = 0;
private static final int RESULT_CODE_B = 0;
Intent intent = new Intent();
                Bundle bundle = new Bundle();
                intent.setClass(MainActivity.this, TestBActivity.class);
                bundle.putString(&quot;msg&quot;, textView.getText().toString());
                intent.putExtras(bundle);
                startActivityForResult(intent, REQUEST_CODE_A);

protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        if (requestCode == REQUEST_CODE_A &amp;&amp; resultCode == RESULT_OK) {
            String str=data.getExtras().getString(&quot;result&quot;);
        }
    }
</code></pre><p>B页面</p>
<pre><code>private static final int RESULT_CODE_B = 0;

Intent intent = new Intent();
                intent.putExtra(&quot;result&quot;, textView.getText().toString());
                setResult(RESULT_OK, intent);
                finish();

public boolean onKeyDown(int keyCode, KeyEvent event) {
        if (keyCode == KeyEvent.KEYCODE_BACK) {
            Intent intent = new Intent();
            intent.putExtra(&quot;result&quot;, &quot;直接返回&quot;);
            setResult(RESULT_OK, intent);
            this.finish();
            return true;
        } else {
            return super.onKeyDown(keyCode, event);
        }
    }
</code></pre><p>List</p>
<pre><code>Intent intent = new Intent();
                    intent.putStringArrayListExtra(&quot;mSelectedPhotos&quot;,
                            mSelectedPhotos);
                    setResult(RESULT_OK, intent);


                    ArrayList&lt;String&gt; mSelectedPhotos = (ArrayList&lt;String&gt;) intent
                        .getStringArrayListExtra(&quot;mSelectedPhotos&quot;);
</code></pre><h3 id="xml_u6587_u4EF6_u4E2D_u5BFC_u5165_u53E6_u4E00_u4E2Axml_u6587_u4EF6_u7684_u65B9_u6CD5include"><a href="#xml_u6587_u4EF6_u4E2D_u5BFC_u5165_u53E6_u4E00_u4E2Axml_u6587_u4EF6_u7684_u65B9_u6CD5include" class="headerlink" title="xml文件中导入另一个xml文件的方法include"></a>xml文件中导入另一个xml文件的方法include</h3><pre><code>&lt;include 
android:id=&quot;@+id/included1&quot;
layout=&quot;@layout/anotherlayout&quot; /&gt;
</code></pre><h3 id="u5355_u51FB_u8FD4_u56DE_u952E_u4E24_u6B21_u9000_u51FA"><a href="#u5355_u51FB_u8FD4_u56DE_u952E_u4E24_u6B21_u9000_u51FA" class="headerlink" title="单击返回键两次退出"></a>单击返回键两次退出</h3><pre><code>private static Boolean isExit = false;
        @Override
        public boolean onKeyDown(int keyCode, KeyEvent event) {
                if (keyCode == KeyEvent.KEYCODE_BACK) {
                        if (isExit == false) {
                                isExit = true;
                                Toast.makeText(this, &quot;再按一次退出程序&quot;, Toast.LENGTH_SHORT).show();
                                new Timer().schedule(new TimerTask() {
                                        @Override
                                        public void run() {
                                                isExit = false;
                                        }
                                }, 2000);
                        } else {
                                finish();
                                System.exit(0);
                        }
                }
                return false;
        }
</code></pre><p>或者</p>
<pre><code>@Override 
public boolean onKeyUp(int keyCode, KeyEvent event) { 
    if (keyCode == KeyEvent.KEYCODE_BACK) { 
        long secondTime = System.currentTimeMillis(); 
        if (secondTime - firstTime &gt; 800) {//如果两次按键时间间隔大于800毫秒，则不退出 
            Toast.makeText(MainActivity.this, &quot;再按一次退出程序...&quot;, 
                    Toast.LENGTH_SHORT).show(); 
            firstTime = secondTime;//更新firstTime 
            return true; 
        } else { 
            System.exit(0);//否则退出程序 
        } 
    } 
    return super.onKeyUp(keyCode, event); 
}
</code></pre><h3 id="u56FE_u7247_u5DE6_u53F3_u5FAA_u73AF_u79FB_u52A8"><a href="#u56FE_u7247_u5DE6_u53F3_u5FAA_u73AF_u79FB_u52A8" class="headerlink" title="图片左右循环移动"></a>图片左右循环移动</h3><pre><code>TranslateAnimation left, right;
right = new TranslateAnimation(Animation.RELATIVE_TO_PARENT, -1f,
                Animation.RELATIVE_TO_PARENT, -2f,
                Animation.RELATIVE_TO_PARENT, 0f, Animation.RELATIVE_TO_PARENT,
                0f);
        left = new TranslateAnimation(Animation.RELATIVE_TO_PARENT, -2f,
                Animation.RELATIVE_TO_PARENT, -1f,
                Animation.RELATIVE_TO_PARENT, 0f, Animation.RELATIVE_TO_PARENT,
                0f);
        right.setDuration(25000);
        left.setDuration(25000);
        right.setFillAfter(true);
        left.setFillAfter(true);

        right.setAnimationListener(new Animation.AnimationListener() {
            @Override
            public void onAnimationStart(Animation animation) {
            }

            @Override
            public void onAnimationRepeat(Animation animation) {
            }

            @Override
            public void onAnimationEnd(Animation animation) {
                runImage.startAnimation(left);
            }
        });
        left.setAnimationListener(new Animation.AnimationListener() {
            @Override
            public void onAnimationStart(Animation animation) {
            }

            @Override
            public void onAnimationRepeat(Animation animation) {
            }

            @Override
            public void onAnimationEnd(Animation animation) {
                runImage.startAnimation(right);
            }
        });
        runImage.startAnimation(right);
</code></pre><h3 id="u63A7_u4EF6_u5DE6_u53F3_u6296_u52A8"><a href="#u63A7_u4EF6_u5DE6_u53F3_u6296_u52A8" class="headerlink" title="控件左右抖动"></a>控件左右抖动</h3><p>res下anim<br>animlayout.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;translate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:duration=&quot;1000&quot;
    android:fromXDelta=&quot;0&quot;
    android:interpolator=&quot;@anim/cycle_7&quot;
    android:toXDelta=&quot;10&quot; /&gt;
</code></pre><p>cycle_7.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;cycleInterpolator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
android:cycles=&quot;7&quot; /&gt;
</code></pre><p>(2)java代码</p>
<p>Animation shake = AnimationUtils.loadAnimation(<br>                        MainActivity.this, R.anim.animlayout);<br>                btn.setAnimation(shake);</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这份是我工作以来，总结的小知识库，有些知识点现在看来太LOW了，把还觉得有用的分享出来！</p>
<h3 id="Genymotion_u4E0B_u8F7D_u865A_u62DF_u955C_u50CFConnection_timeout"><a href="#Genymotion_u4E0B_u8F7D_u865A_u62DF_u955C_u50CFConnection_timeout" class="headerlink" title="Genymotion下载虚拟镜像Connection timeout"></a>Genymotion下载虚拟镜像Connection timeout</h3><p>Add new device出现的问题：</p>
<p>Failed to deploy virtual device.<br>Unable to create virtual device.Connection timeout occurred.</p>
<p>解决方案：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#24403;&#36873;&#25321;Google Nexus 5 - 6.0.0 - API 23 - 1080x1920&#19979;&#36733;device&#22833;&#36133;&#21518;&#65292;&#21040;C:\Users\&#29992;&#25143;&#20027;&#30446;&#24405;\AppData\Local\Genymobile\Genymotion\ova&#19979;&#30475;&#21040;genymotion_vbox86p_6.0_160114_090449.ova&#65292;&#22823;&#23567;&#21364;&#26159;0KB&#65292;&#22312;C:\Users\&#29992;&#25143;&#20027;&#30446;&#24405;\AppData\Local\Genymobile\genymotion.log&#65292;&#25171;&#24320;&#35813;&#25991;&#20214;&#65292;&#25214;&#21040;&#31867;&#20284;&#10;    &#10;    &#8220;http://files2.genymotion.com/dists/6.0.0/ova/genymotion_vbox86p_6.0_160114_090449.ova&#8221;&#36335;&#24452;&#65292;&#21363;&#24744;&#24819;&#35201;&#19979;&#36733;&#30340;&#38236;&#20687;&#25991;&#20214;URL&#65307;`&#10;&#10;&#29992;&#36805;&#38647;&#21435;&#19979;&#36733;&#65292;&#19979;&#36733;&#23436;&#25104;&#21518;&#25918;&#21040;C:\Users\&#29992;&#25143;&#20027;&#30446;&#24405;\AppData\Local\Genymobile\Genymotion\ova&#65307;&#10;&#37325;&#26032;&#28857;&#20987;Google Nexus 5 - 6.0.0 - API 23 - 1080x1920&#21435;&#19979;&#36733;&#65292;&#39564;&#35777;&#23433;&#35013;&#21518;&#21363;&#20250;&#26174;&#31034;&#22312;&#35774;&#22791;&#21015;&#34920;&#20013;&#12290;</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="知识库" scheme="http://kevinhero.github.io/tags/%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    
      <category term="技术" scheme="http://kevinhero.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Lambda for Android]]></title>
    <link href="http://kevinhero.github.io/2016/03/01/Android%20Skills/Lambda%20for%20Android/"/>
    <id>http://kevinhero.github.io/2016/03/01/Android Skills/Lambda for Android/</id>
    <published>2016-02-29T18:33:17.000Z</published>
    <updated>2016-04-06T04:28:28.000Z</updated>
    <content type="html"><![CDATA[<p>Lambda，它让代码看起来更加简洁，但个人认为代码的可读性差了很多，因此一直没有去深入学习。</p>
<h3 id="u4EC0_u4E48_u662Flambda"><a href="#u4EC0_u4E48_u662Flambda" class="headerlink" title="什么是lambda"></a>什么是lambda</h3><p>lambda是一种匿名表达式，retrolambda使得Android能使用lambda特性，举个例子：</p>
<pre><code>view.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View v) {
Log.d(&quot;wxl&quot;, &quot;retrolambda test&quot;);
}
});
</code></pre><p>使用 lambda</p>
<pre><code>view.setOnClickListener(
v -&gt; Log.d(&quot;wxl&quot;, &quot;retrolambda test&quot;));
</code></pre><h3 id="Android_u5982_u4F55_u4F7F_u7528"><a href="#Android_u5982_u4F55_u4F7F_u7528" class="headerlink" title="Android如何使用"></a>Android如何使用</h3><p>这里是使用Retrolambda的gradle插件，这样就可以在代码中使用lambda了。<br><a id="more"></a></p>
<h4 id="Android_Studio_u914D_u7F6ERetrolambda"><a href="#Android_Studio_u914D_u7F6ERetrolambda" class="headerlink" title="Android Studio配置Retrolambda"></a>Android Studio配置Retrolambda</h4><p>lambda需要安装JDK8，下载最新版本jdk-8u73</p>
<p>build.gradle</p>
<pre><code>buildscript {
    repositories {
             jcenter()
        }
        dependencies {
            classpath &apos;com.android.tools.build:gradle:1.5.0&apos;
            classpath &apos;me.tatarka:gradle-retrolambda:3.2.4&apos;//加上这句依赖，这会使用retrolambda来编译Java代码
    }
}
</code></pre><p>app/build.gradle</p>
<pre><code>apply plugin: &apos;com.android.application&apos;
apply plugin: &apos;me.tatarka.retrolambda&apos;//加上这句加,入plugin声明
android {
……
compileOptions {//使用JAVA8语法解析
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }
}
    retrolambda {//指定将源码编译的级别，使用下列代码，会将代码编译到兼容1.6的字节码格式
    javaVersion JavaVersion.VERSION_1_6
}
</code></pre><h4 id="Android_Studio_u81EA_u52A8_u751F_u6210lambda"><a href="#Android_Studio_u81EA_u52A8_u751F_u6210lambda" class="headerlink" title="Android Studio自动生成lambda"></a>Android Studio自动生成lambda</h4><p><img src="https://d7.usercdn.com/i/04033/9kdvn64rz5p9.png" alt=""></p>
<p>当配置Retrolambda成功后，Android Studio会有提示，按Alt+Enter键<br>hexo<br><img src="https://d7.usercdn.com/i/04033/8zt63yej4sql.png" alt=""></p>
<p>点击替换，这样就能自动生成，使用lambda了。到这里我就可以洗洗睡了，也很晚了，但为什么可以这样写呢，还是来简单了解lambda语法吧。<br>lambda语法简介</p>
<pre><code>input -&gt; body
</code></pre><h4 id="intput_u79CD_u7C7B"><a href="#intput_u79CD_u7C7B" class="headerlink" title="intput种类"></a>intput种类</h4><h5 id="u65E0_u8F93_u5165_void"><a href="#u65E0_u8F93_u5165_void" class="headerlink" title="无输入 void"></a>无输入 void</h5><pre><code>() -&gt; body

new Thread(new Runnable() {
@Override
public void run() {
Log.d(&quot;wxl&quot;, &quot;retrolambda test&quot;);
}
});
</code></pre><p>使用 lambda</p>
<pre><code>new Thread(() -&gt; Log.d(&quot;wxl&quot;, &quot;retrolambda test&quot;));
</code></pre><h5 id="u4E00_u4E2A_u53C2_u6570_u8F93_u5165"><a href="#u4E00_u4E2A_u53C2_u6570_u8F93_u5165" class="headerlink" title="一个参数输入"></a>一个参数输入</h5><pre><code>x -&gt; body

view.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View v) {
Log.d(&quot;wxl&quot;, &quot;retrolambda test&quot;);
}
});
</code></pre><p>使用 lambda</p>
<pre><code>view.setOnClickListener(
v -&gt; Log.d(&quot;wxl&quot;, &quot;retrolambda test&quot;));
</code></pre><h5 id="u591A_u4E2A_u53C2_u6570_u8F93_u5165"><a href="#u591A_u4E2A_u53C2_u6570_u8F93_u5165" class="headerlink" title="多个参数输入"></a>多个参数输入</h5><pre><code>(x, y) -&gt; x + y;

List&lt;String&gt; names = Arrays.asList(&quot;peter&quot;, &quot;anna&quot;, &quot;mike&quot;, &quot;xenia&quot;);
Collections.sort(names, new Comparator&lt;String&gt;() {
    @Override
    public int compare(String a, String b) {
        return b.compareTo(a);
    }
    });
    for (String name : names) {
    Log.d(&quot;wxl&quot;, name);
}
</code></pre><p>使用 lambda</p>
<pre><code>List&lt;String&gt; names = Arrays.asList(&quot;peter&quot;, &quot;anna&quot;, &quot;mike&quot;, &quot;xenia&quot;);
    Collections.sort(names, (a, b) -&gt; b.compareTo(a));
     for (String name : names) {
        Log.d(&quot;wxl&quot;, name);
}
</code></pre><h5 id="u4E0D_u7701_u7565_u578B_u5225"><a href="#u4E0D_u7701_u7565_u578B_u5225" class="headerlink" title="不省略型別"></a>不省略型別</h5><pre><code>(int x, int y) -&gt; x + y;
</code></pre><h4 id="body__u79CD_u7C7B"><a href="#body__u79CD_u7C7B" class="headerlink" title="body 种类"></a>body 种类</h4><h5 id="u4EC0_u9EBC_u90FD_u4E0D_u505A"><a href="#u4EC0_u9EBC_u90FD_u4E0D_u505A" class="headerlink" title="什麼都不做"></a>什麼都不做</h5><pre><code>() -&gt; {}
</code></pre><h5 id="u5355_u884C_u4E0D_u9700_u8981_u6709_u8FD4_u56DE_u503C_uFF0C_u5355_u884C_u53EF_u7701_u7565_7B_7D"><a href="#u5355_u884C_u4E0D_u9700_u8981_u6709_u8FD4_u56DE_u503C_uFF0C_u5355_u884C_u53EF_u7701_u7565_7B_7D" class="headerlink" title="单行不需要有返回值，单行可省略{}"></a>单行不需要有返回值，单行可省略{}</h5><pre><code>(x, y) -&gt; x + y;
</code></pre><h5 id="u5355_u884C_u9700_u8981_u6709_u8FD4_u56DE_u503C"><a href="#u5355_u884C_u9700_u8981_u6709_u8FD4_u56DE_u503C" class="headerlink" title="单行需要有返回值"></a>单行需要有返回值</h5><pre><code>(x, y) -&gt; x + y//注意没有分号结尾

Observable.just(&quot;Hello&quot;, &quot;RxJava&quot;)
.map(new Func1&lt;String, String&gt;() {
@Override
    public String call(String s) {
     return s.toUpperCase();
    }
});
</code></pre><p>使用 lambda</p>
<pre><code>Observable.just(&quot;Hello&quot;, &quot;RxJava&quot;)
.map(s -&gt; s.toUpperCase());
</code></pre><h5 id="u591A_u884C_u4E0D_u9700_u8981_u6709_u8FD4_u56DE_u503C"><a href="#u591A_u884C_u4E0D_u9700_u8981_u6709_u8FD4_u56DE_u503C" class="headerlink" title="多行不需要有返回值"></a>多行不需要有返回值</h5><pre><code>(x, y) -&gt;{
x x;
y y;
}
</code></pre><h5 id="u591A_u884C_u9700_u8981_u6709_u8FD4_u56DE_u503C"><a href="#u591A_u884C_u9700_u8981_u6709_u8FD4_u56DE_u503C" class="headerlink" title="多行需要有返回值"></a>多行需要有返回值</h5><pre><code>(x, y) -&gt;{
x x;
y y;
return x + y;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>Lambda，它让代码看起来更加简洁，但个人认为代码的可读性差了很多，因此一直没有去深入学习。</p>
<h3 id="u4EC0_u4E48_u662Flambda"><a href="#u4EC0_u4E48_u662Flambda" class="headerlink" title="什么是lambda"></a>什么是lambda</h3><p>lambda是一种匿名表达式，retrolambda使得Android能使用lambda特性，举个例子：</p>
<pre><code>view.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View v) {
Log.d(&quot;wxl&quot;, &quot;retrolambda test&quot;);
}
});
</code></pre><p>使用 lambda</p>
<pre><code>view.setOnClickListener(
v -&gt; Log.d(&quot;wxl&quot;, &quot;retrolambda test&quot;));
</code></pre><h3 id="Android_u5982_u4F55_u4F7F_u7528"><a href="#Android_u5982_u4F55_u4F7F_u7528" class="headerlink" title="Android如何使用"></a>Android如何使用</h3><p>这里是使用Retrolambda的gradle插件，这样就可以在代码中使用lambda了。<br>]]>
    
    </summary>
    
      <category term="Lambda" scheme="http://kevinhero.github.io/tags/Lambda/"/>
    
      <category term="技术" scheme="http://kevinhero.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[理解Android编译命令]]></title>
    <link href="http://kevinhero.github.io/2016/02/25/Android%20Skills/%E7%90%86%E8%A7%A3Android%E7%9A%84%E7%BC%96%E8%AF%91%E5%91%BD%E4%BB%A4/"/>
    <id>http://kevinhero.github.io/2016/02/25/Android Skills/理解Android的编译命令/</id>
    <published>2016-02-25T11:33:45.000Z</published>
    <updated>2016-04-06T11:04:55.000Z</updated>
    <content type="html"><![CDATA[<p>工欲善其事，必先利其器，对于想要深入学习Android源码，必须先掌握Android编译命令.</p>
<p>关于Android Build系统，这个话题很早就打算整理下，迟迟没有下笔，决定跟大家分享下。先看下面几条指令，相信编译过Android源码的人都再熟悉不过的。</p>
<p>source /opt/android1204_17.conf<br>source setenv.sh<br>lunch<br>make -j12<br><a id="more"></a></p>
<p>记得最初刚接触Android时，同事告诉我用上面的指令就可以编译Android源码，指令虽短但过几天就记不全或者忘记顺序，每次编译时还需要看看自己的云笔记，冰冷的指令总是难以让我记忆。后来我决定认真研究下这个指令的含义。知其然还需知其所以然，这样能更深层次的理解并记忆，才能与自身的知识体系建立强连接，或许还有意外收获，果然如此，接下来跟大家分享一下在研究上述几条指令含义的过程中，深入了解到的Android Build(编译)系统。</p>
<p>二、编译命令</p>
<p>准备好编译环境后，编译Android源码的第一步是 source build/envsetup.sh，其中source命令就是用于运行shell脚本命令，功能等价于”.”，因此该命令也等价于. build/envsetup.sh。在文件envsetup.sh声明了当前会话终端可用的命令，这里需要注意的是当前会话终端，也就意味着每次新打开一个终端都必须再一次执行这些指令。起初并不理解为什么新开的终端不能直接执行make指令，到这里总算明白了。</p>
<p>接下来，解释一下本文开头的引用的命令：</p>
<p>source /opt/android1204_17.conf  //初始化jdk环境变量（这个不是必需的，因厂商而异）<br>source setenv.sh  //初始化编译环境，包括后面的lunch和make指令<br>lunch  //指定此次编译的目标设备以及编译类型<br>make  -j12 //开始编译，默认为编译整个系统，其中-j12代表的是编译的job数量为12。</p>
<p>所有的编译命令都在envsetup.sh文件能找到相对应的function，比如上述的命令lunch，make，在文件一定能找到</p>
<p>function lunch{<br>…<br>}</p>
<p>function {<br>…<br>}</p>
<p>具体实现这里就不展开说明，下面精炼地总结了一下各个指令用法和功效。</p>
<p>2.1 代码编译</p>
<p>编译指令</p>
<p>解释</p>
<p>m</p>
<p>在源码树的根目录执行编译</p>
<p>mm</p>
<p>编译当前路径下所有模块，但不包含依赖</p>
<p>mmm [module_path]</p>
<p>编译指定路径下所有模块，但不包含依赖</p>
<p>mma</p>
<p>编译当前路径下所有模块，且包含依赖</p>
<p>mmma [module_path]</p>
<p>编译指定路径下所有模块，且包含依赖</p>
<p>make [module_name]</p>
<p>无参数，则表示编译整个Android代码</p>
<p>下面列举部分模块的编译指令：</p>
<p>模块</p>
<p>make命令</p>
<p>mmm命令</p>
<p>init</p>
<p>make init</p>
<p>mmm system/core/init</p>
<p>zygote</p>
<p>make app_process</p>
<p>mmm frameworks/base/cmds/app_process</p>
<p>system_server</p>
<p>make services</p>
<p>mmm frameworks/base/services</p>
<p>java framework</p>
<p>make framework</p>
<p>mmm frameworks/base</p>
<p>framework资源</p>
<p>make framework-res</p>
<p>mmm frameworks/base/core/res</p>
<p>jni framework</p>
<p>make libandroid_runtime</p>
<p>mmm frameworks/base/core/jni</p>
<p>binder</p>
<p>make libbinder</p>
<p>mmm frameworks/native/libs/binder</p>
<p>上述mmm命令同样适用于mm/mma/mmma，编译系统采用的是增量编译，只会编译发生变化的目标文件。当需要重新编译所有的相关模块，则需要编译命令后增加参数-B，比如make -B [module_name]，或者 mm -B [module_path]。</p>
<p>Tips:</p>
<ul>
<li>对于m、mm、mmm、mma、mmma这些命令的实现都是通过make方式来完成的。</li>
<li>mmm/mm编译的效率很高，而make/mma/mmma编译较缓慢；</li>
<li>make/mma/mmma编译时会把所有的依赖模块一同编译，但mmm/mm不会;</li>
<li>建议：首次编译时采用make/mma/mmma编译；当依赖模块已经编译过的情况，则使用mmm/mm编译。</li>
</ul>
<p>2.2 代码搜索</p>
<p>搜索指令</p>
<p>解释</p>
<p>cgrep</p>
<p>所有C/C++文件执行搜索操作</p>
<p>jgrep</p>
<p>所有Java文件执行搜索操作</p>
<p>ggrep</p>
<p>所有Gradle文件执行搜索操作</p>
<p>mangrep [keyword]</p>
<p>所有AndroidManifest.xml文件执行搜索操作</p>
<p>sepgrep [keyword]</p>
<p>所有sepolicy文件执行搜索操作</p>
<p>resgrep [keyword]</p>
<p>所有本地res/*.xml文件执行搜索操作</p>
<p>sgrep [keyword]</p>
<p>所有资源文件执行搜索操作</p>
<p>上述指令用法最终实现方式都是基于grep指令，各个指令用法格式：</p>
<p>xgrep [keyword]  //x代表的是上表的搜索指令</p>
<p>例如，搜索所有AndroidManifest.xml文件中的launcher关键字所在文件的具体位置，指令</p>
<p>mangrep launcher</p>
<p>再如，搜索所有system_app的selinux权限信息</p>
<p>sepgrep system_app</p>
<p>Tips: Android源码非常庞大，直接采用grep来搜索代码，不仅方法笨拙、浪费时间，而且搜索出很多无意义的混淆结果。根据具体需求，来选择合适的代码搜索指令，能节省代码搜索时间，提高搜索结果的精准度，方便定位目标代码。</p>
<p>2.3 导航指令</p>
<p>导航指令</p>
<p>解释</p>
<p>croot</p>
<p>切换至Android根目录</p>
<p>cproj</p>
<p>切换至工程的根目录</p>
<p>godir [filename]</p>
<p>跳转到包含某个文件的目录</p>
<p>Tips: 当每次修改完某个文件后需要编译时，执行cproj后会跳转到当前模块的根目录，也就是Android.mk文件所在目录，然后再执行mm指令，即可编译目标模块；当进入源码层级很深后，需要返回到根目录，使用croot一条指令完成；另外cd - 指令可用于快速切换至上次目录。</p>
<p>2.4 信息查询</p>
<p>查询指令</p>
<p>解释</p>
<p>hmm</p>
<p>查询所有的指令help信息</p>
<p>findmakefile</p>
<p>查询当前目录所在工程的Android.mk文件路径</p>
<p>print_lunch_menu</p>
<p>查询lunch可选的product</p>
<p>printconfig</p>
<p>查询各项编译变量值</p>
<p>gettop</p>
<p>查询Android源码的根目录</p>
<p>gettargetarch</p>
<p>获取TARGET_ARCH值</p>
<p>Tips: 当忘了前面的所有指令时，可以执行一个hmm便可输出这些指令的帮助信息。</p>
<p>其他指令：</p>
<ul>
<li>make clean：执行清理操作，等价于 rm -rf out/</li>
<li>make update-api：更新API，在framework API改动后需执行该指令，Api记录在目录frameworks/base/api；</li>
</ul>
<p>三、编译系统</p>
<p>Android 编译系统是Android源码的一部分，用于编译Android系统，Android SDK以及相关文档。该编译系统是由Make文件、Shell以及Python脚本共同组成，其中最为重要的便是Make文件。关于编译系统可参考 理解 Android Build 系统。</p>
<p>3.1 Makefile分类</p>
<p>整个Build系统的Make文件分为三大类：</p>
<ul>
<li>系统核心的Make文件：定义了Build系统的框架，文件全部位于路径/build/core，其他Make文件都是基于该框架编写的；</li>
<li>针对产品的Make文件：定义了具体某个型号手机的Make文件，文件路径位于/device，该目录下往往又以公司名和产品名划分两个子级目录，比如/device/qcom/msm8916；</li>
<li>针对模块的Make文件：整个系统分为各个独立的模块，每个模块都一个专门的Make文件，名称统一为”Android.mk”，该文件定义了当前模块的编译方式。Build系统会扫描整个源码树中名为”Android.mk”的问题，并执行相应模块的编译工作。</li>
</ul>
<p>3.2 编译产物</p>
<p>经过make编译后的产物，都位于/out目录，该目录下主要关注下面几个目录：</p>
<ul>
<li>/out/host：Android开发工具的产物，包含SDK各种工具，比如adb，dex2oat，aapt等。</li>
<li>/out/target/common：通用的一些编译产物，包含Java应用代码和Java库；</li>
<li>/out/target/product/[product_name]：针对特定设备的编译产物以及平台相关C/C++代码和二进制文件；</li>
</ul>
<p>在/out/target/product/[product_name]目录下，有几个重量级的镜像文件：</p>
<ul>
<li>system.img:挂载为根分区，主要包含Android OS的系统文件；</li>
<li>ramdisk.img:主要包含init.rc文件和配置文件等；</li>
<li>userdata.img:被挂载在/data，主要包含用户以及应用程序相关的数据；</li>
</ul>
<p>当然还有boot.img，reocovery.img等镜像文件，这里就不介绍了。</p>
<p>3.3 Android.mk解析</p>
<p>在源码树中每一个模块的所有文件通常都相应有一个自己的文件夹，在该模块的根目录下有一个名称为“Android.mk” 的文件。编译系统正是以模块为单位进行编译，每个模块都有唯一的模块名，一个模块可以有依赖多个其他模块，模块间的依赖关系就是通过模块名来引用的。也就是说当模块需要依赖一个jar包或者apk时，必须先将jar包或apk定义为一个模块，然后再依赖相应的模块。</p>
<p>对于Android.mk文件，通常都是以下面两行</p>
<p>LOCAL_PATH := $(call my-dir)  //设置当编译路径为当前文件夹所在路径<br>include $(CLEAR_VARS)  //清空编译环境的变量（由其他模块设置过的变量）</p>
<p>为方便模块编译，编译系统设置了很多的编译环境变量，如下：</p>
<ul>
<li>LOCAL_SRC_FILES：当前模块包含的所有源码文件；</li>
<li>LOCAL_MODULE：当前模块的名称（具有唯一性）；</li>
<li>LOCAL_PACKAGE_NAME：当前APK应用的名称（具有唯一性）；</li>
<li>LOCAL_C_INCLUDES：C/C++所需的头文件路径;</li>
<li>LOCAL_STATIC_LIBRARIES：当前模块在静态链接时需要的库名;</li>
<li>LOCAL_SHARED_LIBRARIES：当前模块在运行时依赖的动态库名;</li>
<li>LOCAL_STATIC_JAVA_LIBRARIES：当前模块依赖的Java静态库;</li>
<li>LOCAL_JAVA_LIBRARIES：当前模块依赖的Java共享库;</li>
<li>LOCAL_CERTIFICATE：签署当前应用的证书名称，比如flatform。</li>
<li>LOCAL_MODULE_TAGS：当前模块所包含的标签，可以包含多标签，可能值为debgu,eng,user,development或optional（默认值）</li>
</ul>
<p>针对这些环境变量，编译系统还定义了一些便捷函数，如下：</p>
<ul>
<li>$(call my-dir)：获取当前文件夹路径；</li>
<li>$(call all-java-files-under, )：获取指定目录下的所有Java文件；</li>
<li>$(call all-c-files-under, )：获取指定目录下的所有C文件；</li>
<li>$(call all-Iaidl-files-under, ) ：获取指定目录下的所有AIDL文件；</li>
<li><p>$(call all-makefiles-under, )：获取指定目录下的所有Make文件；</p>
<p>LOCAL_PATH = call my-dir)<br>include CLEAR_VARS)</p>
<h1 id="u83B7_u53D6_u6240_u6709_u5B50_u76EE_u5F55_u4E2D_u7684Java_u6587_u4EF6"><a href="#u83B7_u53D6_u6240_u6709_u5B50_u76EE_u5F55_u4E2D_u7684Java_u6587_u4EF6" class="headerlink" title="获取所有子目录中的Java文件"></a>获取所有子目录中的Java文件</h1><p>LOCAL_SRC_FILES = call all-subdir-java-files)</p>
<h1 id="u5F53_u524D_u6A21_u5757_u4F9D_u8D56_u7684_u52A8_u6001Java_u5E93_u540D_u79F0"><a href="#u5F53_u524D_u6A21_u5757_u4F9D_u8D56_u7684_u52A8_u6001Java_u5E93_u540D_u79F0" class="headerlink" title="当前模块依赖的动态Java库名称"></a>当前模块依赖的动态Java库名称</h1><p>LOCAL_JAVA_LIBRARIES = com.gityuan.lib</p>
<h1 id="u5F53_u524D_u6A21_u5757_u7684_u540D_u79F0"><a href="#u5F53_u524D_u6A21_u5757_u7684_u540D_u79F0" class="headerlink" title="当前模块的名称"></a>当前模块的名称</h1><p>LOCAL_MODULE = demo</p>
<h1 id="u5C06_u5F53_u524D_u6A21_u5757_u7F16_u8BD1_u6210_u4E00_u4E2A_u9759_u6001_u7684Java_u5E93"><a href="#u5C06_u5F53_u524D_u6A21_u5757_u7F16_u8BD1_u6210_u4E00_u4E2A_u9759_u6001_u7684Java_u5E93" class="headerlink" title="将当前模块编译成一个静态的Java库"></a>将当前模块编译成一个静态的Java库</h1><p>include BUILD_STATIC_JAVA_LIBRARY)</p>
</li>
</ul>
<p>如果觉得本文对您有所帮助，请关注我的微信公众号：gityuan， 微博：Gityuan。 或者点击这里查看更多关于gityuan个人信息</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>工欲善其事，必先利其器，对于想要深入学习Android源码，必须先掌握Android编译命令.</p>
<p>关于Android Build系统，这个话题很早就打算整理下，迟迟没有下笔，决定跟大家分享下。先看下面几条指令，相信编译过Android源码的人都再熟悉不过的。</p>
<p>source /opt/android1204_17.conf<br>source setenv.sh<br>lunch<br>make -j12<br>]]>
    
    </summary>
    
      <category term="编译" scheme="http://kevinhero.github.io/tags/%E7%BC%96%E8%AF%91/"/>
    
      <category term="技术" scheme="http://kevinhero.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Webview上传文件的那些坑]]></title>
    <link href="http://kevinhero.github.io/2016/02/22/Android%20Skills/Webview%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9D%91/"/>
    <id>http://kevinhero.github.io/2016/02/22/Android Skills/Webview上传文件的那些坑/</id>
    <published>2016-02-22T13:01:14.000Z</published>
    <updated>2016-02-22T05:35:13.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>要说Android中最厉害的组件莫过于Webview 了，夸张点说把这个组件放在屏幕上就可以算作一个简单地浏览器应用了。但你若认为这就万事大吉了，可太小看Webview这个磨人的妖精了，下面单就上传文件的这个坑来做展开。</p>
</blockquote>
<a id="more"></a>
<h3 id="u652F_u6301_u4E0A_u4F20_u6587_u4EF6"><a href="#u652F_u6301_u4E0A_u4F20_u6587_u4EF6" class="headerlink" title="支持上传文件"></a>支持上传文件</h3><p>Webview执行上传操作的逻辑是这样的：首先准备上传时会回调WebChromeClient类下的<code>openFileChooser</code>方法，在这个方法中给我们机会发起Intent来打开支持提供文件的第三方应用，最后在<code>onActivityResult</code>回调中将第三方应用提供的内容通过一个叫做<code>ValueCallback</code>的参数返回给<code>Webview</code>（详细点来说：ValueCallback是在openFileChooser 方法里由webview提供给我们的，里面包裹一个Uri，我们在<code>onActivityResult</code> 里将选中的Uri反馈给<code>ValueCallback</code>，这时候相当于Webview就知道我们选择了什么文件），因此，我们需要为<code>Webview</code>设置一个提供<code>openFileChooser</code>方法的<code>WebChromeClient</code>，这个方法在不同版本的<code>Android</code>中参数是不同的，为此我们一般需要写三个重载函数，大致像这个样子：</p>
<pre><code>private ValueCallback&lt;Uri&gt; mUploadMessage;
    //设置`WebChromeClient`:
webview.setWebChromeClient(new WebChromeClient(){
     public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg) {
            Log.d(TAG, &quot;openFileChoose(ValueCallback&lt;Uri&gt; uploadMsg)&quot;);
            mUploadMessage = uploadMsg;
            Intent i = new Intent(Intent.ACTION_GET_CONTENT);
            i.addCategory(Intent.CATEGORY_OPENABLE);
            i.setType(&quot;*/*&quot;);
            MainActivity.this.startActivityForResult(Intent.createChooser(i, &quot;File Chooser&quot;), FILECHOOSER_RESULTCODE);
      }
      public void openFileChooser( ValueCallback uploadMsg, String acceptType ) {
            Log.d(TAG, &quot;openFileChoose( ValueCallback uploadMsg, String acceptType )&quot;);
            mUploadMessage = uploadMsg;
            Intent i = new Intent(Intent.ACTION_GET_CONTENT);
            i.addCategory(Intent.CATEGORY_OPENABLE);
            i.setType(&quot;*/*&quot;);
            MainActivity.this.startActivityForResult(
                    Intent.createChooser(i, &quot;File Browser&quot;),
                    FILECHOOSER_RESULTCODE);
      }
      public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg, String acceptType, String capture){
            Log.d(TAG, &quot;openFileChoose(ValueCallback&lt;Uri&gt; uploadMsg, String acceptType, String capture)&quot;);
            mUploadMessage = uploadMsg;
            Intent i = new Intent(Intent.ACTION_GET_CONTENT);
            i.addCategory(Intent.CATEGORY_OPENABLE);
            i.setType(&quot;*/*&quot;);
            MainActivity.this.startActivityForResult( Intent.createChooser( i, &quot;File Browser&quot; ), MainActivity.FILECHOOSER_RESULTCODE );
        }
});

//onActivityResult回调   
@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        if(requestCode==FILECHOOSER_RESULTCODE)
         {
                if (null == mUploadMessage &amp;&amp; null == mUploadCallbackAboveL) return;
                 Uri result = data == null || resultCode != RESULT_OK ? null : data.getData();
                 if (mUploadMessage != null) {
                    mUploadMessage.onReceiveValue(result);
                    mUploadMessage = null;
               }
          }
       }
</code></pre><p>还有重要的一点：如果这个上传操作涉及到JS操作，别忘记对Webview开启对JS的支持：</p>
<pre><code>WebSettings settings = webview.getSettings();
settings.setJavaScriptEnabled(true);
</code></pre><h3 id="u4EE3_u7801_u6DF7_u6DC6"><a href="#u4EE3_u7801_u6DF7_u6DC6" class="headerlink" title="代码混淆"></a>代码混淆</h3><pre><code>-keepclassmembers class * extends android.webkit.WebChromeClient{
    public void openFileChooser(...);
}
</code></pre><h3 id="u517C_u5BB95-0"><a href="#u517C_u5BB95-0" class="headerlink" title="兼容5.0"></a>兼容5.0</h3><pre><code>webview.setWebChromeClient(new WebChromeClient(){
public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg) {
     ...
}
public void openFileChooser( ValueCallback uploadMsg, String acceptType ) {
       ...
}
public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg, String acceptType, String capture){
                ...
}

// For Android 5.0+
public boolean onShowFileChooser (WebView webView, ValueCallback&lt;Uri[]&gt; filePathCallback, WebChromeClient.FileChooserParams fileChooserParams) {
         mUploadCallbackAboveL = filePathCallback;
         Intent i = new Intent(Intent.ACTION_GET_CONTENT);
         i.addCategory(Intent.CATEGORY_OPENABLE);
         i.setType(&quot;*/*&quot;);
         MainActivity.this.startActivityForResult(
                    Intent.createChooser(i, &quot;File Browser&quot;),
                    FILECHOOSER_RESULTCODE);
         return true;
        }
});

@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {
    super.onActivityResult(requestCode, resultCode, data);
    if(requestCode==FILECHOOSER_RESULTCODE)
    {
        if (null == mUploadMessage &amp;&amp; null == mUploadCallbackAboveL) return;
        Uri result = data == null || resultCode != RESULT_OK ? null : data.getData();
        if (mUploadCallbackAboveL != null) {
            onActivityResultAboveL(requestCode, resultCode, data);
        }
        else  if (mUploadMessage != null) {
            mUploadMessage.onReceiveValue(result);
            mUploadMessage = null;
        }
    }
}
@TargetApi(Build.VERSION_CODES.LOLLIPOP)
private void onActivityResultAboveL(int requestCode, int resultCode, Intent data) {
    if (requestCode != FILECHOOSER_RESULTCODE
            || mUploadCallbackAboveL == null) {
        return;
    }
    Uri[] results = null;
    if (resultCode == Activity.RESULT_OK) {
        if (data == null) {
        } else {
            String dataString = data.getDataString();
            ClipData clipData = data.getClipData();
            if (clipData != null) {
                results = new Uri[clipData.getItemCount()];
                for (int i = 0; i &lt; clipData.getItemCount(); i++) {
                    ClipData.Item item = clipData.getItemAt(i);
                    results[i] = item.getUri();
                }
            }
            if (dataString != null)
                results = new Uri[]{Uri.parse(dataString)};
        }
    }
    mUploadCallbackAboveL.onReceiveValue(results);
    mUploadCallbackAboveL = null;
    return;
}
</code></pre><blockquote>
<p>代码转自: <a href="http://blog.saymagic.cn/2015/11/08/webview-upload.html" target="_blank" rel="external">http://blog.saymagic.cn/2015/11/08/webview-upload.html</a></p>
<p>源码地址: <a href="https://gitcafe.com/saymagic/Webviewdemo" target="_blank" rel="external">https://gitcafe.com/saymagic/Webviewdemo</a></p>
</blockquote>
<pre><code>* 说明:实际上我使用了该段代码只能够 完成5.0+的支持,对于5.0以下的机器支持的并不完美,比如说上传完成之后,并不能显示图片到目标位置.
</code></pre><ul>
<li>没办法继续爬文 终于发现了</li>
</ul>
<pre><code>package com.fuiou.webviewupload;
import java.io.File;
import android.app.Activity;
import android.app.AlertDialog;
import android.content.ContentValues;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.database.Cursor;
import android.graphics.Bitmap;
import android.net.Uri;
import android.os.Bundle;
import android.os.Environment;
import android.provider.MediaStore;
import android.util.Log;
import android.view.KeyEvent;
import android.webkit.ValueCallback;
import android.webkit.WebChromeClient;
import android.webkit.WebView;
import android.webkit.WebViewClient;
import android.widget.Toast;

public class MainActivity extends Activity {
    public static final String TAG = &quot;MainActivity&quot;;
    ValueCallback&lt;Uri&gt; mUploadMessage;
    private WebView mWebView;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        initView();
    }

    private void initView() {
        mWebView = (WebView) findViewById(R.id.web_view);
        mWebView.setWebChromeClient(new MyWebChromeClient());

        mWebView.setWebViewClient(new MyWebViewClient(this));
//        webView.loadUrl(&quot;file:///android_asset/upload_image.html&quot;);
        mWebView.loadUrl(&quot;http://192.168.72.62:8080/fileUpload&quot;);
    }


    private class MyWebViewClient extends WebViewClient{
        private Context mContext;
        public MyWebViewClient(Context context){
            super();
            mContext = context;
        }

        @Override
        public void onPageStarted(WebView view, String url, Bitmap favicon) {
            Log.d(TAG,&quot;URL地址:&quot; + url);
            super.onPageStarted(view, url, favicon);
        }

        @Override
        public void onPageFinished(WebView view, String url) {
            Log.i(TAG, &quot;onPageFinished&quot;);
            super.onPageFinished(view, url);
        }
    }

    public static final int FILECHOOSER_RESULTCODE = 1;
    private static final int REQ_CAMERA = FILECHOOSER_RESULTCODE+1;
    private static final int REQ_CHOOSE = REQ_CAMERA+1;

    private class MyWebChromeClient extends WebChromeClient {

        // For Android 3.0+
           public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg, String acceptType) {  
               if (mUploadMessage != null) return;
               mUploadMessage = uploadMsg;   
               selectImage();
//               Intent i = new Intent(Intent.ACTION_GET_CONTENT);
//               i.addCategory(Intent.CATEGORY_OPENABLE);
//               i.setType(&quot;*/*&quot;);
//                   startActivityForResult( Intent.createChooser( i, &quot;File Chooser&quot; ), FILECHOOSER_RESULTCODE );
           }
            // For Android &lt; 3.0
            public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg) {
                   openFileChooser( uploadMsg, &quot;&quot; );
            }
            // For Android  &gt; 4.1.1
          public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg, String acceptType, String capture) {
                  openFileChooser(uploadMsg, acceptType);
          }

    }

    /**
     * 检查SD卡是否存在
     *
     * @return
     */
    public final boolean checkSDcard() {
        boolean flag = Environment.getExternalStorageState().equals(
                Environment.MEDIA_MOUNTED);
        if (!flag) {
            Toast.makeText(this, &quot;请插入手机存储卡再使用本功能&quot;,Toast.LENGTH_SHORT).show();
        }
        return flag;
    }
    String compressPath = &quot;&quot;;

    protected final void selectImage() {
        if (!checkSDcard())
            return;
        String[] selectPicTypeStr = { &quot;camera&quot;,&quot;photo&quot; };
        new AlertDialog.Builder(this)
                .setItems(selectPicTypeStr,
                        new DialogInterface.OnClickListener() {
                            @Override
                            public void onClick(DialogInterface dialog,
                                    int which) {
                                switch (which) {
                                // 相机拍摄
                                case 0:
                                    openCarcme();
                                    break;
                                // 手机相册
                                case 1:
                                    chosePic();
                                    break;
                                default:
                                    break;
                                }
                                compressPath = Environment
                                        .getExternalStorageDirectory()
                                        .getPath()
                                        + &quot;/fuiou_wmp/temp&quot;;
                                new File(compressPath).mkdirs();
                                compressPath = compressPath + File.separator
                                        + &quot;compress.jpg&quot;;
                            }
                        }).show();
    }

    String imagePaths;
    Uri  cameraUri;
    /**
     * 打开照相机
     */
    private void openCarcme() {
        Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);

        imagePaths = Environment.getExternalStorageDirectory().getPath()
                + &quot;/fuiou_wmp/temp/&quot;
                + (System.currentTimeMillis() + &quot;.jpg&quot;);
        // 必须确保文件夹路径存在，否则拍照后无法完成回调
        File vFile = new File(imagePaths);
        if (!vFile.exists()) {
            File vDirPath = vFile.getParentFile();
            vDirPath.mkdirs();
        } else {
            if (vFile.exists()) {
                vFile.delete();
            }
        }
        cameraUri = Uri.fromFile(vFile);
        intent.putExtra(MediaStore.EXTRA_OUTPUT, cameraUri);
        startActivityForResult(intent, REQ_CAMERA);
    }

    /**
     * 拍照结束后
     */
    private void afterOpenCamera() {
        File f = new File(imagePaths);
        addImageGallery(f);
        File newFile = FileUtils.compressFile(f.getPath(), compressPath);
    }

    /** 解决拍照后在相册中找不到的问题 */
    private void addImageGallery(File file) {
        ContentValues values = new ContentValues();
        values.put(MediaStore.Images.Media.DATA, file.getAbsolutePath());
        values.put(MediaStore.Images.Media.MIME_TYPE, &quot;image/jpeg&quot;);
        getContentResolver().insert(
                MediaStore.Images.Media.EXTERNAL_CONTENT_URI, values);
    }

    /**
     * 本地相册选择图片
     */
    private void chosePic() {
        FileUtils.delFile(compressPath);
        Intent innerIntent = new Intent(Intent.ACTION_GET_CONTENT); // &quot;android.intent.action.GET_CONTENT&quot;
        String IMAGE_UNSPECIFIED = &quot;image/*&quot;;
        innerIntent.setType(IMAGE_UNSPECIFIED); // 查看类型
        Intent wrapperIntent = Intent.createChooser(innerIntent, null);
        startActivityForResult(wrapperIntent, REQ_CHOOSE);
    }

    /**
     * 选择照片后结束
     *
     * @param data
     */
    private Uri afterChosePic(Intent data) {

        // 获取图片的路径：
        String[] proj = { MediaStore.Images.Media.DATA };
        // 好像是android多媒体数据库的封装接口，具体的看Android文档
        Cursor cursor = managedQuery(data.getData(), proj, null, null, null);
        if(cursor == null ){
            Toast.makeText(this, &quot;上传的图片仅支持png或jpg格式&quot;,Toast.LENGTH_SHORT).show();
            return null;
        }
        // 按我个人理解 这个是获得用户选择的图片的索引值
        int column_index = cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DATA);
        // 将光标移至开头 ，这个很重要，不小心很容易引起越界
        cursor.moveToFirst();
        // 最后根据索引值获取图片路径
        String path = cursor.getString(column_index);
        if(path != null &amp;&amp; (path.endsWith(&quot;.png&quot;)||path.endsWith(&quot;.PNG&quot;)||path.endsWith(&quot;.jpg&quot;)||path.endsWith(&quot;.JPG&quot;))){
            File newFile = FileUtils.compressFile(path, compressPath);
            return Uri.fromFile(newFile);
        }else{
            Toast.makeText(this, &quot;上传的图片仅支持png或jpg格式&quot;,Toast.LENGTH_SHORT).show();
        }
        return null;
    }



    /**
     * 返回文件选择
     */
    @Override
    protected void onActivityResult(int requestCode, int resultCode,
            Intent intent) {
    //        if (requestCode == FILECHOOSER_RESULTCODE) {
    //            if (null == mUploadMessage)
    //                return;
    //            Uri result = intent == null || resultCode != RESULT_OK ? null
    //                    : intent.getData();
    //            mUploadMessage.onReceiveValue(result);
    //            mUploadMessage = null;
    //        }

        if (null == mUploadMessage)
            return;
        Uri uri = null;
        if(requestCode == REQ_CAMERA ){
            afterOpenCamera();
            uri = cameraUri;
        }else if(requestCode == REQ_CHOOSE){
            uri = afterChosePic(intent);
        }
        mUploadMessage.onReceiveValue(uri);
        mUploadMessage = null;
        super.onActivityResult(requestCode, resultCode, intent);
    }

    public boolean onKeyDown(int keyCode, KeyEvent event) {
        if ((keyCode == KeyEvent.KEYCODE_BACK) &amp;&amp; mWebView.canGoBack()) {  
            mWebView.goBack();  
            return true;  
        }else{
                finish();
        }
        return super.onKeyDown(keyCode, event);  
        }
}
</code></pre><p>根据这个哥们的代码进行精简,符合自己的需求,而且发现了这个代码的一个问题,没有能够进行判空操作,如果没有选择图片,直接返回APP会奔溃!</p>
<p>下面是我的开发源码:</p>
<pre><code>private class MyWebChromeClient extends WebChromeClient {


        // For Android 5.0+
        public boolean onShowFileChooser(WebView webView, ValueCallback&lt;Uri[]&gt; filePathCallback, WebChromeClient.FileChooserParams fileChooserParams) {
            mUploadCallbackAboveL = filePathCallback;
//            Intent i = new Intent(Intent.ACTION_GET_CONTENT);
//            i.addCategory(Intent.CATEGORY_OPENABLE);
//            i.setType(&quot;*/*&quot;);
//            HomePageViewActivity.this.startActivityForResult(
//                    Intent.createChooser(i, &quot;File Browser&quot;),
//                    FILECHOOSER_RESULTCODE);
            selectImage();
            return true;
        }


        //For Android 3.0+
        public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg, String acceptType) {
            if (mUploadMessage != null) return;
            mUploadMessage = uploadMsg;
            selectImage();
        }

        // For Android &lt; 3.0
        public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg) {
            if (mUploadMessage != null) return;
            mUploadMessage = uploadMsg;
            selectImage();
        }

        // For Android  &gt; 4.1.1
        public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg, String acceptType, String capture) {
            if (mUploadMessage != null) return;
            mUploadMessage = uploadMsg;
            selectImage();
        }


    }


    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        if (requestCode == FILECHOOSER_RESULTCODE) {
            if (null == mUploadMessage &amp;&amp; null == mUploadCallbackAboveL) return;
            Uri result = data == null || resultCode != RESULT_OK ? null : data.getData();
            if (mUploadCallbackAboveL != null) {
                onActivityResultAboveL(requestCode, resultCode, data);
            } else if (mUploadMessage != null) {
                mUploadMessage.onReceiveValue(result);
                mUploadMessage = null;
            }
        }


        if (null == mUploadMessage)
            return;
        Uri uri = null;
        if (requestCode == REQ_CHOOSE) {
            uri = afterChosePic(data);
        }
        mUploadMessage.onReceiveValue(uri);
        mUploadMessage = null;
        super.onActivityResult(requestCode, resultCode, data);
    }


    @TargetApi(Build.VERSION_CODES.LOLLIPOP)
    private void onActivityResultAboveL(int requestCode, int resultCode, Intent data) {
        if (requestCode != FILECHOOSER_RESULTCODE
                || mUploadCallbackAboveL == null) {
            return;
        }

        Uri[] results = null;
        if (resultCode == Activity.RESULT_OK) {
            if (data == null) {

            } else {
                String dataString = data.getDataString();
                ClipData clipData = data.getClipData();

                if (clipData != null) {
                    results = new Uri[clipData.getItemCount()];
                    for (int i = 0; i &lt; clipData.getItemCount(); i++) {
                        ClipData.Item item = clipData.getItemAt(i);
                        results[i] = item.getUri();
                    }
                }

                if (dataString != null)
                    results = new Uri[]{Uri.parse(dataString)};
            }
        }
        mUploadCallbackAboveL.onReceiveValue(results);
        mUploadCallbackAboveL = null;
        return;
    }


    /**
     * 检查SD卡是否存在
     *
     * @return
     */
    public final boolean checkSDcard() {
        boolean flag = Environment.getExternalStorageState().equals(
                Environment.MEDIA_MOUNTED);
        if (!flag) {
            Toast.makeText(this, &quot;请插入手机存储卡再使用本功能&quot;, Toast.LENGTH_SHORT).show();
        }
        return flag;
    }

    String compressPath = &quot;&quot;;

    protected final void selectImage() {
        if (!checkSDcard())
            return;

        chosePic();
        compressPath = Environment
                .getExternalStorageDirectory()
                .getPath()
                + &quot;/fuiou_wmp/temp&quot;;
        new File(compressPath).mkdirs();
        compressPath = compressPath + File.separator
                + &quot;compress.jpg&quot;;
    }


    /**
     * 本地相册选择图片
     */
    private void chosePic() {
        FileUtils.delFile(compressPath);
        Intent innerIntent = new Intent(Intent.ACTION_GET_CONTENT); // &quot;android.intent.action.GET_CONTENT&quot;
        String IMAGE_UNSPECIFIED = &quot;image/*&quot;;
        innerIntent.setType(IMAGE_UNSPECIFIED); // 查看类型
        Intent wrapperIntent = Intent.createChooser(innerIntent, null);
        startActivityForResult(wrapperIntent, REQ_CHOOSE);
    }

    /**
     * 选择照片后结束
     *
     * @param data
     */
    private Uri afterChosePic(Intent data) {

        if (data != null) {
            // 获取图片的路径：
            String[] proj = {MediaStore.Images.Media.DATA};
            // 好像是android多媒体数据库的封装接口，具体的看Android文档
            Cursor cursor = managedQuery(data.getData(), proj, null, null, null);
//        if (cursor == null) {
//            Toast.makeText(this, &quot;上传的图片仅支持png或jpg格式&quot;, Toast.LENGTH_SHORT).show();
//            return null;
//        }
            // 按我个人理解 这个是获得用户选择的图片的索引值
            int column_index = cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DATA);
            // 将光标移至开头 ，这个很重要，不小心很容易引起越界
            cursor.moveToFirst();
            // 最后根据索引值获取图片路径
            String path = cursor.getString(column_index);
//            if (path != null &amp;&amp; (path.endsWith(&quot;.png&quot;) || path.endsWith(&quot;.PNG&quot;) || path.endsWith(&quot;.jpg&quot;) || path.endsWith(&quot;.JPG&quot;))) {
//            } else {
//                Toast.makeText(this, &quot;上传的图片仅支持png或jpg格式&quot;, Toast.LENGTH_SHORT).show();
//            }
            File newFile = FileUtils.compressFile(path, compressPath);
            return Uri.fromFile(newFile);
        }
        return null;
    }
</code></pre><p>都目前位置 问题得到完美的解决!!</p>
<p>参考:<a href="http://blog.isming.me/2015/12/21/android-webview-upload-file/" target="_blank" rel="external">http://blog.isming.me/2015/12/21/android-webview-upload-file/</a><br><a href="http://www.huochai.mobi/p/d/900504/?share_tid=846ea82e2685&amp;fmid=0" target="_blank" rel="external">http://www.huochai.mobi/p/d/900504/?share_tid=846ea82e2685&amp;fmid=0</a><br><a href="http://www.lai18.com/content/1191983.html" target="_blank" rel="external">http://www.lai18.com/content/1191983.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>要说Android中最厉害的组件莫过于Webview 了，夸张点说把这个组件放在屏幕上就可以算作一个简单地浏览器应用了。但你若认为这就万事大吉了，可太小看Webview这个磨人的妖精了，下面单就上传文件的这个坑来做展开。</p>
</blockquote>]]>
    
    </summary>
    
      <category term="Webview" scheme="http://kevinhero.github.io/tags/Webview/"/>
    
      <category term="技术" scheme="http://kevinhero.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android源码编译和内核编译]]></title>
    <link href="http://kevinhero.github.io/2016/02/21/Android%20Skills/Android%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/"/>
    <id>http://kevinhero.github.io/2016/02/21/Android Skills/Android源码编译/</id>
    <published>2016-02-21T06:33:45.000Z</published>
    <updated>2016-02-26T07:27:49.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u6E90_u7801_u7F16_u8BD1"><a href="#u6E90_u7801_u7F16_u8BD1" class="headerlink" title="源码编译"></a>源码编译</h2><h4 id="1_u3001_u7CFB_u7EDF_uFF1A_Ubuntu14-04_u4EE5_u4E0A__u6216_u8005_Mac"><a href="#1_u3001_u7CFB_u7EDF_uFF1A_Ubuntu14-04_u4EE5_u4E0A__u6216_u8005_Mac" class="headerlink" title="1、系统： Ubuntu14.04以上 或者 Mac"></a>1、系统： Ubuntu14.04以上 或者 Mac</h4><blockquote>
<p>下面的介绍都是在ubuntu下进行的</p>
</blockquote>
<h4 id="2_u3001JdK_u5B89_u88C5"><a href="#2_u3001JdK_u5B89_u88C5" class="headerlink" title="2、JdK安装"></a>2、JdK安装</h4><pre><code>$ sudo add-apt-repository &quot;deb http://archive.canonical.com/ lucid partner&quot;
$ sudo apt-get update
$ sudo apt-get install sun-java8-jdk
</code></pre><a id="more"></a> 
<h4 id="3_u3001_u5FC5_u5907_u8F6F_u4EF6_u5305_u5B89_u88C5"><a href="#3_u3001_u5FC5_u5907_u8F6F_u4EF6_u5305_u5B89_u88C5" class="headerlink" title="3、必备软件包安装"></a>3、必备软件包安装</h4><pre><code>$ sudo apt-get install git-core gnupg flex bison gperf build-essential \
  zip curl zlib1g-dev libc6-dev lib32ncurses5-dev ia32-libs \
  x11proto-core-dev libx11-dev lib32readline5-dev lib32z-dev \
  libgl1-mesa-dev g++-multilib mingw32 tofrodos python-markdown \
  libxml2-utils
</code></pre><h4 id="uFF14__u4E0B_u8F7Drepo_u5DE5_u5177"><a href="#uFF14__u4E0B_u8F7Drepo_u5DE5_u5177" class="headerlink" title="４　下载repo工具"></a>４　下载repo工具</h4><pre><code>$ cd ~
$ mkdir ~/bin
$ PATH=~/bin:$PATH
$ curl https://dl-ssl.google.com/dl/googlesource/git-repo/repo &gt; ~/bin/repo
$ chmod a+x ~/bin/repo
</code></pre><h4 id="uFF15__u4E0B_u8F7D_u6E90_u7801"><a href="#uFF15__u4E0B_u8F7D_u6E90_u7801" class="headerlink" title="５　下载源码"></a>５　下载源码</h4><blockquote>
<p>注意，下面最后一条命令，-b 后面的 Gingerbread 可以替换成 IceCreamSandwich 或者是 Froyo 中的任何一个。当然，还有其它选择，这个名字，就是 Android 版本的英文名，<a href="http://source.android.com/source/build-numbers.html" target="_blank" rel="external">http://source.android.com/source/build-numbers.html</a> 里面有所有的名字</p>
</blockquote>
<pre><code>$ mkdir CMROM
$ cd CMROM
$ repo init -u git://github.com/CyanogenMod/android.git
</code></pre><blockquote>
<p>如果是使用Google官方的源码编译</p>
</blockquote>
<pre><code>$ repo init -u https://android.googlesource.com/platform/manifest -b [Gingerbread]

[?]部分是Android的版本名称--详见http://source.android.com/source/build-numbers.html
</code></pre><ul>
<li>注意事项</li>
</ul>
<blockquote>
<p>默认情况下，访问Android源码是匿名的，为了防止下载服务器压力过大，下载服务器对每个ip都有下载限制。如果和别人共享一个公网IP(和别人共享路由器时，便是如此),Android源码服务器便会阻止多人同时下载，容易报错。为了解决该问题，需要使用带授权的访问，源码服务器此时对用户进行限制，而不是对ip进行限制。方法如下：<br>先创建密码：<a href="https://android.googlesource.com/new-password" target="_blank" rel="external">https://android.googlesource.com/new-password</a><br>该地址也经常无法访问，需多次尝试(可相隔几分钟)，若使用代理，就没法获得有用的密钥<br>再将密码保存在~/.netrc里<br>然后强制使用带授权的访问：<br> $repo init -u <a href="https://android.googlesource.com/a/platform/manifest" target="_blank" rel="external">https://android.googlesource.com/a/platform/manifest</a><br>在国内用repo初始化时，会经常遇到101的错误，因为有墙的原因，重试多次，运气好时便可以完成，设置代理的话会更顺利一点</p>
</blockquote>
<ul>
<li><p>源代码的目录结构</p>
<p>  在讲述Android源码编译的三个步骤之前，将先介绍Android源码目录结构，以便读者理清Android编译系统核心代码在Android源代码的位置。<br>Android源代码顶层目录结构如下所示：</p>
<p>../CyanogenMod/</p>
<pre><code>├──abi#应用二进制接口，不同的操作系统，应用二进制接口不同，因此linux上的二进制可执行文件在windows上无法执行
├──android#存放了一些xml文件，用于描述工程路径及其对应的远程仓库地址，repo工具将使用这些信息同步代码
├──bionic#bionic C库,Android没有使用标准的glibc库，而是自己重新实现了一套c/C++库，包括libc libdl libm libstdc++ libthread_db
├──bootable# 包含两个工程，recovery和diskinstaller，刷机或者系统升级都是由recovery完成的，
├──build#Android编译系统核心代码都存放在该目录，我们也将对该目录下的文件做详细分析
├──cts#Android兼容性测试套件标准
├──dalvik#dalvik JAVA虚拟机，Android用的java虚拟机和pc上用的jvm不一样
├──development#应用程序开发工具 有eclipse开发用的formatter配置
├──device#设备相关配置文件，存放规则 device/$vendor/$product
├──docs#网站文档
├──external#用到的第三方库 象busybox bash openssl等工具都存放在该目录
├──filelist#使用godir命令生成的索引文件
├──frameworks#核心框架——java及C++语言，可生成framework.jar
├──gdk#glass开发Sdk
├──hardware#部分厂家开源的硬件适配层HAL代码
├──kernel#内核源码目录 存放规则kernel/$vendor/$product
├──libcore#一些有用的库 像xml Jason luni
├──libnativehelper#Support functions for Android’s class libraries
├──Makefile#在顶层目录编译，利用的默认Makefile，它只是简单包含了build/core/main.mk
├──ndk#ndk开发工具
├──packages#Android apk程序所在目录,象settings，gallery等程序
├──pdk#Platform Development Kit The goal of the PDK release is to help chipset vendors and OEMs to migrate to a new relelase
├──prebuilt#x86和arm架构下预编译的一些资源
├──prebuilts#有clang eclipse gcc misc ndk qemu-kernel sdk tools等子目录，交叉编译工具链所在目录
├──sdk#sdk及模拟器
├──system#核心代码，包含了最小化可启动的环境，还有底层调试及检查工具，adbd也在system/core目录
├──tools#有子目录build和motodev，可能跟摩托罗拉有关
├──vendor#设备制造商专用的配置存放目录，存放规则vendor/$vendor/$product，cm编写的apk也放在该目录
</code></pre><p>build子目录存放编译系统的核心代码，包含着138个makefile，15个shell脚本，19个python脚本，7个C文件，7个C++文件，16个头文件，因此如果想分析编译系统核心代码，使用的IDE需支持这些编程语言，推荐使用eclipse，安装一些插件就可以很方便地查看这些代码<br>build子文件夹的目录结构如下所示：<br>build/</p>
<pre><code>├── buildspec.mk.default#buildspec的模版文件，可定义一些变量比如TARGET_BUILD_VARIANT:=user，TARGET_BUILD_TYPE:=release
├── CleanSpec.mk#增量编译时，会执行该文件里的命令，这些命令一般用于清除中间文件
├── core#编译系统的核心文件放在该目录，主要是一些makefile
├── envsetup.sh#编译时需先用source envsetup.sh设置好环境变量，该脚本提供了许多有用的命令，比如cout,croot,cgrep,在详细介绍Android编译步骤时会列出来
├── libs#是一个C++模块，编译后可生成libhost.a静态库，里面的函数主要用于与编译主机交互
├── target#包含编译目标相关的makefile，它有两个子文件夹 board和product，产品都在该目录下定义，比如generic,full产品，定义设备产品时，会从这里继承产品
└── tools#各种工具，多数使用python编写，工具有用于签名的signpak, 用于下载device配置的roomservice.py等，后续将详细介绍
</code></pre><p>我们在阅读build核心代码时，可能最头疼的就是变量，编译系统里有成百上千的变量，我们常常不知道其含义，容易一头雾水，为此我做了一个编译系统的参考手册供大家查阅， 可以很方便地检索变量，查看变量的意义，并有示例值。链接：<a href="http://android.cloudchou.com/" target="_blank" rel="external">http://android.cloudchou.com/</a></p>
</li>
</ul>
<h4 id="uFF16__u540C_u6B65_u6E90_u7801"><a href="#uFF16__u540C_u6B65_u6E90_u7801" class="headerlink" title="６　同步源码"></a>６　同步源码</h4><blockquote>
<p>别看只有一条命令，但是，下载的时间，很长的，推荐这条命令，晚上的时候，挂机执行，第二天早上，差不多能下载完。毕竟是 3GB 多的东西呢。</p>
</blockquote>
<pre><code>$ repo sync -j 10
</code></pre><ul>
<li>注意事项<blockquote>
<p>在工作目录里使用repo sync同步代码，期间可能会多次卡死，需要ctrl+z，然后杀掉进程，然后再次使用repo sync，因为其支持断点续传，不需要担心会从头开始下载 还可以开启多个进程同时下载，使用repo sync -j4<br>j4代表开启4个线程,建议i5以上的开4,i7开8</p>
</blockquote>
</li>
</ul>
<h4 id="4-_u7F16_u8BD1_u6E90_u4EE3_u7801"><a href="#4-_u7F16_u8BD1_u6E90_u4EE3_u7801" class="headerlink" title="4.编译源代码"></a>4.编译源代码</h4><ul>
<li><p>初始化编译环境</p>
<pre><code>$source build/envsetup.sh
</code></pre></li>
</ul>
<ul>
<li><p>选择一个目标设备，以cm下编译htc one为例</p>
<pre><code>$lunch cm_m7ul-eng
</code></pre></li>
<li><p>此时会从网站下载m7ul的device配置以及内核源代码<br>所有目标设备的格式为BUILD-BUILDTYPE， BUILD是选择的目标设备，比如cm_m7,而BUILD_TYPE是eng，user或者userdebug</p>
<pre><code>user: 适合发布产品时使用，访问受限
userdebug: 和user类型类似，有root权限和调试能力，适合调试
eng: 开发配置，有额外的调试工具
</code></pre></li>
<li><p>编译源代码：</p>
<pre><code>$mka
</code></pre></li>
</ul>
<h2 id="u5185_u6838_u7F16_u8BD1"><a href="#u5185_u6838_u7F16_u8BD1" class="headerlink" title="内核编译"></a>内核编译</h2><h4 id="uFF11__u4E0B_u8F7D_u5185_u6838_u6E90_u7801"><a href="#uFF11__u4E0B_u8F7D_u5185_u6838_u6E90_u7801" class="headerlink" title="１　下载内核源码"></a>１　下载内核源码</h4><p>　　每一个 Android 手机厂商，都会在自己的网站上公布已经生产的手机的内核源码，大家去小米手机的官方网站下载即可。</p>
<h4 id="uFF12__u89E3_u538B_u5185_u6838_u6E90_u7801_u5305"><a href="#uFF12__u89E3_u538B_u5185_u6838_u6E90_u7801_u5305" class="headerlink" title="２　解压内核源码包"></a>２　解压内核源码包</h4><p>　　内核源码，一般是以压缩包的形式提供下载的。大家下载之后，在 Ubuntu 中解压即可，因为命令非常简单，这里不提供。</p>
<h4 id="uFF13__u914D_u7F6E_u4EA4_u53C9_u5DE5_u5177_u94FE_uFF08_u7F16_u8BD1_u5668_uFF09_u8DEF_u5F84"><a href="#uFF13__u914D_u7F6E_u4EA4_u53C9_u5DE5_u5177_u94FE_uFF08_u7F16_u8BD1_u5668_uFF09_u8DEF_u5F84" class="headerlink" title="３　配置交叉工具链（编译器）路径"></a>３　配置交叉工具链（编译器）路径</h4><p>　　学过编程的人都知道，源码要编译成程序，必须要用编译器编译。而且手机的 CPU 不同于 PC 机，所以，得用专用的工具，即“交叉工具链”。<br>　　打开内核源码目录下的 Makefile 文件，找到“CROSS_COMPILE”定义的地方，确保和下面一模一样。</p>
<pre><code>CROSS_COMPILE := $(shell if [ -f .cross_compile ]; then \
    cat .cross_compile; \
    fi)
</code></pre><p>　　接着，在内核源码目录下面，新建一个叫“.cross_compile”的文件，在文件中，输入以下分隔线中间的一行内容</p>
<pre><code>/（这前面，是 Android 源码的绝对路径，要求您有一点 Ubuntu 使用经验，否则不能完成）/ANDROID_SRC/prebuilt/linux-x86/toolchain/arm-eabi-4.4.0/bin/arm-eabi-
</code></pre><p>　　打开已经下载的 Android 源码（前面有提到如何下载）目录，在 ANDROID_SRC/prebuilt/linux-x86/toolchain 下面，你会发现有几个工具链文件夹，名字为别是 arm-eabi-4.2.1（4.3.1，4.4.0，4.4.3），如果，你是用 64位 系统，用哪个都可以。如果是 32位 系统，貌似用 4.4.3 会出错。建议用 4.4.0。<br>　注：ANDROID_SRC 是指您电脑上，Android 源码存储的目录，请根据实际情况，进行替换。</p>
<h4 id="uFF14__u201C-config_u201D_u914D_u7F6E_u6587_u4EF6"><a href="#uFF14__u201C-config_u201D_u914D_u7F6E_u6587_u4EF6" class="headerlink" title="４　“.config”配置文件"></a>４　“.config”配置文件</h4><p>　　在内核源码的目录下面，一定要有一个名字为“.config”的文件，这个文件，是小米手机的内核配置。如果内核源码的根目录下，没有发现这个文件，或者，发现的文件不是针对小米手机配置的，在 LINUX_SRC/arch/arm/configs 下面，找到针对小米手机的配置文件，复制到内核源码根目录，即可。<br>　注：LINUX_SRC 是指您电脑上，内核源码存储的目录，请根据实际情况，进行替换。</p>
<h4 id="uFF15__u9009_u62E9_u5185_u6838_u914D_u7F6E_u9009_u9879"><a href="#uFF15__u9009_u62E9_u5185_u6838_u914D_u7F6E_u9009_u9879" class="headerlink" title="５　选择内核配置选项"></a>５　选择内核配置选项</h4><pre><code>$ cd LINUX_SRC
$ make config
</code></pre><p>这里的config文件,是在内核源码根目录下的 config文件,如果没有直接名称为config文件的,看看是否有前缀,例如:menuconfig<br>　　输入上面的命令后，会出现一个怪怪的列表，通过按“空格键”，进行“选择”或“取消”某些选项。完成后，记得保存。<br>　注：在手机使用中，有的用户总抱怨不能使用“Wifi Tether”，不能“使用笔记本共享出来的宽带上网”，都是因为这一步，内核的选项没有被正确设置。读完这篇文章之后，大家可以自己动手了。</p>
<h4 id="uFF16__u201C_u6700_u540E_u4E00_u6B65_u201D"><a href="#uFF16__u201C_u6700_u540E_u4E00_u6B65_u201D" class="headerlink" title="６　“最后一步”"></a>６　“最后一步”</h4><pre><code>$ cd LINUX_SRC
$ make
</code></pre><p>　编译完成之后，会在“kernel/goldfish/arch/arm/boot/”目录下生成名为zImage的文件。 </p>
<h2 id="u7528_u5230_u7684_u547D_u4EE4"><a href="#u7528_u5230_u7684_u547D_u4EE4" class="headerlink" title="用到的命令"></a>用到的命令</h2><h4 id="u4E0B_u8F7DAndroid_u6E90_u7801_u7B80_u8981_u6D41_u7A0B"><a href="#u4E0B_u8F7DAndroid_u6E90_u7801_u7B80_u8981_u6D41_u7A0B" class="headerlink" title="下载Android源码简要流程"></a>下载Android源码简要流程</h4><pre><code>a. 获取repo文件: curl http://commondatastorage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo .注意执行该文件需要python2.5以上版本,如果是2.4.3的python版本就无法执行这个文件脚本;
b. 修改repo权限 : chmod a+x ~/bin/repo , 如果repo没有执行权限, 该脚本也无法执行;
c. 初始化repo文件 : repo init -u https://android.googlesource.com/platform/manifest -b android-2.3.3_r1 , 这里要下载2.3.3版本的源码;
d. 开始下载 :repo sync , 执行该命令就可以开始下载Android源码;
</code></pre><h4 id="u4E0B_u8F7DAndroid_u5185_u6838_u6E90_u7801_u7B80_u8981_u6D41_u7A0B"><a href="#u4E0B_u8F7DAndroid_u5185_u6838_u6E90_u7801_u7B80_u8981_u6D41_u7A0B" class="headerlink" title="下载Android内核源码简要流程"></a>下载Android内核源码简要流程</h4><pre><code>a. 使用git下载 : git clone https://android.googlesource.com/kernel/goldfish.git ;
b. 查看分支 : git branch -a ;
c. 检出版本 : git checkout remotes/origin/android-goldfish-2.6.29 ;
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u6E90_u7801_u7F16_u8BD1"><a href="#u6E90_u7801_u7F16_u8BD1" class="headerlink" title="源码编译"></a>源码编译</h2><h4 id="1_u3001_u7CFB_u7EDF_uFF1A_Ubuntu14-04_u4EE5_u4E0A__u6216_u8005_Mac"><a href="#1_u3001_u7CFB_u7EDF_uFF1A_Ubuntu14-04_u4EE5_u4E0A__u6216_u8005_Mac" class="headerlink" title="1、系统： Ubuntu14.04以上 或者 Mac"></a>1、系统： Ubuntu14.04以上 或者 Mac</h4><blockquote>
<p>下面的介绍都是在ubuntu下进行的</p>
</blockquote>
<h4 id="2_u3001JdK_u5B89_u88C5"><a href="#2_u3001JdK_u5B89_u88C5" class="headerlink" title="2、JdK安装"></a>2、JdK安装</h4><pre><code>$ sudo add-apt-repository &quot;deb http://archive.canonical.com/ lucid partner&quot;
$ sudo apt-get update
$ sudo apt-get install sun-java8-jdk
</code></pre>]]>
    
    </summary>
    
      <category term="源码" scheme="http://kevinhero.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="技术" scheme="http://kevinhero.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Kotlin 1.0 正式版发布啦]]></title>
    <link href="http://kevinhero.github.io/2016/02/18/New%20Lan/Kotlin1.0%E6%AD%A3%E5%BC%8F%E7%89%88%E5%8F%91%E5%B8%83/"/>
    <id>http://kevinhero.github.io/2016/02/18/New Lan/Kotlin1.0正式版发布/</id>
    <published>2016-02-18T15:01:14.000Z</published>
    <updated>2016-04-07T03:45:13.000Z</updated>
    <content type="html"><![CDATA[<p>就在昨天，Android领域的Swift–Kotlin 1.0发布了，详细的新版本发布介绍请「阅读原文」查看官方发行说明。</p>
<h3 id="u4F55_u4E3AKotlin_uFF1F"><a href="#u4F55_u4E3AKotlin_uFF1F" class="headerlink" title="何为Kotlin？"></a>何为Kotlin？</h3><p>Kotlin 是一门实用的编程语言，可用于 JVM 和 Android 程序开发，Kotlin 结合了面向对象和函数式特性，致力于互操作性，安全，简洁和工具支持。</p>
<p>Kotlin 是一门通用的语言，只要能用 Java 的地方就能用 Kotlin，包含：服务器程序开发，移动应用开发（Android），桌面客户端程序开发。 Kotlin 支持所有主要的开发工具以及服务，比如：</p>
<pre><code>IntelliJ IDEA，Android Studio 和 Eclipse
Maven, Gradle 和Ant
Spring Boot（Kotlin 支持今天正式发布！）
GitHub，Slack，甚至 Minecraft
</code></pre><a id="more"></a>
<p>Kotlin 的主要特点之一是Java+Kotlin 混合工程的互操作性以及无缝兼容，使引入Kotlin的过程简单容易，并达成更少的重复性代码(boilerplate code)和更佳的类型安全(type-safety)。<br>Kotlin 还有一个扩展标准库(extensive standard library)能让日常工作变得简单顺畅，它能帮助保持低内存占用 (bytecode footprint)。当然，Kotlin 中自然可以使用 Java 库，反之亦然。</p>
<h3 id="u4E3A_u4F55_u8BF4Kotlin_u975E_u5E38_u9002_u5408_u4E8EAndroid_uFF1F"><a href="#u4E3A_u4F55_u8BF4Kotlin_u975E_u5E38_u9002_u5408_u4E8EAndroid_uFF1F" class="headerlink" title="为何说Kotlin非常适合于Android？"></a>为何说Kotlin非常适合于Android？</h3><p>基本上，这是因为Kotlin的所有特性都非常适合于Android生态圈。Kotlin的库非常小，我们在开发过程中不会引入额外的成本。其大小 相当于support-v4库，我们在很多项目中所使用的库都比Kotlin大。除此之外，Android Studio（官方的Android IDE）是基于IntelliJ构建的。这意味着我们的IDE对该语言提供了非常棒的支持。我们可以很快就配置好项目，并且使用熟悉的IDE进行开发。我 们可以继续使用Gradle以及IDE所提供的各种运行与调试特性。这与使用Java开发应用别无二致。归功于互操作性，我们可以在Kotlin代码中使 用Android SDK而不会遇到任何问题。实际上，部分SDK使用起来会变得更加简单，这是因为互操作性是非常智能的，比如说它可以将getters与setters映 射到Kotlin属性上，我们也可以以闭包的形式编写监听器。</p>
<h3 id="u5982_u4F55_u5728Android_u5F00_u53D1_u4E2D_u4F7F_u7528Kotlin_uFF1F"><a href="#u5982_u4F55_u5728Android_u5F00_u53D1_u4E2D_u4F7F_u7528Kotlin_uFF1F" class="headerlink" title="如何在Android开发中使用Kotlin？"></a>如何在Android开发中使用Kotlin？</h3><p>过程非常简单，只需按照下面的步骤来即可：</p>
<blockquote>
<p>从IDE plugins中下载Kotlin插件<br>在模块中创建Kotlin类<br>使用“Configure Kotlin in Project…”<br>开始编码</p>
</blockquote>
<h3 id="Kotlin_u7684_u4E00_u4E9B_u7279_u6027"><a href="#Kotlin_u7684_u4E00_u4E9B_u7279_u6027" class="headerlink" title="Kotlin的一些特性"></a>Kotlin的一些特性</h3><p>Kotlin拥有大量非常打动人心的特性，这里无法一一进行介绍，不过我们来看一下其中最为重要的一些。</p>
<h4 id="Null_u5B89_u5168"><a href="#Null_u5B89_u5168" class="headerlink" title="Null安全"></a>Null安全</h4><p>如前所述，Kotlin是null安全的。如果一个类型可能为null，那么我们就需要在类型后面加上一个?。这样，每次在使用该类型的变量时，我们都需要进行null检查。比如说，如下代码将无法编译通过：</p>
<pre><code>var artist: Artist? = null?
artist.print()
</code></pre><p>第2行会显示一个错误，因为没有对变量进行null检查。我们可以这样做：</p>
<pre><code>if (artist != null) {
?    artist.print()?
}
</code></pre><p>这展示了Kotlin另一个出色的特性：智能类型转换。如果检查了变量的类型，那就无需在检查作用域中对其进行类型转换。这样，我们现在就可以在 if中将artist作为Artist类型的变量了。这对于其他检查也是适用的。还有一种更简单的方式来检查null，即在调用对象的函数前使用?。甚至 还可以通过Elvis运算符?提供另外一种做法：</p>
<pre><code>val name = artist?.name ?: &quot;&quot;
</code></pre><h4 id="u6570_u636E_u7C7B"><a href="#u6570_u636E_u7C7B" class="headerlink" title="数据类"></a>数据类</h4><p>在Java中，如果想要创建数据类或是POJO类（只保存了一些状态的类），我们需要创建一个拥有大量字段、getters与setters的类，也许还要提供toString与equals方法：</p>
<pre><code>public class Artist {
    private long id;
    private String name;
    private String url;
    private String mbid;

    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getUrl() {
        return url;
    }

    public void setUrl(String url) {
        this.url = url;
    }

    public String getMbid() {
        return mbid;
    }

    public void setMbid(String mbid) {
        this.mbid = mbid;
    }

    @Override
    public String toString() {
        return &quot;Artist{&quot; +
                &quot;id=&quot; + id +
                &quot;, name=&apos;&quot; + name + &apos;\&apos;&apos; +
                &quot;, url=&apos;&quot; + url + &apos;\&apos;&apos; +
                &quot;, mbid=&apos;&quot; + mbid + &apos;\&apos;&apos; +
                &apos;}&apos;;
    }
}
</code></pre><p>在Kotlin中，上述代码可以写成下面这样：</p>
<pre><code>data class Artist (?
    var id: Long,
    var name: String,
    var url: String,
    var mbid: String)
</code></pre><p>Kotlin使用属性而非字段。基本上，属性就是字段加上其getter与setter。</p>
<h4 id="u4E92_u64CD_u4F5C"><a href="#u4E92_u64CD_u4F5C" class="headerlink" title="互操作"></a>互操作</h4><p>Kotlin提供了一些非常棒的互操作特性，这对于Android开发帮助非常大。其中之一就是拥有单个方法的接口与lambda表达式之间的映射。这样，下面这个单击监听器：</p>
<pre><code>view.setOnClickListener(object : View.OnClickListener {
    override fun onClick(v: View) {
        toast(&quot;Click&quot;)?
    }
?})
</code></pre><p>可以写成这样：</p>
<pre><code>view.setOnClickListener { toast(&quot;Click&quot;) }
</code></pre><p>此外，getters与setters都会自动映射到属性上。这并不会造成性能上的损失，因为字节码实际上只是调用原来的getters与setters。如下代码所示：</p>
<pre><code>supportActionBar.title = title
textView.text = title
contactsList.adapter = ContactsAdapter()
</code></pre><p>####Lambda表达式</p>
<p>Lambda表达式会在极大程度上精简代码，不过重要的是借助于Lambda表达式，我们可以做到之前无法实现或是实现起来非常麻烦的事情。借助于 Lambda表达式，我们可以以一种更加函数式的方式来思考问题。Lambda表达式其实就是一种指定类型，并且该类型定义了一个函数的方式。比如说，我 们可以像下面这样定义一个变量：</p>
<pre><code>val listener: (View) -&gt; Boolean
</code></pre><p>该变量可以声明一个函数，它接收一个view并返回这个函数。我们需要通过闭包的方式来定义函数的行为：</p>
<pre><code>val listener = { view: View -&gt; view is TextView }
</code></pre><p>上面这个函数会接收一个View，如果该view是TextView的实例，那么它就会返回true。由于编译器可以推断出类型，因此我们无需指定。还可以更加明确一些：</p>
<pre><code>val listener: (View) -&gt; Boolean = { view -&gt; view is TextView }
</code></pre><p>借助于Lambda表达式，我们可以抛弃回调接口的使用。只需设置希望后面会被调用的函数即可：</p>
<pre><code>fun asyncOperation(value: Int, callback: (Boolean) -&gt; Unit) {
    ...
    callback(true)?
}

asyncOperation(5) { result -&gt; println(&quot;result: $result&quot;) }
</code></pre><p>还有一种更加简洁的方式，如果函数只接收一个参数，那就可以使用保留字it：</p>
<pre><code>asyncOperation(5) { println(&quot;result: $it&quot;) }
</code></pre><h4 id="Anko"><a href="#Anko" class="headerlink" title="Anko"></a>Anko</h4><p>Anko是Kotlin团队开发的一个库，旨在简化Android开发。其主要目标在于提供一个DSL，使用Kotlin代码来声明视图：</p>
<pre><code>verticalLayout {
    val name = editText()
    button(&quot;Say Hello&quot;) {
        onClick { toast(&quot;Hello, ${name.text}!&quot;) }
    }
}
</code></pre><p>它还提供了其他一些很有用的特性。比如说，导航到其他Activity：</p>
<pre><code>startActivity(&quot;id&quot; to res.id, &quot;name&quot; to res.name)
</code></pre><h3 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h3><p>如你所见，Kotlin在很多方面都简化了Android的开发工作。它会提升你的生产力，并且可以通过非常不同且更加简单的方式来解决一些常见的问题，你开始学习了么？</p>
<h3 id="u53C2_u8003_u8D44_u6599_uFF1A"><a href="#u53C2_u8003_u8D44_u6599_uFF1A" class="headerlink" title="参考资料："></a>参考资料：</h3><pre><code>1. http://www.infoq.com/cn/news/2016/01/kotlin-android?utm_campaign=infoq_content&amp;utm_source=infoq&amp;utm_medium=feed&amp;utm_term=global
2. http://www.oschina.net/news/70734/kotlin-1-0-final
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>就在昨天，Android领域的Swift–Kotlin 1.0发布了，详细的新版本发布介绍请「阅读原文」查看官方发行说明。</p>
<h3 id="u4F55_u4E3AKotlin_uFF1F"><a href="#u4F55_u4E3AKotlin_uFF1F" class="headerlink" title="何为Kotlin？"></a>何为Kotlin？</h3><p>Kotlin 是一门实用的编程语言，可用于 JVM 和 Android 程序开发，Kotlin 结合了面向对象和函数式特性，致力于互操作性，安全，简洁和工具支持。</p>
<p>Kotlin 是一门通用的语言，只要能用 Java 的地方就能用 Kotlin，包含：服务器程序开发，移动应用开发（Android），桌面客户端程序开发。 Kotlin 支持所有主要的开发工具以及服务，比如：</p>
<pre><code>IntelliJ IDEA，Android Studio 和 Eclipse
Maven, Gradle 和Ant
Spring Boot（Kotlin 支持今天正式发布！）
GitHub，Slack，甚至 Minecraft
</code></pre>]]>
    
    </summary>
    
      <category term="Kotlin" scheme="http://kevinhero.github.io/tags/Kotlin/"/>
    
      <category term="技术" scheme="http://kevinhero.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Ibeacon]]></title>
    <link href="http://kevinhero.github.io/2016/01/25/%E9%9A%8F%E7%AC%94/Ibeacon/"/>
    <id>http://kevinhero.github.io/2016/01/25/随笔/Ibeacon/</id>
    <published>2016-01-25T04:01:14.000Z</published>
    <updated>2016-02-19T09:12:16.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u662F_u4EC0_u4E48_uFF1F"><a href="#u662F_u4EC0_u4E48_uFF1F" class="headerlink" title="是什么？"></a>是什么？</h3><p>iBeacon是apple公司提出的“一种可以让附近手持电子设备检测到的一种新的低功耗、低成本信号传送器”的一套可用于室内定位系统的协议。 这种技术可以使一个智能手机或其他装置在一个iBeacon基站的感应范围内执行相应的命令。</p>
<p>这是帮助智能手机确定他们大概位置或环境的一个应用程序。在一个iBeacon基站的帮助下，智能手机的软件能大概找到它和这个iBeacon基站的相对位置。iBeacon能让手机收到附近售卖商品的通知，也可以让消费者不用拿出钱包或信用卡就能在销售点的POS机上完成支付。iBeacon技术通过低功耗蓝牙（BLE），也就是我们所说的智能蓝牙来实现。</p>
<p>iBeacon为利用低功耗蓝牙可以近距离感测的功能来传输通用唯一识别码的一个app或操作系统。 这个识别码可以在网上被查找到用以确定设备的物理位置或者可以在设备上触发一个动作比如在社交媒体签到或者推送通知。</p>
<p>各种供应商创造了不同形式的iBeacon硬件设备，包括小硬币电池设备，随身碟和蓝牙4.0通用加密狗。<br><a id="more"></a></p>
<h3 id="u529F_u80FD"><a href="#u529F_u80FD" class="headerlink" title="功能"></a>功能</h3><p>一套iBeacon的部署由一个或多个在一定范围内发射传输他们唯一的识别码iBeacon信标设备组成。接收设备上的软件可以查找iBeacon并实现多种功能，比如通知用户，接收设备也可以通过链接iBeacons从iBeacon的通用属性配置服务来恢复价值。iBeacons不推送通知给接收设备（除了他们自己的ID），然而，手机软件可以使用从iBeacons接收到的信号来自己推送通知。</p>
<h3 id="u533A_u57DF_u76D1_u6D4B"><a href="#u533A_u57DF_u76D1_u6D4B" class="headerlink" title="区域监测"></a>区域监测</h3><p>区域监测仅限20个区域，可以在后台运行，即使app在后台运行或者手机锁屏，依然有不同的应用通知监听app（用户）进入/退出该区。区域监测也给了关闭的app一个反应的机会，在进入相关区域时允许弹出小窗口。</p>
<h3 id="u5206_u7C7B"><a href="#u5206_u7C7B" class="headerlink" title="分类"></a>分类</h3><p>分类工作仅应用在前端，但是将返回数组iBeacons的所有属性（UUID等）。</p>
<p>一个iOS设备接收一个iBeacon的传输可以近乎于iBeacon的距离，iBeacon的传输距离分为3个不同的范围：</p>
<p>最近：几厘米<br>中距：几米<br>远距：大于10米<br>当用户进入、退出或者在区域内徘徊时，iBeacon的广播有能力进行传播，根据用户和Beacon的距离，这三个距离范围可以相互交互。</p>
<p>iBeacon传输的最大射程将取决于位置、现场布置、障碍物(例如在一个皮革手袋或厚情况下)。标准信号有近似的70米，远程信号可达450米。</p>
<h3 id="u7535_u529B_u6D88_u8017"><a href="#u7535_u529B_u6D88_u8017" class="headerlink" title="电力消耗"></a>电力消耗</h3><p>Comparison of 16 major beacon hardware of battery life in months (higher is better) by Aislelabs’ The Hitchickers Guide to iBeacon Hardware[15]<br>低功耗蓝牙相比于传统蓝牙在功耗和效率方面有显著提高，在16个不同的iBeacon厂商的一项研究报告称，电池的寿命在1到24个月的范围之内。苹果公司，用一枚纽扣电池提供了1-3个月的生活，设置了100ms的广告频率，这样如果电池提供时间增加到2~3年就相当于广告频率增到到900ms。</p>
<p>在部署beacon启用手机app时，手机电池的消耗是一个必须要考虑的因素。最新的报告显示附近有ibeacon时，旧的手机会消耗更多的电量，然而新一点的手机在同样的环境下则更加高效。除了浏览手机消耗的时间，扫描附近的浏览量和信标数依然是电池消耗很重要的因素，正如Aislelabs指出的报告一样。在后续的报告中，Aislelabs发现了苹果5s，苹果5c和旧版的苹果4s在电池消耗方面的一个大幅的改善。在10个ibeacons的周围，苹果4s每小时消耗了11%的电量而苹果5s则每小时比它少消耗5%的电量。一个高效节能的ibeacon应用程序需要考虑这些方面去保持应用的响应性和电池消耗之间的平衡。</p>
<h3 id="u6700_u65B0_u8FDB_u5C55"><a href="#u6700_u65B0_u8FDB_u5C55" class="headerlink" title="最新进展"></a>最新进展</h3><p>2013年中苹果公司介绍了iBeacons，专家撰写了文章表示iBeacons怎样通过简化支付提供现场支持来帮助零售业。随着IOS7的推出，零售商和其他中小型企业将能够使用蓝牙4.0技术。据报道，2013年12月6日苹果在其254个零售店中使用了iBeacons。</p>
<p>2014年5月，花费最低5美金到30美金以上就可购买不同的iBeacons硬件设备。每一个不同的设备对自己的默认发射功率和广告频率都有不同的默认设置。一些硬件的广告频率可以快到每100毫秒一次而还有一些的可以低至1赫兹。 iBeacon技术还在襁褓期，有报道指出一个软件存在的异样，最新安卓系统的蓝牙堆栈在面对许多iBeacons时会崩溃。</p>
<h3 id="u517C_u5BB9_u8BBE_u5907"><a href="#u517C_u5BB9_u8BBE_u5907" class="headerlink" title="兼容设备"></a>兼容设备</h3><p>支持蓝牙4.0的IOS设备（iPhone4s及以上，iPad第三代及以上，iPad mini第一代及以上，iPod Touch第五代）。<br>支持OS X Mavericks 10.9操作系统和蓝牙4.0的苹果计算机。<br>安卓4.3及以上（如三星 Galaxy S3/S4/S4 Mini, 三星 Galaxy Note 2/3, HTC One, Google/LG Nexus 7 2013 version/Nexus 4/Nexus 5, HTC Butterfly, OnePlus One）<br>支持Lumia Cyan及以上更新服务Windows Phone设备（报告显示，不包含Windows Phone 8.1）</p>
<h3 id="u7F3A_u70B9"><a href="#u7F3A_u70B9" class="headerlink" title="缺点"></a>缺点</h3><p>iBeacon协议是开放的，且易于伪造，部署的节点可能被其他人恶意使用，甚至伪造一个ID完全相同的 Beacon，支付安全很难保证。该应用可以搜集用户的位置信息、行为信息，这些隐私信息的安全要如何保障尚待规范。</p>
<p>iBeacon太麻烦，对于用户来说手机上需要下载不同的 App 才能在不同的商场、地段体验，对于商户来说也没有一个通用、快捷的后台。</p>
<p>手机必须支持蓝牙4.0以上并保持蓝牙开启状态</p>
<p>iBeacons由于依赖于蓝牙技术，传输距离较大，而且通过基站传输数据，那么，如果基站被攻击，连接到基站的设备就很危险了。iBeacons是通过蓝牙实现的，一般来说两个设备建立连接都需要几秒甚至十几秒吧，操作也比较繁琐，这个对于用户来说体验就相对较差了。</p>
<p>在再室外环境 Beacon的信号特别不稳定，尤其是一大风，本来已经搜索到的Beacon瞬间就“风逝”了。<br>测距技术主要有三种：AoA（角测距）、RSSI（基于接收信号强度）和ToA（时间测距）。<br>低功耗蓝牙（即BLE）的测距主要是通过RSSI。虽然从一定程度上说RSSI只需较少的通信开销和较低的实现复杂度,这在能量有限的网络节点中是非常重要的。<br>同时它也有一个致命的缺点——过渡依赖环境。RSSI易受环境变化影响，从而只能是大致测距，想要提高精确度，需要至少三个Beacon，利用圆覆盖区重叠区域得到比较精确的距离。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u662F_u4EC0_u4E48_uFF1F"><a href="#u662F_u4EC0_u4E48_uFF1F" class="headerlink" title="是什么？"></a>是什么？</h3><p>iBeacon是apple公司提出的“一种可以让附近手持电子设备检测到的一种新的低功耗、低成本信号传送器”的一套可用于室内定位系统的协议。 这种技术可以使一个智能手机或其他装置在一个iBeacon基站的感应范围内执行相应的命令。</p>
<p>这是帮助智能手机确定他们大概位置或环境的一个应用程序。在一个iBeacon基站的帮助下，智能手机的软件能大概找到它和这个iBeacon基站的相对位置。iBeacon能让手机收到附近售卖商品的通知，也可以让消费者不用拿出钱包或信用卡就能在销售点的POS机上完成支付。iBeacon技术通过低功耗蓝牙（BLE），也就是我们所说的智能蓝牙来实现。</p>
<p>iBeacon为利用低功耗蓝牙可以近距离感测的功能来传输通用唯一识别码的一个app或操作系统。 这个识别码可以在网上被查找到用以确定设备的物理位置或者可以在设备上触发一个动作比如在社交媒体签到或者推送通知。</p>
<p>各种供应商创造了不同形式的iBeacon硬件设备，包括小硬币电池设备，随身碟和蓝牙4.0通用加密狗。<br>]]>
    
    </summary>
    
      <category term="Ibeacon" scheme="http://kevinhero.github.io/tags/Ibeacon/"/>
    
      <category term="技术" scheme="http://kevinhero.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android MotionEvent详解]]></title>
    <link href="http://kevinhero.github.io/2015/12/21/Android%20Skills/Android%20MotionEvent%E8%AF%A6%E8%A7%A3/"/>
    <id>http://kevinhero.github.io/2015/12/21/Android Skills/Android MotionEvent详解/</id>
    <published>2015-12-21T04:12:45.000Z</published>
    <updated>2016-04-06T04:29:56.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u4E8B_u4EF6_u5750_u6807_u7684_u542B_u4E49"><a href="#u4E8B_u4EF6_u5750_u6807_u7684_u542B_u4E49" class="headerlink" title="事件坐标的含义"></a>事件坐标的含义</h3><p> 我们都知道，每个触摸事件都代表用户在屏幕上的一个动作，而每个动作必定有其发生的位置。在MotionEvent中就有一系列与标触摸事件发生位置相关的函数：</p>
<p>getX()和getY()：由这两个函数获得的x,y值是相对的坐标值，相对于消费这个事件的视图的左上点的坐标。<br>getRawX()和getRawY():有这两个函数获得的x,y值是绝对坐标，是相对于屏幕的。<a id="more"></a><br> 在之前的文章中，我们曾经分析过事件如何通过层层分发，最终到达消费它的视图手中。其中<strong>ViewGroup</strong>的<code>dispatchTransformedTouchEvent</code>函数有如下一段代码:</p>
<pre><code>final float offsetX = mScrollX - child.mLeft;
final float offsetY = mScrollY - child.mTop;
event.offsetLocation(offsetX, offsetY);
handled = child.dispatchTouchEvent(event);
event.offsetLocation(-offsetX, -offsetY);
</code></pre><p> 这段代码清晰展示了父视图把事件分发给子视图时，getX()和getY所获得的相关坐标是如何改变的。当父视图处理事件时，上述两个函数获得的相对坐标是相对于父视图的，然后通过上边这段代码，调整了相对坐标的值，让其变为相对于子视图啦。</p>
<p> 涉及MotionEvent使用的代码一般如下:</p>
<pre><code>action = MotionEventCompat.getActionMasked(event);
switch(action) {
    MotionEvent.ACTION_DOWN:
        break;
    MotionEvent.ACTION_MOVE:
        break;
    MotionEvent.ACTION_UP:
        break;
</code></pre><p> 这里就引入了关于MotionEvent的一个重要概念，事件类型。事件类型就是指MotionEvent对象所代表的动作。比如说，当你的一个手指在屏幕上滑动一下时，系统会产生一系列的触摸事件对象,他们所代表的动作有所不同。有的事件代表你手指按下这个动作,有的事件代表你手指在屏幕上滑动,还有的事件代表你手指离开屏幕。这些事件的事件类型就分别为ACTION_DOWN,ACTION_MOVE,和<strong>ACTION_UP</strong>。上述这个动作所产生的一系列事件，被称为一个事件流，它包括一个<strong>ACTION_DOWN</strong>事件，很多个<strong>ACTION_MOVE</strong>事件，和一个ACTION_UP事件。</p>
<p><img src="https://d9.usercdn.com/2/i/04033/9g2l6srojvha.gif" alt=""></p>
<p> 当然，除了这三个类型外，还有很多不同的事件类型,比如ACTION_CANCEL。它代表当前的手势被取消。要理解这个类型，就必须要了解ViewGroup分发事件的机制。一般来说，如果一个子视图接收了父视图分发给它的ACTION_DOWN事件，那么与ACTION_DOWN事件相关的事件流就都要分发给这个子视图，但是如果父视图希望拦截其中的一些事件，不再继续转发事件给这个子视图的话，那么就需要给子视图一个ACTION_CANCEL事件。<br> 其他的类型会在接下来的博文中一一解释。</p>
<h4 id="Pointer"><a href="#Pointer" class="headerlink" title="Pointer"></a>Pointer</h4><p> 细心的同学会发现，在上一节我描述用户手指在屏幕上滑动的例子时，特地说明了手指的数量为一个。那么当用户两个或者多个手指在屏幕上滑动时，系统又会产生怎样的事件流呢？<br> 为了可以表示多个触摸点的动作，MotionEvent中引入了Pointer的概念，一个pointer就代表一个触摸点，每个pointer都有自己的事件类型，也有自己的横轴坐标值。一个MotionEvent对象中可能会存储多个pointer的相关信息，每个pointer都会有一个自己的id和index。pointer的id在整个事件流中是不会发生变化的，但是index会发生变化。<br> MotionEvent类中的很多方法都是可以传入一个int值作为参数的，其实传入的就是pointer的index值。比如getX(pointerIndex)和getY(pointerIndex)，此时，它们返回的就是index所代表的触摸点相关事件坐标值。<br> 由于pointer的index值在不同的MotionEvent对象中会发生变化，但是id值却不会变化。所以，当我们要记录一个触摸点的事件流时，就只需要保存其id,然后使用findPointerIndex(int)来获得其index值，然后再获得其他信息。</p>
<pre><code>private final static  INVALID_ID = -;
private  mActivePointerId = INVALID_ID;
private  mSecondaryPointerId = INVALID_ID;
private float mPrimaryLastX = -;
private float mPrimaryLastY = -;
private float mSecondaryLastX = -;
private float mSecondaryLastY = -;
public boolean onTouchEvent(MotionEvent event) {
        action = MotionEventCompat.getActionMasked(event);

switch (action) {
            MotionEvent.ACTION_DOWN:
                index = event.getActionIndex();
            mActivePointerId = event.getPointerId(index);
            mPrimaryLastX = MotionEventCompat.getX(event,index);
            mPrimaryLastY = MotionEventCompat.getY(event,index);
            break;
            MotionEvent.ACTION_POINTER_DOWN:
            index = event.getActionIndex();
            mSecondaryPointerId = event.getPointerId(index);
            mSecondaryLastX = event.getX(index);
            mSecondaryLastY = event.getY(index);
            break;
            MotionEvent.ACTION_MOVE:
            index = event.findPointerIndex(mActivePointerId);
                secondaryIndex = MotionEventCompat.findPointerIndex(event,mSecondaryPointerId);
            final float x = MotionEventCompat.getX(event,index);
            final float y = MotionEventCompat.getY(event,index);
            final float secondX = MotionEventCompat.getX(event,secondaryIndex);
            final float secondY = MotionEventCompat.getY(event,secondaryIndex);
            break;
            MotionEvent.ACTION_POINTER_UP:
            xxxxxx(涉及pointer id的转换，之后的文章会讲解)
            break;
            MotionEvent.ACTION_UP:
            MotionEvent.ACTION_CANCEL:
            mActivePointerId = INVALID_ID;
            mPrimaryLastX =-;
            mPrimaryLastY = -;
            break;

return ;
</code></pre><p> 除了pointer的概念，MotionEvent还引入了两个事件类型：</p>
<p><code>ACTION_POINTER_DOWN</code>:代表用户又使用一个手指触摸到屏幕上，也就是说，在已经有一个触摸点的情况下，有新出现了一个触摸点。</p>
<p><code>ACTION_POINTER_UP</code>:代表用户的一个手指离开了触摸屏，但是还有其他手指还在触摸屏上。也就是说，在多个触摸点存在的情况下，其中一个触摸点消失了。它与ACTION_UP的区别就是，它是在多个触摸点中的一个触摸点消失时（此时，还有触摸点存在，也就是说用户还有手指触摸屏幕）产生，而ACTION_UP可以说是最后一个触摸点消失时产生。<br> 那么，用户先两个手指先后接触屏幕，同时滑动，然后在先后离开这一套动作所产生的事件流是什么样的呢？<br> 它所产生的事件流如下：</p>
<p>先产生一个ACTION_DOWN事件，代表用户的第一个手指接触到了屏幕。<br>再产生一个ACTION_POINTER_DOWN事件，代表用户的第二个手指接触到了屏幕。<br>很多的ACTION_MOVE事件，但是在这些MotionEvent对象中，都保存着两个触摸点滑动的信息，相关的代码我们会在文章的最后进行演示。<br>一个ACTION_POINTER_UP事件，代表用户的一个手指离开了屏幕。<br>如果用户剩下的手指还在滑动时，就会产生很多ACTION_MOVE事件。<br>一个ACTION_UP事件，代表用户的最后一个手指离开了屏幕</p>
<p><img src="https://d9.usercdn.com/2/i/04033/2tkzlfdu5yrq.gif" alt=""></p>
<h4 id="getAction__u548C_getActionMasked"><a href="#getAction__u548C_getActionMasked" class="headerlink" title="getAction 和 getActionMasked"></a>getAction 和 getActionMasked</h4><p> 看到文章开头那段代码的同学可能会有点疑问：好像在很多代码里，大家都是通过getAction获得事件类型的，那么它和getActionMasked又有什么不同呢？<br> 从上一节我们可以得知，一个MotionEvent对象中可以包含多个触摸点的事件。当MotionEvent对象只包含一个触摸点的事件时，上边两个函数的结果是相同的，但是当包含多个触摸点时，二者的结果就不同啦。<br> getAction获得的int值是由pointer的index值和事件类型值组合而成的，而getActionWithMasked则只返回事件的类型值<br> 举个例子（注:假设了int中不同位所代表的含义，可能不是例子所中的前8位代表id,后8位代表事件类型）:</p>
<p>getAction returns x0105.<br>getActionMasked will return x0005<br>其中x0100就是pointer的index值。<br> 一般来说，getAction() &amp; ACTION_POINTER_INDEX_MASK就获得了pointer的id,等同于getActionIndex函数;getAction()&amp; ACTION_MASK就获得了pointer的事件类型，等同于getActionMasked函数。</p>
<p> 为了效率，Android系统在处理ACTION_MOVE事件时会将连续的几个多触点移动事件打包到一个MotionEvent对象中。我们可以通过getX(int)和getY(int)来获得最近发生的一个触摸点事件的坐标，然后使用getHistorical(int,int)和getHistorical(int,int)来获得时间稍早的触点事件的坐标，二者是发生时间先后的关系。所以，我们应该先处理通过getHistoricalXX相关函数获得的事件信息，然后在处理当前的事件信息。<br> 下边就是Android Guide中相关的例子:</p>
<pre><code>printSamples(MotionEvent ev) {
    final  historySize = ev.getHistorySize();
    final  pointerCount = ev.getPointerCount();
    ( h = ; h &lt; historySize; h++) {
        System.out.printf(&quot;At time %d:&quot;, ev.getHistoricalEventTime(h));
        ( p = ; p &lt; pointerCount; p++) {
            System.out.printf(&quot;  pointer %d: (%f,%f)&quot;,
                ev.getPointerId(p), ev.getHistoricalX(p, h), ev.getHistoricalY(p, h));


    System.out.printf(&quot;At time %d:&quot;, ev.getEventTime());
    ( p = ; p &lt; pointerCount; p++) {
        System.out.printf(&quot;  pointer %d: (%f,%f)&quot;,
            ev.getPointerId(p), ev.getX(p), ev.getY(p));
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u4E8B_u4EF6_u5750_u6807_u7684_u542B_u4E49"><a href="#u4E8B_u4EF6_u5750_u6807_u7684_u542B_u4E49" class="headerlink" title="事件坐标的含义"></a>事件坐标的含义</h3><p> 我们都知道，每个触摸事件都代表用户在屏幕上的一个动作，而每个动作必定有其发生的位置。在MotionEvent中就有一系列与标触摸事件发生位置相关的函数：</p>
<p>getX()和getY()：由这两个函数获得的x,y值是相对的坐标值，相对于消费这个事件的视图的左上点的坐标。<br>getRawX()和getRawY():有这两个函数获得的x,y值是绝对坐标，是相对于屏幕的。]]>
    
    </summary>
    
      <category term="MotionEvent" scheme="http://kevinhero.github.io/tags/MotionEvent/"/>
    
      <category term="技术" scheme="http://kevinhero.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[React-Native学习指南]]></title>
    <link href="http://kevinhero.github.io/2015/12/19/New%20Lan/React-Native%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/"/>
    <id>http://kevinhero.github.io/2015/12/19/New Lan/React-Native学习指南/</id>
    <published>2015-12-19T15:32:17.000Z</published>
    <updated>2016-02-19T09:13:18.000Z</updated>
    <content type="html"><![CDATA[<p>本指南汇集React-Native各类学习资源，给大家提供便利。指南正在不断的更新，大家有好的资源欢迎Pull Requests！</p>
<p>同时还有Awesome React-Native系列</p>
<p><a href="https://github.com/jondot/awesome-react-native" target="_blank" rel="external">https://github.com/jondot/awesome-react-native</a></p>
<h1 id="u76EE_u5F55"><a href="#u76EE_u5F55" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="/#教程">教程</a><ul>
<li><a href="/#react-native">React Native</a></li>
<li><a href="/#reactjs">React.js</a></li>
<li><a href="/#es6">ES6</a></li>
<li><a href="/#系列教程">系列教程</a></li>
</ul>
</li>
<li><a href="/#开源app">开源APP</a></li>
<li><a href="/#组件">组件</a></li>
<li><a href="/#工具">工具</a></li>
<li><a href="/#资源网站">资源网站</a></li>
<li><a href="/#业界讨论">业界讨论</a></li>
</ul>
<h2 id="u6559_u7A0B"><a href="#u6559_u7A0B" class="headerlink" title="教程"></a>教程</h2><a id="more"></a>
<h3 id="React_Native"><a href="#React_Native" class="headerlink" title="React Native"></a>React Native</h3><ul>
<li><p><strong>React-Native入门指南</strong><br><a href="https://github.com/vczero/react-native-lession" target="_blank" rel="external">https://github.com/vczero/react-native-lession</a></p>
</li>
<li><p><strong>React-Native视频教程(部分免费)</strong><br><a href="https://egghead.io/technologies/react" target="_blank" rel="external">https://egghead.io/technologies/react</a></p>
</li>
<li><p>react-native 官方api文档<br><a href="http://facebook.github.io/react-native/docs/getting-started.html" target="_blank" rel="external">http://facebook.github.io/react-native/docs/getting-started.html</a></p>
</li>
<li><p>react-native中文文档(极客学院)<br><a href="http://wiki.jikexueyuan.com/project/react-native/" target="_blank" rel="external">http://wiki.jikexueyuan.com/project/react-native/</a></p>
</li>
<li><p>react-native中文文档(react native中文网，人工翻译，官网完全同步)<br><a href="http://react-native.cn/docs/getting-started.html" target="_blank" rel="external">http://react-native.cn/docs/getting-started.html</a></p>
</li>
<li><p>react-native第一课<br><a href="http://html-js.com/article/2783" target="_blank" rel="external">http://html-js.com/article/2783</a></p>
</li>
<li><p>深入浅出 React Native：使用 JavaScript 构建原生应用<br><a href="http://zhuanlan.zhihu.com/FrontendMagazine/19996445" target="_blank" rel="external">http://zhuanlan.zhihu.com/FrontendMagazine/19996445</a></p>
</li>
<li><p>React Native通信机制详解<br><a href="http://blog.cnbang.net/tech/2698/" target="_blank" rel="external">http://blog.cnbang.net/tech/2698/</a></p>
</li>
<li><p>React Native布局篇<br><a href="http://segmentfault.com/a/1190000002658374" target="_blank" rel="external">http://segmentfault.com/a/1190000002658374</a></p>
</li>
<li><p>React Native 基础练习指北（一）<br><a href="http://segmentfault.com/a/1190000002645929" target="_blank" rel="external">http://segmentfault.com/a/1190000002645929</a></p>
</li>
<li><p>React Native 基础练习指北（二）<br><a href="http://segmentfault.com/a/1190000002647733" target="_blank" rel="external">http://segmentfault.com/a/1190000002647733</a></p>
</li>
<li><p>Diary of Building an iOS App with React Native<br><a href="http://herman.asia/building-a-flashcard-app-with-react-native" target="_blank" rel="external">http://herman.asia/building-a-flashcard-app-with-react-native</a></p>
</li>
<li><p>Use React Native in Existing iOS App<br><a href="http://blog-en.leapoahead.com/post/use-react-native-in-existing-ios-app" target="_blank" rel="external">http://blog-en.leapoahead.com/post/use-react-native-in-existing-ios-app</a></p>
</li>
<li><p>React Native For Beginners – The Next Big Thing?<br><a href="http://devdactic.com/react-native-for-beginners/" target="_blank" rel="external">http://devdactic.com/react-native-for-beginners/</a></p>
</li>
<li><p>How To Implement A Tab Bar With React Native<br><a href="http://devdactic.com/react-native-tab-bar/" target="_blank" rel="external">http://devdactic.com/react-native-tab-bar/</a></p>
</li>
<li><p>tcomb-form-native使用视频教程(需翻墙)<br><a href="http://react.rocks/example/tcomb-form-native" target="_blank" rel="external">http://react.rocks/example/tcomb-form-native</a></p>
</li>
<li><p>React Native分享记录<br><a href="http://segmentfault.com/a/1190000002678782" target="_blank" rel="external">http://segmentfault.com/a/1190000002678782</a></p>
</li>
<li><p>React Native构建本地视图组件<br><a href="https://www.dobest.me/article/11" target="_blank" rel="external">https://www.dobest.me/article/11</a></p>
</li>
<li><p>react-native-android-lession(安卓系列教程)<br><a href="https://github.com/yipengmu/react-native-android-lession" target="_blank" rel="external">https://github.com/yipengmu/react-native-android-lession</a></p>
</li>
<li><p>React Native模块桥接详解<br><a href="https://www.dobest.me/article/14" target="_blank" rel="external">https://www.dobest.me/article/14</a></p>
</li>
<li><p>React Native: 配置和起步<br><a href="http://www.liaohuqiu.net/cn/posts/react-native-1/" target="_blank" rel="external">http://www.liaohuqiu.net/cn/posts/react-native-1/</a></p>
</li>
<li><p>React Native: Android 的打包<br><a href="http://www.liaohuqiu.net/cn/posts/react-native-android-package/" target="_blank" rel="external">http://www.liaohuqiu.net/cn/posts/react-native-android-package/</a></p>
</li>
<li><p>react-native的第一课<br><a href="https://github.com/coderyi/blog/blob/master/articles/2016/0122_react-native_first_lesson.md" target="_blank" rel="external">https://github.com/coderyi/blog/blob/master/articles/2016/0122_react-native_first_lesson.md</a></p>
</li>
</ul>
<h3 id="React-js"><a href="#React-js" class="headerlink" title="React.js"></a>React.js</h3><ul>
<li><p>react.js中文文档<br><a href="http://reactjs.cn/" target="_blank" rel="external">http://reactjs.cn/</a></p>
</li>
<li><p>react.js入门教程(gitbook)<br><a href="https://hulufei.gitbooks.io/react-tutorial/content/introduction.html" target="_blank" rel="external">https://hulufei.gitbooks.io/react-tutorial/content/introduction.html</a></p>
</li>
<li><p><strong>react.js快速入门教程 - 阮一峰</strong><br><a href="http://www.ruanyifeng.com/blog/2015/03/react.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2015/03/react.html</a></p>
</li>
<li><p>react.js视频教程<br><a href="http://react.nodejs-china.org/t/reactjs/584" target="_blank" rel="external">http://react.nodejs-china.org/t/reactjs/584</a></p>
</li>
</ul>
<h3 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h3><ul>
<li><p>深入浅出ES6（一）：ES6是什么<br><a href="http://www.infoq.com/cn/articles/es6-in-depth-an-introduction" target="_blank" rel="external">http://www.infoq.com/cn/articles/es6-in-depth-an-introduction</a></p>
</li>
<li><p>深入浅出ES6（二）：迭代器和for-of循环<br><a href="http://www.infoq.com/cn/articles/es6-in-depth-iterators-and-the-for-of-loop" target="_blank" rel="external">http://www.infoq.com/cn/articles/es6-in-depth-iterators-and-the-for-of-loop</a></p>
</li>
<li><p>深入浅出ES6（三）：生成器 Generators<br><a href="http://www.infoq.com/cn/articles/es6-in-depth-generators" target="_blank" rel="external">http://www.infoq.com/cn/articles/es6-in-depth-generators</a></p>
</li>
<li><p>深入浅出ES6（四）：模板字符串<br><a href="http://www.infoq.com/cn/articles/es6-in-depth-template-string" target="_blank" rel="external">http://www.infoq.com/cn/articles/es6-in-depth-template-string</a></p>
</li>
<li><p>深入浅出ES6（五）：不定参数和默认参数<br><a href="http://www.infoq.com/cn/articles/es6-in-depth-rest-parameters-and-defaults" target="_blank" rel="external">http://www.infoq.com/cn/articles/es6-in-depth-rest-parameters-and-defaults</a></p>
</li>
</ul>
<h3 id="u7CFB_u5217_u6559_u7A0B"><a href="#u7CFB_u5217_u6559_u7A0B" class="headerlink" title="系列教程"></a>系列教程</h3><ul>
<li><p>深入浅出React（一）：React的设计哲学 - 简单之美<br><a href="http://www.infoq.com/cn/articles/react-art-of-simplity" target="_blank" rel="external">http://www.infoq.com/cn/articles/react-art-of-simplity</a></p>
</li>
<li><p>深入浅出React（二）：React开发神器Webpack<br><a href="http://www.infoq.com/cn/articles/react-and-webpack" target="_blank" rel="external">http://www.infoq.com/cn/articles/react-and-webpack</a></p>
</li>
<li><p>深入浅出React（三）：理解JSX和组件<br><a href="http://www.infoq.com/cn/articles/react-jsx-and-component" target="_blank" rel="external">http://www.infoq.com/cn/articles/react-jsx-and-component</a></p>
</li>
<li><p>深入浅出React（四）：虚拟DOM Diff算法解析<br><a href="http://www.infoq.com/cn/articles/react-dom-diff" target="_blank" rel="external">http://www.infoq.com/cn/articles/react-dom-diff</a></p>
</li>
<li><p>深入浅出React（五）：使用Flux搭建React应用程序架构<br><a href="http://www.infoq.com/cn/articles/react-flux" target="_blank" rel="external">http://www.infoq.com/cn/articles/react-flux</a></p>
</li>
<li><p>react-webpack-cookbook中文版<br><a href="http://fakefish.github.io/react-webpack-cookbook/" target="_blank" rel="external">http://fakefish.github.io/react-webpack-cookbook/</a></p>
</li>
<li><p>Flex 布局语法教程<br><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a></p>
</li>
<li><p>React 初探<br><a href="http://www.alloyteam.com/2015/04/react-explore/" target="_blank" rel="external">http://www.alloyteam.com/2015/04/react-explore/</a></p>
</li>
<li><p>React虚拟DOM浅析<br><a href="http://www.alloyteam.com/2015/10/react-virtual-analysis-of-the-dom/" target="_blank" rel="external">http://www.alloyteam.com/2015/10/react-virtual-analysis-of-the-dom/</a></p>
</li>
<li><p>react组件间通信<br><a href="http://www.alloyteam.com/2015/07/react-zu-jian-jian-tong-xin/" target="_blank" rel="external">http://www.alloyteam.com/2015/07/react-zu-jian-jian-tong-xin/</a></p>
</li>
<li><p>React 数据流管理架构之 Redux 介绍<br><a href="http://www.alloyteam.com/2015/09/react-redux/" target="_blank" rel="external">http://www.alloyteam.com/2015/09/react-redux/</a></p>
</li>
<li><p>React服务器端渲染实践小结<br><a href="http://www.alloyteam.com/2015/10/8783/" target="_blank" rel="external">http://www.alloyteam.com/2015/10/8783/</a></p>
</li>
<li><p>React Native Android 踩坑之旅<br><a href="http://www.alloyteam.com/2015/10/react-native-android-steps-on-tour/" target="_blank" rel="external">http://www.alloyteam.com/2015/10/react-native-android-steps-on-tour/</a></p>
</li>
<li><p>React Native 之 JSBridge<br><a href="http://www.alloyteam.com/2015/05/react-native-zhi-jsbridge/" target="_blank" rel="external">http://www.alloyteam.com/2015/05/react-native-zhi-jsbridge/</a></p>
</li>
</ul>
<h3 id="React_Native_u63A2_u7D22_u7CFB_u5217_u6559_u7A0B"><a href="#React_Native_u63A2_u7D22_u7CFB_u5217_u6559_u7A0B" class="headerlink" title="React Native探索系列教程"></a>React Native探索系列教程</h3><ul>
<li><p>React Native探索（一）：背景、规划和风险<br><a href="http://www.infoq.com/cn/articles/react-native-overview" target="_blank" rel="external">http://www.infoq.com/cn/articles/react-native-overview</a></p>
</li>
<li><p>React Native探索（二）：布局篇<br><a href="http://www.infoq.com/cn/articles/react-native-layout" target="_blank" rel="external">http://www.infoq.com/cn/articles/react-native-layout</a></p>
</li>
<li><p>React Native探索（三）：与 react-web 的融合<br><a href="http://www.infoq.com/cn/articles/react-native-web" target="_blank" rel="external">http://www.infoq.com/cn/articles/react-native-web</a></p>
</li>
</ul>
<h2 id="u5F00_u6E90APP"><a href="#u5F00_u6E90APP" class="headerlink" title="开源APP"></a>开源APP</h2><blockquote>
<p>研究源码也是一个很好的学习方式</p>
</blockquote>
<ul>
<li><p>官方演示App<br><a href="https://github.com/facebook/react-native/tree/master/Examples" target="_blank" rel="external">https://github.com/facebook/react-native/tree/master/Examples</a></p>
</li>
<li><p>react-native-dribbble-app<br><a href="https://github.com/catalinmiron/react-native-dribbble-app" target="_blank" rel="external">https://github.com/catalinmiron/react-native-dribbble-app</a></p>
</li>
<li><p><strong>Leanote for iOS(云笔记)</strong><br><a href="https://github.com/leanote/leanote-ios-rn" target="_blank" rel="external">https://github.com/leanote/leanote-ios-rn</a></p>
</li>
<li><p><strong>ReactNativeRubyChina</strong><br><a href="https://github.com/henter/ReactNativeRubyChina" target="_blank" rel="external">https://github.com/henter/ReactNativeRubyChina</a></p>
</li>
<li><p>HackerNews-React-Native<br><a href="https://github.com/iSimar/HackerNews-React-Native" target="_blank" rel="external">https://github.com/iSimar/HackerNews-React-Native</a></p>
</li>
<li><p>React-Native新闻客户端<br><a href="https://github.com/tabalt/ReactNativeNews" target="_blank" rel="external">https://github.com/tabalt/ReactNativeNews</a></p>
</li>
<li><p><strong>newswatch(新闻客户端)</strong><br><a href="https://github.com/bradoyler/newswatch-react-native" target="_blank" rel="external">https://github.com/bradoyler/newswatch-react-native</a></p>
</li>
<li><p><strong>buyscreen(购买页面)</strong><br><a href="https://github.com/appintheair/react-native-buyscreen" target="_blank" rel="external">https://github.com/appintheair/react-native-buyscreen</a></p>
</li>
<li><p><strong>V2EX客户端</strong><br><a href="https://github.com/samuel1112/v2er" target="_blank" rel="external">https://github.com/samuel1112/v2er</a></p>
</li>
<li><p>react-native-todo<br><a href="https://github.com/joemaddalone/react-native-todo" target="_blank" rel="external">https://github.com/joemaddalone/react-native-todo</a></p>
</li>
<li><p>react-native-beer<br><a href="https://github.com/muratsu/react-native-beer" target="_blank" rel="external">https://github.com/muratsu/react-native-beer</a></p>
</li>
<li><p>react-native-stars<br><a href="https://github.com/86/react-native-stars" target="_blank" rel="external">https://github.com/86/react-native-stars</a></p>
</li>
<li><p><strong>模仿天猫首页的app</strong><br><a href="https://github.com/hugohua/react-native-demo" target="_blank" rel="external">https://github.com/hugohua/react-native-demo</a></p>
</li>
<li><p>ReactNativeChess<br><a href="https://github.com/csarsam/ReactNativeChess" target="_blank" rel="external">https://github.com/csarsam/ReactNativeChess</a></p>
</li>
<li><p>react native 编写的音乐软件<br><a href="https://github.com/Johnqing/miumiu" target="_blank" rel="external">https://github.com/Johnqing/miumiu</a></p>
</li>
<li><p>react-native-pokedex<br><a href="https://github.com/ababol/react-native-pokedex" target="_blank" rel="external">https://github.com/ababol/react-native-pokedex</a></p>
</li>
<li><p>CNode-React-Native<br><a href="https://github.com/SFantasy/CNode-React-Native" target="_blank" rel="external">https://github.com/SFantasy/CNode-React-Native</a></p>
</li>
<li><p>8tracks电台客户端<br><a href="https://github.com/voronianski/EightTracksReactNative" target="_blank" rel="external">https://github.com/voronianski/EightTracksReactNative</a></p>
</li>
<li><p>React-Native实现的计算器<br><a href="https://github.com/yoxisem544/Calculator-using-React-Native" target="_blank" rel="external">https://github.com/yoxisem544/Calculator-using-React-Native</a></p>
</li>
<li><p><strong>房产搜索app</strong><br><a href="https://github.com/jawee/react-native-PropertyFinder" target="_blank" rel="external">https://github.com/jawee/react-native-PropertyFinder</a></p>
</li>
<li><p>知乎专栏app<br><a href="https://github.com/LeezQ/react-native-zhihu-app" target="_blank" rel="external">https://github.com/LeezQ/react-native-zhihu-app</a></p>
</li>
<li><p>ForeignExchangeApp<br><a href="https://github.com/peralmq/ForeignExchangeApp" target="_blank" rel="external">https://github.com/peralmq/ForeignExchangeApp</a></p>
</li>
<li><p>Segmentfault 客户端<br><a href="https://github.com/fakefish/sf-react-native" target="_blank" rel="external">https://github.com/fakefish/sf-react-native</a></p>
</li>
<li><p>糗事百科app<br><a href="https://github.com/stormhouse/QiuShiReactNative" target="_blank" rel="external">https://github.com/stormhouse/QiuShiReactNative</a></p>
</li>
<li><p>孢子社区app<br><a href="https://github.com/Hi-Rube/baoz-ReactNative" target="_blank" rel="external">https://github.com/Hi-Rube/baoz-ReactNative</a></p>
</li>
<li><p><strong>深JS app</strong><br><a href="https://github.com/fraserxu/shenjs" target="_blank" rel="external">https://github.com/fraserxu/shenjs</a></p>
</li>
<li><p>Den - 房屋销售app*<br><a href="https://github.com/asamiller/den" target="_blank" rel="external">https://github.com/asamiller/den</a></p>
</li>
<li><p><strong>Noder-cnodejs客户端</strong><br><a href="https://github.com/soliury/noder-react-native" target="_blank" rel="external">https://github.com/soliury/noder-react-native</a></p>
</li>
<li><p>知乎日报Android版<br><a href="https://github.com/race604/ZhiHuDaily-React-Native" target="_blank" rel="external">https://github.com/race604/ZhiHuDaily-React-Native</a></p>
</li>
<li><p>ziliun-react-native<br><a href="https://github.com/sonnylazuardi/ziliun-react-native" target="_blank" rel="external">https://github.com/sonnylazuardi/ziliun-react-native</a></p>
</li>
<li><p>react-native-weather-app<br><a href="https://github.com/shevawen/react-native-weather-app" target="_blank" rel="external">https://github.com/shevawen/react-native-weather-app</a></p>
</li>
<li><p>React Native Sample App(Navigation,Flux)<br><a href="https://github.com/taskrabbit/ReactNativeSampleApp" target="_blank" rel="external">https://github.com/taskrabbit/ReactNativeSampleApp</a></p>
</li>
<li><p>TesterHome社区app<br><a href="https://github.com/qddegtya/A-ReactNative-TesterHome" target="_blank" rel="external">https://github.com/qddegtya/A-ReactNative-TesterHome</a></p>
</li>
<li><p>Finance - 股票报价app<br><a href="https://github.com/7kfpun/FinanceReactNative" target="_blank" rel="external">https://github.com/7kfpun/FinanceReactNative</a></p>
</li>
<li><p>shopping - 购物app<br><a href="https://github.com/bigsui/shopping-react-native" target="_blank" rel="external">https://github.com/bigsui/shopping-react-native</a></p>
</li>
<li><p>zhuiyuan - 追源cms app<br><a href="https://github.com/kazaff/ZhuiYuanDemo" target="_blank" rel="external">https://github.com/kazaff/ZhuiYuanDemo</a></p>
</li>
<li><p>uestc-bbs-react-native - UESTC清水河畔RN客户端(with Redux)<br><a href="https://github.com/just4fun/uestc-bbs-react-native" target="_blank" rel="external">https://github.com/just4fun/uestc-bbs-react-native</a></p>
</li>
<li><p><strong>react-native-nw-react-calculator</strong>(iOS/Android、Web、桌面多端)<br><a href="https://github.com/benoitvallon/react-native-nw-react-calculator" target="_blank" rel="external">https://github.com/benoitvallon/react-native-nw-react-calculator</a></p>
</li>
<li><p>react-native-nba-app<br><a href="https://github.com/wwayne/react-native-nba-app" target="_blank" rel="external">https://github.com/wwayne/react-native-nba-app</a></p>
</li>
</ul>
<h2 id="u7EC4_u4EF6"><a href="#u7EC4_u4EF6" class="headerlink" title="组件"></a>组件</h2><blockquote>
<p>由于已经有较好的组件库网站，这里就不做总结。可以直接查看如下网站，过后可能精选一部分优质组件出来 :P</p>
</blockquote>
<ul>
<li><p><strong>React-native组件库</strong>（比较全的组件库）<br><a href="http://react.parts/" target="_blank" rel="external">http://react.parts/</a></p>
</li>
<li><p><strong>React Native Modules</strong><br><a href="http://reactnativemodules.com/" target="_blank" rel="external">http://reactnativemodules.com/</a></p>
</li>
<li><p><strong>最佳轮播类组件</strong><br><a href="https://github.com/leecade/react-native-swiper" target="_blank" rel="external">https://github.com/leecade/react-native-swiper</a></p>
</li>
<li><p>React Native Router<br><a href="https://github.com/t4t5/react-native-router" target="_blank" rel="external">https://github.com/t4t5/react-native-router</a></p>
</li>
<li><p>下拉刷新组件<br><a href="https://github.com/jsdf/react-native-refreshable-listview" target="_blank" rel="external">https://github.com/jsdf/react-native-refreshable-listview</a></p>
</li>
<li><p>模态框<br><a href="https://github.com/brentvatne/react-native-modal" target="_blank" rel="external">https://github.com/brentvatne/react-native-modal</a></p>
</li>
<li><p>react-native-navbar<br><a href="https://github.com/react-native-fellowship/react-native-navbar" target="_blank" rel="external">https://github.com/react-native-fellowship/react-native-navbar</a></p>
</li>
<li><p>滚动轮播组件<br><a href="https://github.com/appintheair/react-native-looped-carousel" target="_blank" rel="external">https://github.com/appintheair/react-native-looped-carousel</a></p>
</li>
<li><p>HTML显示组件<br><a href="https://github.com/jsdf/react-native-htmlview" target="_blank" rel="external">https://github.com/jsdf/react-native-htmlview</a></p>
</li>
<li><p><strong>Material React Native (MRN)</strong> - Material Design组件库<br><a href="https://github.com/binggg/mrn" target="_blank" rel="external">https://github.com/binggg/mrn</a></p>
</li>
</ul>
<h2 id="u5DE5_u5177"><a href="#u5DE5_u5177" class="headerlink" title="工具"></a>工具</h2><ul>
<li><p>react-native-snippets(代码提示)<br><a href="https://github.com/Shrugs/react-native-snippets" target="_blank" rel="external">https://github.com/Shrugs/react-native-snippets</a></p>
</li>
<li><p>react-native-babel(使用ES6+)<br><a href="https://github.com/roman01la/react-native-babel" target="_blank" rel="external">https://github.com/roman01la/react-native-babel</a></p>
</li>
<li><p>sqlite for react-native<br><a href="https://github.com/almost/react-native-sqlite" target="_blank" rel="external">https://github.com/almost/react-native-sqlite</a></p>
</li>
<li><p>gulp-react-native-css(就像写css一样写React Style)<br><a href="https://github.com/soliury/gulp-react-native-css" target="_blank" rel="external">https://github.com/soliury/gulp-react-native-css</a></p>
</li>
<li><p>rnpm(React Native Package Manager)<br><a href="https://github.com/rnpm/rnpm" target="_blank" rel="external">https://github.com/rnpm/rnpm</a></p>
</li>
</ul>
<h2 id="u8D44_u6E90_u7F51_u7AD9"><a href="#u8D44_u6E90_u7F51_u7AD9" class="headerlink" title="资源网站"></a>资源网站</h2><ul>
<li><p>React-native官网<br><a href="http://facebook.github.io/react-native/" target="_blank" rel="external">http://facebook.github.io/react-native/</a></p>
</li>
<li><p><strong>React-China社区</strong><br><a href="http://react-china.org/" target="_blank" rel="external">http://react-china.org/</a></p>
</li>
<li><p><strong>React Native中文社区</strong><br><a href="http://bbs.react-native.cn/" target="_blank" rel="external">http://bbs.react-native.cn/</a></p>
</li>
<li><p><strong>React-native组件库</strong>（比较全的组件库）<br><a href="http://react.parts/" target="_blank" rel="external">http://react.parts/</a></p>
</li>
<li><p><strong>React Native Modules</strong><br><a href="http://reactnativemodules.com/" target="_blank" rel="external">http://reactnativemodules.com/</a></p>
</li>
<li><p><strong>Use React Native 资讯站</strong>(使用技巧及新闻)<br><a href="http://www.reactnative.com/" target="_blank" rel="external">http://www.reactnative.com/</a></p>
</li>
<li><p>11款React Native开源移动 UI 组件<br><a href="http://www.oschina.net/news/61214/11-react-native-ui-components" target="_blank" rel="external">http://www.oschina.net/news/61214/11-react-native-ui-components</a></p>
</li>
<li><p><strong>稀土掘金的 React 标签</strong><br><a href="http://gold.xitu.io/#/tag/React.js" target="_blank" rel="external">http://gold.xitu.io/#/tag/React.js</a> <a href="http://gold.xitu.io/#/tag/React%20Native" target="_blank" rel="external">http://gold.xitu.io/#/tag/React%20Native</a></p>
</li>
</ul>
<h2 id="u4E1A_u754C_u8BA8_u8BBA"><a href="#u4E1A_u754C_u8BA8_u8BBA" class="headerlink" title="业界讨论"></a>业界讨论</h2><ul>
<li><p>跨平台开发时代的 (再次) 到来？（ Xamarin，NativeScript 和 React Native 对比）<br><a href="http://onevcat.com/2015/03/cross-platform/" target="_blank" rel="external">http://onevcat.com/2015/03/cross-platform/</a></p>
</li>
<li><p>谈谈 React Native - 唐巧<br><a href="http://blog.devtang.com/blog/2015/02/01/talk-about-react-native/" target="_blank" rel="external">http://blog.devtang.com/blog/2015/02/01/talk-about-react-native/</a></p>
</li>
<li><p>如何评价React-Native?<br><a href="http://www.zhihu.com/question/27852694/answer/43990708" target="_blank" rel="external">http://www.zhihu.com/question/27852694/answer/43990708</a></p>
</li>
<li><p>React Native概述：背景、规划和风险<br><a href="http://div.io/topic/938" target="_blank" rel="external">http://div.io/topic/938</a></p>
</li>
<li><p>Native与Web的融合 - Qcon中React-Native演讲<br><a href="http://www.infoq.com/cn/presentations/the-fusion-of-native-and-web" target="_blank" rel="external">http://www.infoq.com/cn/presentations/the-fusion-of-native-and-web</a></p>
</li>
</ul>
<p>本文转自:<a href="https://github.com/jondot/awesome-react-native" target="_blank" rel="external">https://github.com/jondot/awesome-react-native</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本指南汇集React-Native各类学习资源，给大家提供便利。指南正在不断的更新，大家有好的资源欢迎Pull Requests！</p>
<p>同时还有Awesome React-Native系列</p>
<p><a href="https://github.com/jondot/awesome-react-native">https://github.com/jondot/awesome-react-native</a></p>
<h1 id="u76EE_u5F55"><a href="#u76EE_u5F55" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="/#教程">教程</a><ul>
<li><a href="/#react-native">React Native</a></li>
<li><a href="/#reactjs">React.js</a></li>
<li><a href="/#es6">ES6</a></li>
<li><a href="/#系列教程">系列教程</a></li>
</ul>
</li>
<li><a href="/#开源app">开源APP</a></li>
<li><a href="/#组件">组件</a></li>
<li><a href="/#工具">工具</a></li>
<li><a href="/#资源网站">资源网站</a></li>
<li><a href="/#业界讨论">业界讨论</a></li>
</ul>
<h2 id="u6559_u7A0B"><a href="#u6559_u7A0B" class="headerlink" title="教程"></a>教程</h2>]]>
    
    </summary>
    
      <category term="React-Native" scheme="http://kevinhero.github.io/tags/React-Native/"/>
    
      <category term="技术" scheme="http://kevinhero.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[RecyclerView 列表控件中简单实现时间线]]></title>
    <link href="http://kevinhero.github.io/2015/12/18/Android%20Skills/RecyclerView%20%E5%88%97%E8%A1%A8%E6%8E%A7%E4%BB%B6%E4%B8%AD%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E6%97%B6%E9%97%B4%E7%BA%BF/"/>
    <id>http://kevinhero.github.io/2015/12/18/Android Skills/RecyclerView 列表控件中简单实现时间线/</id>
    <published>2015-12-17T17:01:14.000Z</published>
    <updated>2016-02-19T09:20:12.000Z</updated>
    <content type="html"><![CDATA[<p>看见很多软件中都有时间线的东西，貌似天气啊，旅游啊什么的最多了；具体实现方式很多，在本篇文章中讲解一种自定义View封装的方式。</p>
<h3 id="u6548_u679C"><a href="#u6548_u679C" class="headerlink" title="效果"></a>效果</h3><p>先来看看效果。<br><img src="http://www.jcodecraeer.com/uploads/20150825/1440469250572021.png" alt=""><br><a id="more"></a></p>
<h3 id="u5206_u6790"><a href="#u5206_u6790" class="headerlink" title="分析"></a>分析</h3><p>软件中，可以看见前面的时间线也就是线条加上圆圈组成；当然这里的圆圈与线条也都是可以随意换成其他的，比如图片等等。</p>
<p>当然这里最简单的来说，是上面一个线条，然后一个圆圈，然后下面一个线条；上线条在第一条数据时不做显示，下线条在最后一条数据时不做显示。</p>
<p><img src="http://www.jcodecraeer.com/uploads/20150825/1440469277121276.png" alt=""></p>
<p>这里自定义布局部分也就是把旁边的线条与圆圈封装到一起，并使用简单的方法来控制是否显示。<br>当封装好了后，与旁边的文字部分也就是水瓶方向的线性布局了，然后设置为每一个的RecyclerView 的Item的布局也就完成了。</p>
<h3 id="u63A7_u4EF6"><a href="#u63A7_u4EF6" class="headerlink" title="控件"></a>控件</h3><p>控件很简单，首先我们继承View，取名为 TimeLineMarker 就OK。</p>
<h3 id="Attrs__u5C5E_u6027"><a href="#Attrs__u5C5E_u6027" class="headerlink" title="Attrs 属性"></a>Attrs 属性</h3><p>开始控件之前先准备好需要的属性。</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;resources&gt;
    &lt;declare-styleable name=&quot;TimeLineMarker&quot;&gt;
        &lt;attr name=&quot;markerSize&quot; format=&quot;dimension&quot; /&gt;
        &lt;attr name=&quot;marker&quot; format=&quot;color|reference&quot; /&gt;
        &lt;attr name=&quot;beginLine&quot; format=&quot;color|reference&quot; /&gt;
        &lt;attr name=&quot;endLine&quot; format=&quot;color|reference&quot; /&gt;
        &lt;attr name=&quot;lineSize&quot; format=&quot;dimension&quot; /&gt;
    &lt;/declare-styleable&gt;
&lt;/resources&gt;
</code></pre><p>在这里也就准备了线条的大小、开始线条、结束线条、中间标示部分及大小。</p>
<h3 id="u5C5E_u6027_u4E0E_u73B0_u5B9E"><a href="#u5C5E_u6027_u4E0E_u73B0_u5B9E" class="headerlink" title="属性与现实"></a>属性与现实</h3><pre><code>private int mMarkerSize = 24;
private int mLineSize = 12;
private Drawable mBeginLine;
private Drawable mEndLine;
private Drawable mMarkerDrawable;

@Override
protected void onDraw(Canvas canvas) {
    if (mBeginLine != null) {
        mBeginLine.draw(canvas);
    }

    if (mEndLine != null) {
        mEndLine.draw(canvas);
    }

    if (mMarkerDrawable != null) {
        mMarkerDrawable.draw(canvas);
    }

    super.onDraw(canvas);
}
</code></pre><p>两个大小属性，3个具体的Drawable，然后在onDraw方法中进行具体的显示也就OK。</p>
<h3 id="u6784_u9020_u4E0E_u5C5E_u6027_u521D_u59CB_u5316"><a href="#u6784_u9020_u4E0E_u5C5E_u6027_u521D_u59CB_u5316" class="headerlink" title="构造与属性初始化"></a>构造与属性初始化</h3><p>在上面我们定义了属性，在这里我们在构造函数中获取XML所设置的属性。</p>
<pre><code>public TimeLineMarker(Context context) {
    this(context, null);
}

public TimeLineMarker(Context context, AttributeSet attrs) {
    this(context, attrs, 0);
}

public TimeLineMarker(Context context, AttributeSet attrs, int defStyle) {
    super(context, attrs, defStyle);
    init(attrs);
}

private void init(AttributeSet attrs) {
    // Load attributes
    final TypedArray a = getContext().obtainStyledAttributes(
            attrs, R.styleable.TimeLineMarker, 0, 0);

    mMarkerSize = a.getDimensionPixelSize(
            R.styleable.TimeLineMarker_markerSize,
            mMarkerSize);

    mLineSize = a.getDimensionPixelSize(
            R.styleable.TimeLineMarker_lineSize,
            mLineSize);

    mBeginLine = a.getDrawable(
            R.styleable.TimeLineMarker_beginLine);

    mEndLine = a.getDrawable(
            R.styleable.TimeLineMarker_endLine);

    mMarkerDrawable = a.getDrawable(
            R.styleable.TimeLineMarker_marker);

    a.recycle();

    if (mBeginLine != null)
        mBeginLine.setCallback(this);

    if (mEndLine != null)
        mEndLine.setCallback(this);

    if (mMarkerDrawable != null)
        mMarkerDrawable.setCallback(this);
}
</code></pre><h3 id="Drawable__u7684_u4F4D_u7F6E_u4E0E_u5927_u5C0F_u521D_u59CB_u5316"><a href="#Drawable__u7684_u4F4D_u7F6E_u4E0E_u5927_u5C0F_u521D_u59CB_u5316" class="headerlink" title="Drawable 的位置与大小初始化"></a>Drawable 的位置与大小初始化</h3><p>属性啥的有了，具体的Drawable 也有了，要显示的地方调用也是OK了；但是如果没有进行进行具体的位置调整这一切也都没有意义。</p>
<pre><code>@Override
protected void onSizeChanged(int w, int h, int oldw, int oldh) {
    super.onSizeChanged(w, h, oldw, oldh);
    initDrawableSize();
}

private void initDrawableSize() {
    int pLeft = getPaddingLeft();
    int pRight = getPaddingRight();
    int pTop = getPaddingTop();
    int pBottom = getPaddingBottom();

    int width = getWidth();
    int height = getHeight();

    int cWidth = width - pLeft - pRight;
    int cHeight = height - pTop - pBottom;

    Rect bounds;

    if (mMarkerDrawable != null) {
        // Size
        int markerSize = Math.min(mMarkerSize, Math.min(cWidth, cHeight));
        mMarkerDrawable.setBounds(pLeft, pTop,
                pLeft + markerSize, pTop + markerSize);

        bounds = mMarkerDrawable.getBounds();
    } else {
        bounds = new Rect(pLeft, pTop, pLeft + cWidth, pTop + cHeight);
    }


    int halfLineSize = mLineSize &gt;&gt; 1;
    int lineLeft = bounds.centerX() - halfLineSize;

    if (mBeginLine != null) {
        mBeginLine.setBounds(lineLeft, 0, lineLeft + mLineSize, bounds.top);
    }

    if (mEndLine != null) {
        mEndLine.setBounds(lineLeft, bounds.bottom, lineLeft + mLineSize, height);
    }
}
</code></pre><p>initDrawableSize 方法进行具体的运算，而运算的时间点就是当控件的大小改变（onSizeChanged）的时候。</p>
<p>在初始化中采用了一定的投机取巧；这里利用了上内边距与下内边距分别作为上线条与下线条的长度；而线条与中间的标识都采用了水平距中。</p>
<h3 id="u5176_u4ED6_u8BBE_u7F6E_u65B9_u6CD5"><a href="#u5176_u4ED6_u8BBE_u7F6E_u65B9_u6CD5" class="headerlink" title="其他设置方法"></a>其他设置方法</h3><pre><code>public void setLineSize(int lineSize) {
    if (mLineSize != lineSize) {
        this.mLineSize = lineSize;
        initDrawableSize();
        invalidate();
    }
}

public void setMarkerSize(int markerSize) {
    if (this.mMarkerSize != markerSize) {
        mMarkerSize = markerSize;
        initDrawableSize();
        invalidate();
    }
}

public void setBeginLine(Drawable beginLine) {
    if (this.mBeginLine != beginLine) {
        this.mBeginLine = beginLine;
        if (mBeginLine != null) {
            mBeginLine.setCallback(this);
        }
        initDrawableSize();
        invalidate();
    }
}

public void setEndLine(Drawable endLine) {
    if (this.mEndLine != endLine) {
        this.mEndLine = endLine;
        if (mEndLine != null) {
            mEndLine.setCallback(this);
        }
        initDrawableSize();
        invalidate();
    }
}

public void setMarkerDrawable(Drawable markerDrawable) {
    if (this.mMarkerDrawable != markerDrawable) {
        this.mMarkerDrawable = markerDrawable;
        if (mMarkerDrawable != null) {
            mMarkerDrawable.setCallback(this);
        }
        initDrawableSize();
        invalidate();
    }
}
</code></pre><p>在设置中，首先判断是否更改，如果更改那么就更新并重新计算位置；随后刷新界面。</p>
<blockquote>
<p>到这里，控件差不多准备OK了，其中还有很多可以完善的地方，比如加上快捷设置颜色什么的，也可以加上大小计算的东西。同时还可以加上时间线是水瓶还是垂直等等。在这里就不累赘介绍哪些了。下面来看看如何使用。</p>
</blockquote>
<h3 id="u4F7F_u7528"><a href="#u4F7F_u7528" class="headerlink" title="使用"></a>使用</h3><h4 id="XML_u5E03_u5C40"><a href="#XML_u5E03_u5C40" class="headerlink" title="XML布局"></a>XML布局</h4><h5 id="ITEM_u5E03_u5C40item_time_line-xml"><a href="#ITEM_u5E03_u5C40item_time_line-xml" class="headerlink" title="ITEM布局item_time_line.xml"></a>ITEM布局item_time_line.xml</h5><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:orientation=&quot;horizontal&quot;
    android:paddingLeft=&quot;@dimen/lay_16&quot;
    android:paddingRight=&quot;@dimen/lay_16&quot;
    tools:ignore=&quot;MissingPrefix&quot;&gt;

    &lt;net.qiujuer.example.timeline.widget.TimeLineMarker
        android:id=&quot;@+id/item_time_line_mark&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;match_parent&quot;
        android:paddingBottom=&quot;@dimen/lay_16&quot;
        android:paddingLeft=&quot;@dimen/lay_4&quot;
        android:paddingRight=&quot;@dimen/lay_4&quot;
        android:paddingTop=&quot;@dimen/lay_16&quot;
        app:beginLine=&quot;@color/black_alpha_32&quot;
        app:endLine=&quot;@color/black_alpha_32&quot;
        app:lineSize=&quot;2dp&quot;
        app:marker=&quot;@drawable/ic_timeline_default_marker&quot;
        app:markerSize=&quot;24dp&quot; /&gt;

    &lt;TextView
        android:id=&quot;@+id/item_time_line_txt&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_gravity=&quot;center&quot;
        android:paddingBottom=&quot;@dimen/lay_16&quot;
        android:paddingLeft=&quot;@dimen/lay_4&quot;
        android:paddingRight=&quot;@dimen/lay_4&quot;
        android:paddingTop=&quot;@dimen/lay_16&quot;
        android:textColor=&quot;@color/grey_600&quot;
        android:textSize=&quot;@dimen/font_16&quot; /&gt;

&lt;/LinearLayout&gt;
</code></pre><p>在这里我们之间使用顺序布局，左边是TimelIne控件，右边是一个简单的字体控件，具体使用中可以细化一些。</p>
<p>在TImeLine控件中我们的Mark是使用的drawable/ic_timeline_default_marker；这个就是一个简单的圆圈而已；对于自己美化可以使用一张图片代替或者更加复杂的布局；当然上面的线条就更加简单了，就直接使用颜色代替。</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:shape=&quot;oval&quot;&gt;
    &lt;solid android:color=&quot;@color/cyan_500&quot; /&gt;
    &lt;stroke
        android:width=&quot;1dp&quot;
        android:color=&quot;@color/black_alpha_32&quot; /&gt;
&lt;/shape&gt;
</code></pre><h5 id="u4E3B_u754C_u9762XML_RecyclerView"><a href="#u4E3B_u754C_u9762XML_RecyclerView" class="headerlink" title="主界面XML RecyclerView"></a>主界面XML RecyclerView</h5><pre><code>&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:paddingBottom=&quot;@dimen/activity_vertical_margin&quot;
    android:paddingLeft=&quot;@dimen/activity_horizontal_margin&quot;
    android:paddingRight=&quot;@dimen/activity_horizontal_margin&quot;
    android:paddingTop=&quot;@dimen/activity_vertical_margin&quot;
    tools:context=&quot;.MainActivity&quot;&gt;

    &lt;android.support.v7.widget.RecyclerView
        android:id=&quot;@+id/time_line_recycler&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:clickable=&quot;true&quot;
        android:fadeScrollbars=&quot;true&quot;
        android:fadingEdge=&quot;none&quot;
        android:focusable=&quot;true&quot;
        android:focusableInTouchMode=&quot;true&quot;
        android:overScrollMode=&quot;never&quot;
        android:scrollbarSize=&quot;2dp&quot;
        android:scrollbarThumbVertical=&quot;@color/cyan_500&quot;
        android:scrollbars=&quot;vertical&quot; /&gt;

&lt;/RelativeLayout&gt;
</code></pre><p>在这里就是加上了一个RecyclerView 控件在主界面就OK。</p>
<h5 id="Java_u4EE3_u7801_u90E8_u5206"><a href="#Java_u4EE3_u7801_u90E8_u5206" class="headerlink" title="Java代码部分"></a>Java代码部分</h5><p>在开始之前先来看看我们的文件具体有些神马。</p>
<p><img src="http://www.jcodecraeer.com/uploads/20150825/1440469609114998.png" alt=""></p>
<p>widget中就是具体的自定义控件，model是具体的数据模型，adapter部分，这里有一个Recyclerview的adapter文件，以及一个具体的Item TimeLineViewHolder，当然在这里还定义了一个ItemType类，该类用来标示每个Item的类型，比如头部，第一个，普通，最后一个，底部等等。</p>
<h6 id="TimeLineModel-java"><a href="#TimeLineModel-java" class="headerlink" title="TimeLineModel.java"></a>TimeLineModel.java</h6><pre><code>package net.qiujuer.example.timeline.model;

/**
 * Created by qiujuer
 * on 15/8/23.
 */
public class TimeLineModel {
    private String name;
    private int age;

    public TimeLineModel() {

    }

    public TimeLineModel(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public int getAge() {
        return age;
    }

    public String getName() {
        return name;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public void setName(String name) {
        this.name = name;
    }
}
</code></pre><p>一个名字，一个年龄也就OK。</p>
<h6 id="ItemType-java"><a href="#ItemType-java" class="headerlink" title="ItemType.java"></a>ItemType.java</h6><pre><code>package net.qiujuer.example.timeline.adapter;

/**
 * Created by qiujuer
 * on 15/8/23.
 */
public class ItemType {
    public final static int NORMAL = 0;

    public final static int HEADER = 1;
    public final static int FOOTER = 2;

    public final static int START = 4;
    public final static int END = 8;

    public final static int ATOM = 16;
}
</code></pre><p>分别定义了几个静态值，分别代表普通、头部、底部、开始、结束、原子；当然其中有些可以不用定义。</p>
<h6 id="TimeLineViewHolder-java"><a href="#TimeLineViewHolder-java" class="headerlink" title="TimeLineViewHolder.java"></a>TimeLineViewHolder.java</h6><pre><code>package net.qiujuer.example.timeline.adapter;

import android.support.v7.widget.RecyclerView;
import android.view.View;
import android.widget.TextView;

import net.qiujuer.example.timeline.R;
import net.qiujuer.example.timeline.model.TimeLineModel;
import net.qiujuer.example.timeline.widget.TimeLineMarker;

/**
 * Created by qiujuer
 * on 15/8/23.
 */
public class TimeLineViewHolder extends RecyclerView.ViewHolder {
    private TextView mName;

    public TimeLineViewHolder(View itemView, int type) {
        super(itemView);

        mName = (TextView) itemView.findViewById(R.id.item_time_line_txt);

        TimeLineMarker mMarker = (TimeLineMarker) itemView.findViewById(R.id.item_time_line_mark);
        if (type == ItemType.ATOM) {
            mMarker.setBeginLine(null);
            mMarker.setEndLine(null);
        } else if (type == ItemType.START) {
            mMarker.setBeginLine(null);
        } else if (type == ItemType.END) {
            mMarker.setEndLine(null);
        }

    }

    public void setData(TimeLineModel data) {
        mName.setText(&quot;Name:&quot; + data.getName() + &quot; Age:&quot; + data.getAge());
    }
}
</code></pre><p>该文件为RecyclerView 的Adapter中每个Item需要实现的Holder类。<br>在该类中，我们在构造函数中需要传入一个根View同时传入一个当然item的状态。<br>随后使用find….找到控件，在这里我们把TextView保存起来，而TimeLineView找到后直接进行初始化设置。<br>根据传入的ItemType来判断是否是第一个，最后一个，以及原子；然后设置TimeLineView的属性。<br>在下面的setData方法中我们显示具体的Model数据。</p>
<h6 id="TimeLineAdapter-java"><a href="#TimeLineAdapter-java" class="headerlink" title="TimeLineAdapter.java"></a>TimeLineAdapter.java</h6><p>适配器部分，我们需要做的工作是；根据具体的数据渲染上对应的界面就OK。</p>
<pre><code>package net.qiujuer.example.timeline.adapter;

import android.support.v7.widget.RecyclerView;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;

import net.qiujuer.example.timeline.R;
import net.qiujuer.example.timeline.model.TimeLineModel;

import java.util.List;

/**
 * Created by qiujuer
 * on 15/8/23.
 */
public class TimeLineAdapter extends RecyclerView.Adapter&lt;TimeLineViewHolder&gt; {
    private List&lt;TimeLineModel&gt; mDataSet;

    public TimeLineAdapter(List&lt;TimeLineModel&gt; models) {
        mDataSet = models;
    }

    @Override
    public int getItemViewType(int position) {
        final int size = mDataSet.size() - 1;
        if (size == 0)
            return ItemType.ATOM;
        else if (position == 0)
            return ItemType.START;
        else if (position == size)
            return ItemType.END;
        else return ItemType.NORMAL;
    }

    @Override
    public TimeLineViewHolder onCreateViewHolder(ViewGroup viewGroup, int viewType) {
        // Create a new view.
        View v = LayoutInflater.from(viewGroup.getContext())
                .inflate(R.layout.item_time_line, viewGroup, false);
        return new TimeLineViewHolder(v, viewType);
    }

    @Override
    public void onBindViewHolder(TimeLineViewHolder timeLineViewHolder, int i) {
        timeLineViewHolder.setData(mDataSet.get(i));
    }

    @Override
    public int getItemCount() {
        return mDataSet.size();
    }
}
</code></pre><blockquote>
<p>在这里需要着重说一下：我复写了getItemViewType方法；在该方法中我们需要设置对应的Item的类型；在这里传入的是item的坐标，需要返回的是item的具体状态，该状态标示是int类型；在这里我使用的是ItemType的静态属性。<br>该方法会在调用onCreateViewHolder方法之前调用；而onCreateViewHolder方法中的第二个参数int值也就是从getItemViewType之中来；所以我们可以在这里进行对应的数据状态标示。<br>而在onCreateViewHolder方法中我们返回一个：TimeLineViewHolder就OK，随后在onBindViewHolder方法中进行数据初始化操作。</p>
</blockquote>
<h6 id="MainActivity-java"><a href="#MainActivity-java" class="headerlink" title="MainActivity.java"></a>MainActivity.java</h6><p>上面所有都准备好了，下面就进行具体的显示。<br>在这里就只贴出核心代码了；篇幅也是有些长。</p>
<pre><code>private RecyclerView mRecycler;

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    mRecycler = (RecyclerView) findViewById(R.id.time_line_recycler);
    initRecycler();
}

private void initRecycler() {
    LinearLayoutManager layoutManager = new LinearLayoutManager(this);
    layoutManager.setOrientation(LinearLayoutManager.VERTICAL);

    TimeLineAdapter adapter = new TimeLineAdapter(getData());

    mRecycler.setLayoutManager(layoutManager);
    mRecycler.setAdapter(adapter);
}

private List&lt;TimeLineModel&gt; getData() {
    List&lt;TimeLineModel&gt; models = new ArrayList&lt;TimeLineModel&gt;();

    models.add(new TimeLineModel(&quot;XiaoMing&quot;, 21));
    models.add(new TimeLineModel(&quot;XiaoFang&quot;, 20));
    models.add(new TimeLineModel(&quot;XiaoHua&quot;, 25));
    models.add(new TimeLineModel(&quot;XiaoA&quot;, 22));
    models.add(new TimeLineModel(&quot;XiaoNiu&quot;, 23));

    return models;
}
</code></pre><p>在这里就是傻瓜的操作了，流程就是准备好对应的数据，装进Adapter，准备好对应的布局方式，然后都设置到RecyclerView中就OK。</p>
<h6 id="u6548_u679C-1"><a href="#u6548_u679C-1" class="headerlink" title="效果"></a>效果</h6><p>来看看具体的效果：</p>
<p><img src="http://www.jcodecraeer.com/uploads/20150825/1440469865127253.png" alt=""></p>
<p>效果虽然简单，但是也算是五脏具全；其中无非就是控件的自定义。这个自定义是可以扩展的，大家可以扩展为水平方向试试。</p>
<h6 id="u4EE3_u7801"><a href="#u4EE3_u7801" class="headerlink" title="代码"></a>代码</h6><p>博客代码都开源到项目中了。<br>地址：<a href="https://github.com/qiujuer/BeFoot/tree/master/blog/sample/TimeLine" target="_blank" rel="external">https://github.com/qiujuer/BeFoot/tree/master/blog/sample/TimeLine</a></p>
<h6 id="u5199_u5728_u6700_u540E"><a href="#u5199_u5728_u6700_u540E" class="headerlink" title="写在最后"></a>写在最后</h6><p>文章的开始截屏来源于：最近没事儿捣鼓了一个APP［UPMiss］，一个简单的生日，纪念日提醒软件；欢迎大家尝鲜。</p>
<hr>
<p>转载出处：<a href="http://blog.csdn.net/qiujuer/article/details/47910185" target="_blank" rel="external">http://blog.csdn.net/qiujuer/article/details/47910185</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>看见很多软件中都有时间线的东西，貌似天气啊，旅游啊什么的最多了；具体实现方式很多，在本篇文章中讲解一种自定义View封装的方式。</p>
<h3 id="u6548_u679C"><a href="#u6548_u679C" class="headerlink" title="效果"></a>效果</h3><p>先来看看效果。<br><img src="http://www.jcodecraeer.com/uploads/20150825/1440469250572021.png" alt=""><br>]]>
    
    </summary>
    
      <category term="时间轴" scheme="http://kevinhero.github.io/tags/%E6%97%B6%E9%97%B4%E8%BD%B4/"/>
    
      <category term="技术" scheme="http://kevinhero.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
</feed>
