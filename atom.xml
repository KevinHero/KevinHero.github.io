<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[熊凯的个人博客]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2016-04-05T06:15:02.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[熊凯]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Android开发代码片段]]></title>
    <link href="http://yoursite.com/2016/03/21/android%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/"/>
    <id>http://yoursite.com/2016/03/21/android代码片段/</id>
    <published>2016-03-21T12:33:02.000Z</published>
    <updated>2016-04-05T06:15:02.000Z</updated>
    <content type="html"><![CDATA[<h3 id="1_u3001_u83B7_u53D6_u7535_u6E90_u9501"><a href="#1_u3001_u83B7_u53D6_u7535_u6E90_u9501" class="headerlink" title="1、获取电源锁"></a>1、获取电源锁</h3><pre><code>public static void acquireWakeLock() {
    unlockKeyBoard();
    try {
        if (null == mWakeLock) {
            PowerManager pm = (PowerManager) BaseApplication.getInstance()
                    .getSystemService(Context.POWER_SERVICE);
            try {
                mWakeLock = pm.newWakeLock(PowerManager.FULL_WAKE_LOCK
                        | PowerManager.ACQUIRE_CAUSES_WAKEUP
                        | PowerManager.ON_AFTER_RELEASE, &quot;PushMessageReceiver&quot;); // |
                                                                                    // PowerManager.ON_AFTER_RELEASE
            } catch (Exception e) {
                DbUtils.exceptionHandler(e);
            }
        }
        if (null != mWakeLock) {
            mWakeLock.acquire();
        }
    } catch (Exception e) {
        DbUtils.exceptionHandler(e);
    }
}
</code></pre><a id="more"></a>
<h3 id="2_u3001_u91CA_u653E_u8BBE_u5907_u7535_u6E90_u9501"><a href="#2_u3001_u91CA_u653E_u8BBE_u5907_u7535_u6E90_u9501" class="headerlink" title="2、释放设备电源锁"></a>2、释放设备电源锁</h3><pre><code>public static void releaseWakeLock() {
    try {
        if (null != mWakeLock) {
            mWakeLock.release();
            mWakeLock = null;
        }
    } catch (Exception e) {
        DbUtils.exceptionHandler(e);
    }
}
</code></pre><h3 id="3_u3001_u89E3_u9501_u952E_u76D8"><a href="#3_u3001_u89E3_u9501_u952E_u76D8" class="headerlink" title="3、解锁键盘"></a>3、解锁键盘</h3><pre><code>public static void unlockKeyBoard () {
    KeyguardManager km = (KeyguardManager)ApplicationContext.getInstance().getContext().getSystemService(Context.KEYGUARD_SERVICE);
    km.newKeyguardLock(&quot;Tag For Debug&quot;).disableKeyguard();
}
</code></pre><p>4、获取当前程序版本名</p>
<pre><code>/**  
* 返回当前程序版本名  
*/    
public static String getAppVersionName(Context context) {    
    String versionName = &quot;&quot;;    
    try {    
        // ---get the package info---    
        PackageManager pm = context.getPackageManager();    

        PackageInfo pi = pm.getPackageInfo(context.getPackageName(), 0);    
        versionName = pi.versionName;    //版本名称
        versioncode = pi.versionCode;  //版本号
        if (versionName == null || versionName.length() &lt;= 0) {    
            return &quot;&quot;;    
        }    
    } catch (Exception e) {    
        Log.e(&quot;VersionInfo&quot;, &quot;Exception&quot;, e);    
    }    
    return versionName;    
} 
</code></pre><h3 id="5_u3001_u83B7_u53D6_u5F53_u524D_u5E94_u7528_u7684_u7248_u672C_u53F7"><a href="#5_u3001_u83B7_u53D6_u5F53_u524D_u5E94_u7528_u7684_u7248_u672C_u53F7" class="headerlink" title="5、获取当前应用的版本号"></a>5、获取当前应用的版本号</h3><pre><code>public static String getVersionName() throws Exception  
{  
        // 获取packagemanager的实例  
        PackageManager packageManager = getPackageManager();  
        // getPackageName()是你当前类的包名，0代表是获取版本信息  
        PackageInfo packInfo = packageManager.getPackageInfo(getPackageName(),0);  
        String version = packInfo.versionName;  
        return version;  
}
</code></pre><h3 id="6_u3001_u83B7_u53D6_u5F53_u524D_u7CFB_u7EDF_u7684_u7248_u672C_u53F7"><a href="#6_u3001_u83B7_u53D6_u5F53_u524D_u7CFB_u7EDF_u7684_u7248_u672C_u53F7" class="headerlink" title="6、获取当前系统的版本号"></a>6、获取当前系统的版本号</h3><pre><code>/** 
 * 手机系统版本 
 */  
 public static String getSdkVersion() {  
     return android.os.Build.VERSION.RELEASE;  
 }  
</code></pre><h3 id="7_u3001_u5F53_u6211_u4EEC_u70B9_u51FB_u67D0_u4E2A_u8BDD_u9898_u7684_u9009_u9879_u5361_uFF0C_u4F1A_u5F39_u51FA_u4E00_u4E2Apopupwindow_uFF0C_u91CC_u9762_u6709_u8BF8_u5982__u8BC4_u8BBA_u3001_u56DE_u590D_u7684_u9009_u9879_uFF0C_u4F60_u70B9_u51FB_u8FD9_u4E2A_u9009_u9879_u7684_u65F6_u5019_uFF0C_u9700_u8981_u5B9A_u4F4D_u5230EditText_u7F16_u8F91_u6846_uFF0C_u5E76_u4E14_u81EA_u52A8_u5F39_u51FA_u8F93_u5165_u6CD5_u3002_u53EF_u4EE5_u8003_u8651_u5982_u4E0B_u65B9_u6CD5_uFF1A"><a href="#7_u3001_u5F53_u6211_u4EEC_u70B9_u51FB_u67D0_u4E2A_u8BDD_u9898_u7684_u9009_u9879_u5361_uFF0C_u4F1A_u5F39_u51FA_u4E00_u4E2Apopupwindow_uFF0C_u91CC_u9762_u6709_u8BF8_u5982__u8BC4_u8BBA_u3001_u56DE_u590D_u7684_u9009_u9879_uFF0C_u4F60_u70B9_u51FB_u8FD9_u4E2A_u9009_u9879_u7684_u65F6_u5019_uFF0C_u9700_u8981_u5B9A_u4F4D_u5230EditText_u7F16_u8F91_u6846_uFF0C_u5E76_u4E14_u81EA_u52A8_u5F39_u51FA_u8F93_u5165_u6CD5_u3002_u53EF_u4EE5_u8003_u8651_u5982_u4E0B_u65B9_u6CD5_uFF1A" class="headerlink" title="7、当我们点击某个话题的选项卡，会弹出一个popupwindow，里面有诸如 评论、回复的选项，你点击这个选项的时候，需要定位到EditText编辑框，并且自动弹出输入法。可以考虑如下方法："></a>7、当我们点击某个话题的选项卡，会弹出一个popupwindow，里面有诸如 评论、回复的选项，你点击这个选项的时候，需要定位到EditText编辑框，并且自动弹出输入法。可以考虑如下方法：</h3><pre><code>// 获取编辑框焦点
editText.setFocusable(true);
//打开软键盘
InputMethodManager imm = (InputMethodManager) ctx
.getSystemService(Context.INPUT_METHOD_SERVICE);
imm.toggleSoftInput(0, InputMethodManager.HIDE_NOT_ALWAYS);

//关闭软键盘
imm.hideSoftInputFromWindow(editText.getWindowToken(), 0);
</code></pre><h3 id="8_u3001EditText_u8F6F_u952E_u76D8"><a href="#8_u3001EditText_u8F6F_u952E_u76D8" class="headerlink" title="8、EditText软键盘"></a>8、EditText软键盘</h3><pre><code>//打开软键盘
et_feedback_content.setFocusable(true);
getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_VISIBLE);
//关闭软键盘
((InputMethodManager)getSystemService(Context.INPUT_METHOD_SERVICE)).hideSoftInputFromWindow(input.getWindowToken(), 0); 
</code></pre><h3 id="9_u3001_u8BBE_u7F6E_u5168_u5C4F_u7684Dialog"><a href="#9_u3001_u8BBE_u7F6E_u5168_u5C4F_u7684Dialog" class="headerlink" title="9、设置全屏的Dialog"></a>9、设置全屏的Dialog</h3><pre><code>//在代码里设置Dialog的Theme
Dialog dialog = new Dialog(this, R.style.Dialog_Fullscreen);  
dialog.setContentView(R.layout.main);  
dialog.show(); 

//设置style
 &lt;style name=&quot;Dialog_Fullscreen&quot;&gt; 
   &lt;item name=&quot;android:windowFullscreen&quot;&gt;true&lt;/item&gt; 
   &lt;item name=&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt;  
&lt;/style&gt;   
</code></pre><h3 id="10_u3001_u8BBE_u7F6E_u5168_u5C4F_u7684Dialog_uFF08_u4E8C_uFF09"><a href="#10_u3001_u8BBE_u7F6E_u5168_u5C4F_u7684Dialog_uFF08_u4E8C_uFF09" class="headerlink" title="10、设置全屏的Dialog（二）"></a>10、设置全屏的Dialog（二）</h3><p>我们也可以自定义Dialog，首先继承Dialig，然后再构造函数中添加</p>
<pre><code>super(context, android.R.style.Theme); 
setOwnerActivity((Activity)context);  
</code></pre><h3 id="11_u3001_u8BBE_u7F6E_u5168_u5C4FDialog_uFF08_u4E09_uFF09"><a href="#11_u3001_u8BBE_u7F6E_u5168_u5C4FDialog_uFF08_u4E09_uFF09" class="headerlink" title="11、设置全屏Dialog（三）"></a>11、设置全屏Dialog（三）</h3><p>首先介绍一个方法：getDecorView()</p>
<p>decorView是window中的最顶层view，可以从window中获取到decorView，然后decorView有个getWindowVisibleDisplayFrame方法可以获取到程序显示的区域，包括标题栏，但不包括状态栏。 于是，我们就可以算出状态栏的高度了。</p>
<pre><code>Rect frame = new Rect();
getWindow().getDecorView().getWindowVisibleDisplayFrame(frame);
int statusBarHeight = frame.top;
</code></pre><p>同样我们获取标题栏的高度</p>
<pre><code>getWindow().findViewById(Window.ID_ANDROID_CONTENT)这个方法获取到的view就是程序不包括标题栏的部分，然后就可以知道标题栏的高度了，代码如下：
int contentTop = getWindow().findViewById(Window.ID_ANDROID_CONTENT).getTop();         
int titleBarHeight = contentTop - statusBarHeight; //statusBarHeight是上面所求的状态栏的高度
</code></pre><p>最后：知道上述原理，我们就可以设置我们的Dialog和activity一样大了，Java代码如下：</p>
<pre><code>final Dialog dialog = new Dialog(WenDetailActivity.this, R.style.popupDialog);
        dialog.requestWindowFeature(Window.FEATURE_NO_TITLE);
        dialog.setContentView(R.layout.wen_cover_pager);
        dialog.setCanceledOnTouchOutside(false);
        dialog.setCancelable(false);
        WindowManager.LayoutParams lay = dialog.getWindow().getAttributes();
        DisplayMetrics dm = new DisplayMetrics();
        getWindowManager().getDefaultDisplay().getMetrics(dm);
        Rect rect = new Rect();
        View view = getWindow().getDecorView();//decorView是window中的最顶层view，可以从window中获取到decorView
        view.getWindowVisibleDisplayFrame(rect);
        lay.height = dm.heightPixels - rect.top;
        lay.width = dm.widthPixels;
</code></pre><p>style.xml如下：</p>
<pre><code>&lt;style name=&quot;popupDialog&quot; parent=&quot;@android:style/Theme.Dialog&quot;&gt;
        &lt;item name=&quot;android:windowBackground&quot;&gt;@drawable/filled_activity_bg&lt;/item&gt;
        &lt;item name=&quot;android:backgroundDimEnabled&quot;&gt;false&lt;/item&gt;
        &lt;item name=&quot;android:windowIsFloating&quot;&gt;true&lt;/item&gt;
        &lt;item name=&quot;android:windowIsTranslucent&quot;&gt;true&lt;/item&gt;
        &lt;item name=&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt;
        &lt;item name=&quot;android:windowContentOverlay&quot;&gt;@null&lt;/item&gt;
        &lt;!--&lt;item name=&quot;android:windowAnimationStyle&quot;&gt;@style/dialog_animation&lt;/item&gt;--&gt;
        &lt;item name=&quot;android:colorBackgroundCacheHint&quot;&gt;@null&lt;/item&gt;
        &lt;item name=&quot;android:backgroundDimAmount&quot;&gt;0.6&lt;/item&gt;&lt;!-- 灰度 --&gt;
        &lt;!--&lt;item name=&quot;android:windowFullscreen&quot;&gt;true&lt;/item&gt;--&gt;
 &lt;/style&gt;
</code></pre><h3 id="12_u3001_u5229_u7528_u4EE3_u7801_u6E05_u9664App_u7684_u6570_u636E"><a href="#12_u3001_u5229_u7528_u4EE3_u7801_u6E05_u9664App_u7684_u6570_u636E" class="headerlink" title="12、利用代码清除App的数据"></a>12、利用代码清除App的数据</h3><pre><code>/** 
* 利用代码清除App的数据 
* 平常我们在清除App的数据时,多半在设置中找到对应的App 
* 然后选择其清除数据.下面给出代码实现. 
*  
* 注意事项: 
* 1 设备需要root 
* 2 该示例中删除的是系统级应用 
* 2 注意在命令的末尾需要加上换行\n 
*   这就相当于我们平时在Dos中输入命令后再换行一样. 
*   否则命令不会被执行. 
*/  
private void cleanData(String packageName){  
    try {  
        Process su= Runtime.getRuntime().exec(&quot;su&quot;);  
        String cmd = &quot;cd /data/data/&quot;+packageName+&quot;;&quot;+&quot;rm -r `ls|grep -v lib`&quot;;  
        System.out.println(&quot;------cmd=&quot;+cmd);  
        cmd = cmd + &quot;\n exit\n&quot;;  
        su.getOutputStream().write(cmd.getBytes());  
        if ((su.waitFor() != 0)) {  
            throw new SecurityException();  
        }  
    } catch (Exception e) {  
        System.out.println(&quot;---&gt; 9527 清除数据时 e=&quot;+e.toString());  
    }  

} 
</code></pre><h3 id="13_u3001_u6E05_u9664_u5185/_u5916_u7F13_u5B58_uFF0C_u6E05_u9664_u6570_u636E_u5E93_uFF0C_u6E05_u9664sharedPreference_uFF0C_u6E05_u9664files_u548C_u6E05_u9664_u81EA_u5B9A_u4E49_u76EE_u5F55"><a href="#13_u3001_u6E05_u9664_u5185/_u5916_u7F13_u5B58_uFF0C_u6E05_u9664_u6570_u636E_u5E93_uFF0C_u6E05_u9664sharedPreference_uFF0C_u6E05_u9664files_u548C_u6E05_u9664_u81EA_u5B9A_u4E49_u76EE_u5F55" class="headerlink" title="13、清除内/外缓存，清除数据库，清除sharedPreference，清除files和清除自定义目录"></a>13、清除内/外缓存，清除数据库，清除sharedPreference，清除files和清除自定义目录</h3><pre><code>/** 文 件 名:  DataCleanManager.java  * 描    述:  主要功能有清除内/外缓存，清除数据库，清除sharedPreference，清除files和清除自定义目录  */
import java.io.File;
import android.content.Context;
import android.os.Environment;

/** * 本应用数据清除管理器 */
public class DataCleanManager {
/** * 清除本应用内部缓存(/data/data/com.xxx.xxx/cache) * * @param context */
public static void cleanInternalCache(Context context) {
    deleteFilesByDirectory(context.getCacheDir());
}

/** * 清除本应用所有数据库(/data/data/com.xxx.xxx/databases) * * @param context */
public static void cleanDatabases(Context context) {
    deleteFilesByDirectory(new File(&quot;/data/data/&quot;
            + context.getPackageName() + &quot;/databases&quot;));
}

/**
 * * 清除本应用SharedPreference(/data/data/com.xxx.xxx/shared_prefs) * * @param
 * context
 */
public static void cleanSharedPreference(Context context) {
    deleteFilesByDirectory(new File(&quot;/data/data/&quot;
            + context.getPackageName() + &quot;/shared_prefs&quot;));
}

/** * 按名字清除本应用数据库 * * @param context * @param dbName */
public static void cleanDatabaseByName(Context context, String dbName) {
    context.deleteDatabase(dbName);
}

/** * 清除/data/data/com.xxx.xxx/files下的内容 * * @param context */
public static void cleanFiles(Context context) {
    deleteFilesByDirectory(context.getFilesDir());
}

/**
 * * 清除外部cache下的内容(/mnt/sdcard/android/data/com.xxx.xxx/cache) * * @param
 * context
 */
public static void cleanExternalCache(Context context) {
    if (Environment.getExternalStorageState().equals(
            Environment.MEDIA_MOUNTED)) {
        deleteFilesByDirectory(context.getExternalCacheDir());
    }
}

/** * 清除自定义路径下的文件，使用需小心，请不要误删。而且只支持目录下的文件删除 * * @param filePath */
public static void cleanCustomCache(String filePath) {
    deleteFilesByDirectory(new File(filePath));
}

/** * 清除本应用所有的数据 * * @param context * @param filepath */
public static void cleanApplicationData(Context context, String... filepath) {
    cleanInternalCache(context);
    cleanExternalCache(context);
    cleanDatabases(context);
    cleanSharedPreference(context);
    cleanFiles(context);
    for (String filePath : filepath) {
        cleanCustomCache(filePath);
    }
}

/** * 删除方法 这里只会删除某个文件夹下的文件，如果传入的directory是个文件，将不做处理 * * @param directory */
private static void deleteFilesByDirectory(File directory) {
    if (directory != null &amp;&amp; directory.exists() &amp;&amp; directory.isDirectory()) {
        for (File item : directory.listFiles()) {
            item.delete();
        }
    }
}
}
</code></pre><h3 id="14_u3001Listview_u6D4B_u91CF_u9AD8_u5EA6__uFF08_u653E_u5728_u8BBE_u7F6E_u5B8C_u9002_u914D_u5668_u4E4B_u540E_u8FDB_u884C_u6D4B_u91CF_uFF0C_u653E_u5728_u4E4B_u524D_uFF0C_u6CA1_u6709_u6548_u679C_uFF09"><a href="#14_u3001Listview_u6D4B_u91CF_u9AD8_u5EA6__uFF08_u653E_u5728_u8BBE_u7F6E_u5B8C_u9002_u914D_u5668_u4E4B_u540E_u8FDB_u884C_u6D4B_u91CF_uFF0C_u653E_u5728_u4E4B_u524D_uFF0C_u6CA1_u6709_u6548_u679C_uFF09" class="headerlink" title="14、Listview测量高度 （放在设置完适配器之后进行测量，放在之前，没有效果）"></a>14、Listview测量高度 （放在设置完适配器之后进行测量，放在之前，没有效果）</h3><pre><code>/**
 * 设置高度
 */
 private void setHeight(ListView listView) {
     // 获取listView的适配器
     ListAdapter adapter = listView.getAdapter();
     // 获取视图的个数
     int count = adapter.getCount();
     // 总高度
     int totalHeight = 0;
     // 循环获取视图
     for (int i = 0; i &lt; count; i++) {
         // 通过i获取每个视图
         View view = adapter.getView(i, null, listView);
         // 重新测量view的高度
         view.measure(MeasureSpec.UNSPECIFIED, MeasureSpec.UNSPECIFIED);
         // 获取测量后的高度添加到总高度
         totalHeight += view.getMeasuredHeight();
     }
     // 总高度加上所有分割线的总高度
     totalHeight += listView.getDividerHeight() * (count - 1);
     // 获取listView的布局属性
     LayoutParams params = listView.getLayoutParams();
     // 设置高度
     params.height = totalHeight;
     // 重新设置布局属性
     listView.setLayoutParams(params);
 }
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1_u3001_u83B7_u53D6_u7535_u6E90_u9501"><a href="#1_u3001_u83B7_u53D6_u7535_u6E90_u9501" class="headerlink" title="1、获取电源锁"></a>1、获取电源锁</h3><pre><code>public static void acquireWakeLock() {
    unlockKeyBoard();
    try {
        if (null == mWakeLock) {
            PowerManager pm = (PowerManager) BaseApplication.getInstance()
                    .getSystemService(Context.POWER_SERVICE);
            try {
                mWakeLock = pm.newWakeLock(PowerManager.FULL_WAKE_LOCK
                        | PowerManager.ACQUIRE_CAUSES_WAKEUP
                        | PowerManager.ON_AFTER_RELEASE, &quot;PushMessageReceiver&quot;); // |
                                                                                    // PowerManager.ON_AFTER_RELEASE
            } catch (Exception e) {
                DbUtils.exceptionHandler(e);
            }
        }
        if (null != mWakeLock) {
            mWakeLock.acquire();
        }
    } catch (Exception e) {
        DbUtils.exceptionHandler(e);
    }
}
</code></pre>]]>
    
    </summary>
    
      <category term="写作" scheme="http://yoursite.com/tags/%E5%86%99%E4%BD%9C/"/>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android开发工作中的细节]]></title>
    <link href="http://yoursite.com/2016/03/02/Android%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C%E4%B8%AD%E7%9A%84%E7%BB%86%E8%8A%82/"/>
    <id>http://yoursite.com/2016/03/02/Android开发工作中的细节/</id>
    <published>2016-03-01T18:33:45.000Z</published>
    <updated>2016-04-05T06:44:02.000Z</updated>
    <content type="html"><![CDATA[<ol>
<li><p>全部 Activity 可继承自 BaseActivity，便于统一风格与处理公共事件，构建对话框统一构建器的建立，万一需要整体变动，一处修改到处有效。</p>
</li>
<li><p>数据库表段字段常量和 SQL 逻辑分离，更清晰，建议使用 Lite 系列框架 LiteOrm 库，超级清晰且重心可以放在业务上不用关心数据库细节。</p>
</li>
<li><p>全局变量放全局类中，模块私有放自己的管理类中，让常量清晰且集中.</p>
</li>
<li><p>不要相信庞大的管理类的东西会带来什么好处，可能是一场灾难，而要时刻注意单一职责原则，一个类专心做好一件事情更为清晰。</p>
<a id="more"></a></li>
<li><p>如果数据没有必要加载，数据请务必延迟初始化，谨记为用户节省内存，总不会有坏处。</p>
</li>
<li><p>异常抛出，在合适的位置处理或者集中处理，不要搞的到处是 catch，混乱且性能低，尽量不要在循环体中捕获异常，以提升性能。</p>
</li>
<li><p>地址引用链长时（3 个以上指向）小心内存泄漏，和警惕堆栈地址指向，典型的易发事件是：数据更新了，ListView 视图却没有刷新，这时 Adapter 很可能指向并的并不是你更新的数据容器地址（一般为 List）。</p>
</li>
<li><p>信息同步：不管是数据库还是网网络操作，新插入的数据注意返回 ID（如果没有赋予唯一 ID），否则相当于没有同步。</p>
</li>
<li><p>多线程操作数据库时，db 关闭了会报错，也很可能出现互锁的问题，推荐使用事务，推荐使用自动化的 LiteOrm 库操作。</p>
</li>
<li><p>做之前先考虑那些可以公用，资源，layout，类，做一个结构、架构分析以加快开发，提升代码可复用度。</p>
</li>
<li><p>有序队列操作 add、delete 操作时注意保持排序，否则你会比较难堪喔。</p>
</li>
<li><p>数据库删除数据时，要注意级联操作避免出现永远删不掉的脏数据喔。</p>
</li>
<li><p>关于形参实参：调用函数时参数为基本类型传的是值，即传值；参数为对象传递的是引用，即传址。</p>
</li>
<li><p>listview 在数据未满一屏时，setSelection 函数不起作用；ListView 批量操作时各子项和视图正确对应，可见即所选。</p>
</li>
</ol>
<p>15 控制 Activity 的代码量，保持主要逻辑清晰。其他类遵守 SRP（单一职能），ISP（接口隔离）原则。</p>
<ol>
<li><p>arraylist 执行 remove 时注意移除 int 和 Integer 的区别。你懂得。</p>
</li>
<li><p>Log 请打上 Tag，调试打印一定要做标记，能定位打印位置，否则尴尬是：不知道是哪里在打印。</p>
</li>
<li><p>码块/常量/资源可以集中公用的一定共用，即使共用逻辑稍复杂一点也会值得，修改起来很轻松，修改一种，到处有效。</p>
</li>
<li><p>setSelection 不起作用，尝试 smoothScrollToPosition。ListView 的 LastVisiblePosition（最后一个可见子项）会随着 getView 方法执行位置不同变动而变。</p>
</li>
<li><p>与 Activity 通讯使用 Handler 更方便； 如果你的框架回调链变长，考虑监听者模式简化回调。</p>
</li>
<li><p>监听者模式不方便使用时，推荐 EventBus 框架库，使用时间总线，没接触过的同学可以自行脑补一下哦。</p>
</li>
<li><p>Handler 在子线程线程使用 Looper.prepare，或者 new 的时候给构造函数传入 MainLooper 来确保在主线程 run。</p>
</li>
<li><p>timepicker 点击确定后需要 clearFocus 才能获取手动输入的时间。</p>
</li>
<li><p>构造函数里面极度不推荐启动异步线程，会埋下隐患。比如：异步线程调用了本例的示例，就会悲剧等着崩溃吧。</p>
</li>
<li><p>千万不要理所当然的以为一个对象不会为空，充分的做好容错处理；另外注意 null 也可以插入 ArrayList 等容器中。</p>
</li>
<li><p>ExpandableListView 的子列表不能点击（禁用）要把 Adapter 的 isChildSelectable 方法返回 true。</p>
</li>
<li><p>UI 显示注意内容过长的情形要提前使用 ScrollView 否则在小手机上尴尬你懂得。</p>
</li>
<li><p>注意按钮的感应范围不小于 9mm 否则不易点击；输入框注意光标的位置更易用户输入。</p>
</li>
<li><p>服务器和客户端尽量统一唯一标识（有可能是 ID），否则多少会有歧义和问题。</p>
</li>
<li><p>注释，尽量去写足够的注释，去描述一下思路，达到看了可以明白某一块代码的效果。</p>
</li>
<li><p>完整型数据一定要用 Sqlite 的 Transaction，大数据一定要用。粗略测试插入 100 个数据有 20 倍的提速，插入 1000 个数据就有 100 多倍的提速。</p>
</li>
<li><p>避免 String=”null”的情况出现 String = null,=””都可以。避免出现 title=”无主题”这样的数据提交到数据库浪费空间。</p>
</li>
<li><p>存在多个不同的 dbhelper 实例情况下，sqlitedatabase 对象必然存在不同的实例，多线程同时写入数据，轮流写入数据时会不定时的报 db is locked，引起崩溃，不管是操作同张表还是异表。读和写可以同时并发，轮流无规律的交替执行。同时写入数据时解决方案是用并发的每个线程都用事 务，db 则不会 lock，按次整体写入。</p>
</li>
<li><p>建议整个应用维护一个 dbhelper 实例，只要 db 没有关闭，全局就只有一个 db 实例，多线程并发写入 db 不会 lock，严格交替进行写入：123123123。。。（123 代表不同线程，轮流插入一个记录），读和写均不会锁住 db，读写交替并没有规律，执行次数和程度看 cpu 分配给哪个线程的时间片长。</p>
</li>
<li><p>一个任务使用事务嵌套N个事务，N个事务中有一个失败，这个任务整体失败，全部成功后，数据才写入，具有安全性，整体性。并且事务写入大批量数据的效率经 实际测试成百上千倍的高于一般的单个写入。数据库大量数据、多线程操作建议使用 LiteOrm 数据库框架，更稳定简单。</p>
</li>
<li><p>经常需要用 ListView 或者其它显示大量 Items 的控件实时跟踪或者查看信息，并且希望最新的条目可以自动滚动到可视范围内。通过设置的控件 transcriptMode 属性可以将 Android 平台的控件（支持 ScrollBar）自动滑动到最底部。</p>
</li>
<li><p>Long a; 判断a有没有赋值，if (a == 0) 在a没有赋值情况下会报错。应该 if (a == null)，Integer、Floag 等也一样，原因你懂，只是提醒你要小心喔。</p>
</li>
<li><p>编码遇到读写、出入等逻辑要双向考虑，文件导入导出，字符字节相互转换都要两边转码。</p>
</li>
<li><p>一个 int 值与一个 Integer 对象（能包含 int 值的最小对象）的大小比率约为 1:4（32 位和 64 位机器有不同）。额外的开销源于 JVM 用于描述 Java 对象的元数据也就是 Integer，（Long、Double 等也是）。</p>
</li>
<li><p>对象由元数据和数据组成。元数据包括类（指向类的指针，描述了类的类型），标记（描述了对象状态，如散列码、形状等），锁（对象同步信息）。数组对象还包括大小的元数据。</p>
</li>
<li><p>一个在 32 位 Java 运行时中使用 1GB  Java 堆的 Java 应用程序在迁移到 64 位 Java 运行时之后，通常需要使用 1.7GB 的 Java 堆。</p>
</li>
<li><p>Hash 集合的访问性能比任何 List 的性能都要高，但每条目的成本也要更高。由于访问性能方面的原因，如果您正在创建大集合（例如，用于实现缓存），那么最好使用基于 Hash 的集合，而不必考虑额外的开销。</p>
</li>
<li><p>对于并不那么注重访问性能的较小集合而言，List 则是合理的选择。ArrayList 和 LinkedList 集合的性能大体相同，但其内存占用完全不同：ArrayList 的每条目大小要比 LinkedList 小得多，但它不是准确设置大小的。List 要使用的正确实现是 ArrayList 还是 LinkedList 取决于 List 长度的可预测性。如果长度未知，那么正确的选择可能是 LinkedList，因为集合包含的空白空间更少。如果大小已知或可预知或比较小，那么 ArrayList 的内存开销会更低一些。</p>
</li>
<li><p>选择正确的集合类型使你能够在集合性能与内存占用之间达到合理的平衡。除此之外，你可以通过正确调整集合大小来最大化填充率、最小化未得到利用的空间，从而最大限度地减少内存占用。</p>
</li>
<li><p>充分利用封装（提供接口类来控制访问数据）和委托（helper 对象来实施任务）两种理念。</p>
</li>
<li><p>延迟分配 Hashtable：如果 Hashtable 为空是经常发生的普遍现象，那么仅在存在需要存储的数据时分配 Hashtable 应该是一种合理的做法。将 Hashtable 分配为准确的大小：虽然会有默认大小，但建议使用更为准确的初始大小。</p>
</li>
<li><p>EditText 在 setText 时不要忘记是否需要 setSelection。在大多数情况下是需要设置的。</p>
</li>
<li><p>XML 两种情况要注意：1 属性名字时候有重复；2 注意文本是否包含非法字符，注意使用 CDATA 包裹。</p>
</li>
<li><p>当逻辑没有明显问题时考虑对象属性、函数参数、网络传输参数是否全部了解，是否设置正确。</p>
</li>
<li><p>当出现编译或者运行时错误，别人那没问题时，考虑你的编译环境和环境版本是否有问题。</p>
</li>
<li><p>由于 String 类的 immutable 性质，当 String 变量需要经常变换其值时，应该考虑使用 StringBuilder 提升性能，多线程使用 StringBuffer 操作 string 提高程序效率。</p>
</li>
<li><p>java 栈的优势是比堆速度快，可共享，主要存放临时变量、参数等，堆的优势是可动态分配内存大小。</p>
</li>
<li><p>只要是用 new ()来新建对象的，都会在堆中创建，而且其数据是单独存值的，即使与栈中的数据（值）相同，也不会与栈中的数据共享。</p>
</li>
<li><p>基本数据类型定义的变量称自动变量，存的是‘字面值’，存在于栈中，可共享（存在即不新建）。</p>
</li>
<li><p>多个 RandomAccessFile 对象指向同一个文件，可使用多个线程一起写入无需再自己加锁，经试验结论：三个线程分别写入 100 万次数据，使用锁约 12 秒，不使用约 8.5 秒。100 个线程分别写入 1 万次数据使用锁耗时约 4.2 秒，不使用锁耗时约 3 秒。</p>
</li>
<li><p>XmlPullParser 解析慎用 nextText ()方法，xml 比较复杂，含有空标签、重复名字标签时容易出现异常问题；TEXT 中使用 getText ()方法代替 START_TAG 中使用 nextText ()方法；START_TAG，TEXT，END_TAG 三个事件配合使用。注意每个 xml 节点之间（不管是开始节点还是结束节点）都会出现 TEXT 事件。</p>
</li>
<li><p>改变逻辑的时候考虑全部用到这项功能的地方，分散的地方多了，容易大意。</p>
</li>
<li><p>当系统原生组件出现问题时，查看错误栈信息，自己写一个该组件的子类，并在合适的地方将出错方法复写一下，加上 try catch 保证不崩溃掉。不要扰乱了该系统控件的正常逻辑。</p>
</li>
<li><p>输入控件注意对空格、换行等符号的控制；输入框里内容注意和左右控件的空间，防止误点击。</p>
</li>
<li><p>注意函数参数里的++或者–操作。是++c 还是 c++，区别很大。</p>
</li>
<li><p>各种地方、永远的不要小看 null 指针问题，甚至有些场合宁可错杀（try catch），不可放过。</p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<ol>
<li><p>全部 Activity 可继承自 BaseActivity，便于统一风格与处理公共事件，构建对话框统一构建器的建立，万一需要整体变动，一处修改到处有效。</p>
</li>
<li><p>数据库表段字段常量和 SQL 逻辑分离，更清晰，建议使用 Lite 系列框架 LiteOrm 库，超级清晰且重心可以放在业务上不用关心数据库细节。</p>
</li>
<li><p>全局变量放全局类中，模块私有放自己的管理类中，让常量清晰且集中.</p>
</li>
<li><p>不要相信庞大的管理类的东西会带来什么好处，可能是一场灾难，而要时刻注意单一职责原则，一个类专心做好一件事情更为清晰。</p>]]>
    
    </summary>
    
      <category term="知识库" scheme="http://yoursite.com/tags/%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[日常使用到的梯子]]></title>
    <link href="http://yoursite.com/2016/03/01/%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E5%88%B0%E7%9A%84%E6%A2%AF%E5%AD%90/"/>
    <id>http://yoursite.com/2016/03/01/日常使用到的梯子/</id>
    <published>2016-03-01T04:33:45.000Z</published>
    <updated>2016-04-05T08:47:20.000Z</updated>
    <content type="html"><![CDATA[<p>日常生活中,由于天朝的局域网的限制,很多网站都无法进行使用,虽然国内也有替代的网站,但是作为开发人员来讲,这些事远远不够的,现在就讲我个人在生活工作中使用到梯子,进行总结一下</p>
<h2 id="PC_u7AEF"><a href="#PC_u7AEF" class="headerlink" title="PC端"></a>PC端</h2><p>##全局梯子<br>目前在PC上(window)使用到的全局的梯子 就是 赛风和VPN Gate</p>
<h3 id="u8D5B_u98CE"><a href="#u8D5B_u98CE" class="headerlink" title="赛风"></a>赛风</h3><p>如果能够直接访问 <a herf="http://www.psiphon3.net/zh/index.html"> 直达</a></p>
<h4 id="u7B80_u5355_u4ECB_u7ECD"><a href="#u7B80_u5355_u4ECB_u7ECD" class="headerlink" title="简单介绍"></a>简单介绍</h4><p>赛风是赛风公司的一款新翻墙工具，利用VPN, SSH和HTTP代理软件提供未经审查的访问互联网。赛风的客户端将自动寻找新的接入点，力求最大限度的绕过网络审查。<br><a id="more"></a><br>赛风旨在为您提供在线内容的开放访问。赛风不会增加暴露您的在线隐私，也不应被用作是在线安全工具。</p>
<p><a herf="https://github.com/Psiphon-Labs">源码地址</a></p>
<h3 id="VPN_Gate"><a href="#VPN_Gate" class="headerlink" title="VPN Gate"></a>VPN Gate</h3><h4 id="u7EFC_u8FF0"><a href="#u7EFC_u8FF0" class="headerlink" title="综述"></a>综述</h4><p>VPN Gate 学术实验项目是一个在线服务，由日本国立筑波大学研究生院为学术研究目的运营。本研究的目的是推广 “全球分布式公共 VPN 中继服务器” 的知识。</p>
<h4 id="u4EAE_u70B9"><a href="#u4EAE_u70B9" class="headerlink" title="亮点"></a>亮点</h4><p>VPN 可以绕过防火墙。VPN 可以隐藏你的真实 IP 地址。VPN 可以防止在本地网络上的窃听</p>
<h4 id="u4F7F_u7528"><a href="#u4F7F_u7528" class="headerlink" title="使用"></a>使用</h4><p>这里提供一个<a herf="http://39.118.148.162:33281/cn/">daily链接</a>,不能保证能否使用,如果不能使用,自己又搜索不到,可以邮件给我</p>
<p>##浏览器梯子 </p>
<h3 id="Lantern"><a href="#Lantern" class="headerlink" title="Lantern"></a>Lantern</h3><p>自己用的 最出名的就是<a href="https://getlantern.org/" target="_blank" rel="external">Lantern</a>,配合Chrome使用,安装完成,打开lantern即可访问Google<br><a herf="https://github.com/getlantern">源码地址</a></p>
<h3 id="u4E09_u65B9_u5C01_u88C5_u7684"><a href="#u4E09_u65B9_u5C01_u88C5_u7684" class="headerlink" title="三方封装的"></a>三方封装的</h3><p><a href="http://www.ccav1.me/chromegae.html" target="_blank" rel="external">ChromeGAE</a></p>
<h4 id="u4ECB_u7ECD"><a href="#u4ECB_u7ECD" class="headerlink" title="介绍"></a>介绍</h4><p>ChromeGAE 是基于 Google Chrome 制作的免费浏览器。</p>
<p>集成多个实用的扩展，可以过滤 视频广告、网页广告 等等。</p>
<p>内置科学上网工具，可畅游 Youtube Facebook Twitter 等网站！</p>
<h2 id="u624B_u673A_u68AF_u5B50"><a href="#u624B_u673A_u68AF_u5B50" class="headerlink" title="手机梯子"></a>手机梯子</h2><p>赛风 lantern</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>日常生活中,由于天朝的局域网的限制,很多网站都无法进行使用,虽然国内也有替代的网站,但是作为开发人员来讲,这些事远远不够的,现在就讲我个人在生活工作中使用到梯子,进行总结一下</p>
<h2 id="PC_u7AEF"><a href="#PC_u7AEF" class="headerlink" title="PC端"></a>PC端</h2><p>##全局梯子<br>目前在PC上(window)使用到的全局的梯子 就是 赛风和VPN Gate</p>
<h3 id="u8D5B_u98CE"><a href="#u8D5B_u98CE" class="headerlink" title="赛风"></a>赛风</h3><p>如果能够直接访问 <a herf="http://www.psiphon3.net/zh/index.html"> 直达</a></p>
<h4 id="u7B80_u5355_u4ECB_u7ECD"><a href="#u7B80_u5355_u4ECB_u7ECD" class="headerlink" title="简单介绍"></a>简单介绍</h4><p>赛风是赛风公司的一款新翻墙工具，利用VPN, SSH和HTTP代理软件提供未经审查的访问互联网。赛风的客户端将自动寻找新的接入点，力求最大限度的绕过网络审查。<br>]]>
    
    </summary>
    
      <category term="VPN" scheme="http://yoursite.com/tags/VPN/"/>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android小知识库]]></title>
    <link href="http://yoursite.com/2016/03/01/Android%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"/>
    <id>http://yoursite.com/2016/03/01/Android开发中的小知识点汇总/</id>
    <published>2016-02-29T18:33:45.000Z</published>
    <updated>2016-04-05T06:42:31.000Z</updated>
    <content type="html"><![CDATA[<p>这份是我工作以来，总结的小知识库，有些知识点现在看来太LOW了，把还觉得有用的分享出来！</p>
<h3 id="Genymotion_u4E0B_u8F7D_u865A_u62DF_u955C_u50CFConnection_timeout"><a href="#Genymotion_u4E0B_u8F7D_u865A_u62DF_u955C_u50CFConnection_timeout" class="headerlink" title="Genymotion下载虚拟镜像Connection timeout"></a>Genymotion下载虚拟镜像Connection timeout</h3><p>Add new device出现的问题：</p>
<p>Failed to deploy virtual device.<br>Unable to create virtual device.Connection timeout occurred.</p>
<p>解决方案：</p>
<p>当选择Google Nexus 5 - 6.0.0 - API 23 - 1080x1920下载device失败后，到C:\Users\用户主目录\AppData\Local\Genymobile\Genymotion\ova下看到genymotion_vbox86p_6.0_160114_090449.ova，大小却是0KB，在C:\Users\用户主目录\AppData\Local\Genymobile\genymotion.log，打开该文件，找到类似“<a href="http://files2.genymotion.com/dists/6.0.0/ova/genymotion_vbox86p_6.0_160114_090449.ova”路径，即您想要下载的镜像文件URL；" target="_blank" rel="external">http://files2.genymotion.com/dists/6.0.0/ova/genymotion_vbox86p_6.0_160114_090449.ova”路径，即您想要下载的镜像文件URL；</a><br>用迅雷去下载，下载完成后放到C:\Users\用户主目录\AppData\Local\Genymobile\Genymotion\ova；<br>重新点击Google Nexus 5 - 6.0.0 - API 23 - 1080x1920去下载，验证安装后即会显示在设备列表中。<br><a id="more"></a></p>
<h3 id="Android_Studio__u5982_u4F55Debug"><a href="#Android_Studio__u5982_u4F55Debug" class="headerlink" title="Android Studio 如何Debug"></a>Android Studio 如何Debug</h3><p>单击F5(Step Over)，单行一个个方法执行<br>单击F6(Step Into)，单行执行<br>单击F7(Step Out)，不往下执行，回到上一行<br>单击F8(Resume Program)，跳出当前断点</p>
<h3 id="Android_Studio_u8BBE_u7F6E_u9ED8_u8BA4_u7684_u7B7E_u540D_u6587_u4EF6"><a href="#Android_Studio_u8BBE_u7F6E_u9ED8_u8BA4_u7684_u7B7E_u540D_u6587_u4EF6" class="headerlink" title="Android Studio设置默认的签名文件"></a>Android Studio设置默认的签名文件</h3><p>新浪微博SSO登录，微信分享这些都需要签名打包，才能看到效果，设置默认签名文件为自己的签名jks，这样就不需要打包了。<br>在app目录下添加你的.jks，然后app的build.gradle文件中的增加以下内容：<br>第一种：</p>
<pre><code>android {  
    signingConfigs {  
        debug {  
            storeFile file(&quot;你的.jks&quot;)
            storePassword &apos;android&apos;
            keyAlias &apos;android&apos;
            keyPassword &apos;android&apos;
        }          
    }      
}
</code></pre><p>第二种：</p>
<pre><code>android {  
    signingConfigs {  
        release {  
            storeFile file(&quot;你的.jks&quot;)
            storePassword &apos;android&apos;
            keyAlias &apos;android&apos;
            keyPassword &apos;android&apos;
        }          
    }  
    buildTypes {
        debug {
            signingConfig signingConfigs.release
        }        
    }
}
</code></pre><p>这样编译出来的debug版本直接用的是你的正式签名</p>
<h3 id="Fragment_u61D2_u52A0_u8F7D"><a href="#Fragment_u61D2_u52A0_u8F7D" class="headerlink" title="Fragment懒加载"></a>Fragment懒加载</h3><pre><code>protected boolean isVisible;

@Override
public void setUserVisibleHint(boolean isVisibleToUser) {
    super.setUserVisibleHint(isVisibleToUser);
    if (getUserVisibleHint()) {
        isVisible = true;
        onVisible();
    } else {
        isVisible = false;
        onInvisible();
    }
}

protected void onVisible() {
    lazyLoad();
}

protected void lazyLoad() {
    if (!isVisible) {
        return;
    }
    getData();
}

protected void onInvisible() {
}
</code></pre><h3 id="Android_studio_u5934_u6CE8_u91CA_u548C_u65B9_u6CD5_u6CE8_u91CA"><a href="#Android_studio_u5934_u6CE8_u91CA_u548C_u65B9_u6CD5_u6CE8_u91CA" class="headerlink" title="Android studio头注释和方法注释"></a>Android studio头注释和方法注释</h3><blockquote>
<p>File | Settings | Editor|File and Code Templates|Includes|File Header</p>
</blockquote>
<pre><code>/**
* Created by ${USER} on ${DATE}.
*/
</code></pre><p>输入我们想要设置的注释模板</p>
<pre><code>adapter.getPositionForSelection()和getSectionForPosition()
getPositionForSection()根据分类列的索引号获得该序列的首个位置
getSectionForPosition()通过该项的位置，获得所在分类组的索引号

getResources().getColor(R.color.color_name) is deprecated和drawableTop

textView.setTextColor(Color.parseColor(&quot;#FFFFFF&quot;));
//或者
ContextCompat.getColor(context, R.color.color_name)

private void showPopupMenu(View v) {
    final View bgView = View.inflate(DemoApplication.getContext(), R.layout.demo_popup_window_bg, null);
    bgView.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            hidePopupWindow();
        }
    });
    if (mPopupBackground == null) {
        mPopupBackground = new PopupWindow(bgView, ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);
    }
    mPopupBackground.showAtLocation(v, Gravity.BOTTOM, 0, 0);
}
</code></pre><p>v：父布局<br>    demo_popup_window_bg.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:background=&quot;@color/aliwx_common_alpha_black&quot;&gt;

&lt;/LinearLayout&gt;
</code></pre><h3 id="onFinishInflate_28_29"><a href="#onFinishInflate_28_29" class="headerlink" title="onFinishInflate()"></a>onFinishInflate()</h3><p>view的onFinishInflate()何时调用的？</p>
<p>当View中所有的子控件均被映射成xml后触发；</p>
<pre><code>MyView mv = (MyView)View.inflate (context,R.layout.my_view,null);
</code></pre><p>当加载完成xml后，就会执行那个方法；</p>
<p>我们一般使用View的流程是在onCreate中使用setContentView来设置要显示Layout文件或直接创建一个View，在当设置了ContentView之后系统会对这个View进行解析，然后回调当前视图View中的onFinishInflate方法。只有解析了这个View我们才能在这个View容器中获取到拥有Id的组件，同样因为系统解析完View之后才会调用onFinishInflate方法，所以我们自定义组件时可以onFinishInflate方法中获取指定子View的引用。</p>
<h3 id="Fragment_u8BBE_u7F6E_u9690_u85CF_u6216_u663E_u793A_u67D0_u4E2AFragment"><a href="#Fragment_u8BBE_u7F6E_u9690_u85CF_u6216_u663E_u793A_u67D0_u4E2AFragment" class="headerlink" title="Fragment设置隐藏或显示某个Fragment"></a>Fragment设置隐藏或显示某个Fragment</h3><h4 id="MainFragment_u70B9_u51FB"><a href="#MainFragment_u70B9_u51FB" class="headerlink" title="MainFragment点击"></a>MainFragment点击</h4><pre><code>public void onItemClick(AdapterView&lt;?&gt; adapterView, View view,
                            int position, long id) {

        ((MainActivity) getActivity()).showImageFragment(true, mData.get(position).get(&quot;title&quot;).toString(), mData.get(position).get(&quot;imgUrl&quot;).toString());

    }
</code></pre><h4 id="MainActivity"><a href="#MainActivity" class="headerlink" title="MainActivity"></a>MainActivity</h4><pre><code>public void showImageFragment(boolean show, String imgTxt, String imgUrl) {
        // showActionbarWithTabs(!show);
        if (show) {
            getSupportFragmentManager().beginTransaction()
                    .show(imageDetailFragment).commit();
            imageDetailFragment.setImgData(imgTxt, imgUrl);
        } else {
            getSupportFragmentManager().beginTransaction()
                    .hide(imageDetailFragment).commit();
        }

    }
</code></pre><h3 id="u83B7_u53D6arrt_u7684_u503C"><a href="#u83B7_u53D6arrt_u7684_u503C" class="headerlink" title="获取arrt的值"></a>获取arrt的值</h3><p>不同主题下需要把颜色，数值写成attr属性<br>xml里，我们可以简单的引用attr属性值</p>
<pre><code>android:background=&quot;?attr/colorPrimary&quot;
</code></pre><h4 id="u4EE3_u7801_u83B7_u53D6"><a href="#u4EE3_u7801_u83B7_u53D6" class="headerlink" title="代码获取"></a>代码获取</h4><pre><code>TypedValue typedValue = new TypedValue();
mContext.getTheme().resolveAttribute(R.attr.colorPrimary, typedValue, true);
int colorPrimary = typedValue.data;//value.data里面存储着的就是获取到的colorPrimary的值
</code></pre><h3 id="u62E8_u53F7_u76D8_u62E8_u6253_u7535_u8BDD"><a href="#u62E8_u53F7_u76D8_u62E8_u6253_u7535_u8BDD" class="headerlink" title="拨号盘拨打电话"></a>拨号盘拨打电话</h3><pre><code>Intent intent = new Intent(Intent.ACTION_CALL,
Uri.parse(&quot;tel:&quot; + &quot;400-036-1977&quot;));
// intent.setAction(Intent.ACTION_CALL);// 直接拨号
intent.setAction(Intent.ACTION_DIAL);// 拨号盘
startActivity(intent);
</code></pre><h3 id="Drawable_/Bitmap_u3001String/InputStream_u3001Bitmap/byte_5B_5D_u4E92_u8F6C"><a href="#Drawable_/Bitmap_u3001String/InputStream_u3001Bitmap/byte_5B_5D_u4E92_u8F6C" class="headerlink" title="Drawable /Bitmap、String/InputStream、Bitmap/byte[]互转"></a>Drawable /Bitmap、String/InputStream、Bitmap/byte[]互转</h3><pre><code>http://wuxiaolong.me/2015/08/10/Drawable-to-Bitmap/
</code></pre><h3 id="ProgressDialog"><a href="#ProgressDialog" class="headerlink" title="ProgressDialog"></a>ProgressDialog</h3><pre><code>final ProgressDialog progress = new ProgressDialog(LoginActivity.this);
        progress.setMessage(&quot;请稍等...&quot;);
        progress.setCanceledOnTouchOutside(false);
        progress.show();
progress.dismiss();
</code></pre><h3 id="u6BEB_u79D2"><a href="#u6BEB_u79D2" class="headerlink" title="毫秒"></a>毫秒</h3><p>毫秒Calendar.getInstance().getTimeInMillis()和System.currentTimeMillis()</p>
<h3 id="Fragment_setUserVisibleHint_28boolean_isVisibleToUser_29"><a href="#Fragment_setUserVisibleHint_28boolean_isVisibleToUser_29" class="headerlink" title="Fragment setUserVisibleHint(boolean isVisibleToUser)"></a>Fragment setUserVisibleHint(boolean isVisibleToUser)</h3><pre><code>@Override
public void setUserVisibleHint(boolean isVisibleToUser) {
    super.setUserVisibleHint(isVisibleToUser);
    if (isVisibleToUser) {
        //相当于Fragment的onResume
    } else {
        //相当于Fragment的onPause
    }
}
</code></pre><h3 id="Fragment_onActivityResult"><a href="#Fragment_onActivityResult" class="headerlink" title="Fragment onActivityResult"></a>Fragment onActivityResult</h3><pre><code>public void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        getActivity();
        if (resultCode == Activity.RESULT_OK
                &amp;&amp; requestCode == AppUtils.REQUEST_CODE_ISLOGIN) {
            // 检查是否完善资料

            if (AppUtils.getSharedPreferences(getActivity()).getBoolean(
                    &quot;hasPersonalData&quot;, false)) {
                // 取本地存取是否完善资料,完善直接提示咨询对话框
                consultationDialog();
            } else {
                getCheckPersonalData();
            }

        }
    } 

startActivityForResult(intent,AppConfig.REQUEST_CODE_DIALOGUE);// 不是调用 getActivity().startActivityForResult()。
</code></pre><h3 id="dimen_u4EE3_u7801_u53D6_u503C"><a href="#dimen_u4EE3_u7801_u53D6_u503C" class="headerlink" title="dimen代码取值"></a>dimen代码取值</h3><p>getDimension方法获取到资源文件中定义的dimension值。</p>
<pre><code>Resources res = getResources();
float fontSize = res.getDimension(R.dimen.font_size);
</code></pre><h3 id="u6570_u7EC4_u521D_u59CB_u5316_u8D4B_u503C"><a href="#u6570_u7EC4_u521D_u59CB_u5316_u8D4B_u503C" class="headerlink" title="数组初始化赋值"></a>数组初始化赋值</h3><p>1、创建数组后，通过循环对数组赋值。<br>例如代码：</p>
<pre><code>int [] nums = new int [100];
for(int i=0;i&lt;10;i++){
nums[i] = i;
}
</code></pre><p>2、例如代码：</p>
<pre><code>int [] nums = {0,1,2,3,4,5,6,7,8,9};
</code></pre><p>3、</p>
<pre><code>int [] nums = new int[]{0,1,2,3,4,5,6,7,8,9};
</code></pre><h3 id="Fragment-isAdded_28_29"><a href="#Fragment-isAdded_28_29" class="headerlink" title="Fragment.isAdded()"></a>Fragment.isAdded()</h3><pre><code>Fragment mBeforeFragment = new Fragment();
public void switchFragment(Fragment currentFragment) {
if (currentFragment.isAdded()) {
getSupportFragmentManager().beginTransaction().hide(mBeforeFragment).show(currentFragment).commit();
} else {
getSupportFragmentManager().beginTransaction().hide(mBeforeFragment).add(R.id.container, currentFragment).commit();
}
mBeforeFragment = currentFragment;
}
</code></pre><p>调用：</p>
<pre><code>switchFragment(HomeFragment.newInstance());
HomeFragment


public static HomeFragment homeFragment = null;

public static HomeFragment newInstance() {
if (homeFragment == null) {
homeFragment = new HomeFragment();
}
return homeFragment;
}
</code></pre><h3 id="android_u4E4BinputType_u5C5E_u6027"><a href="#android_u4E4BinputType_u5C5E_u6027" class="headerlink" title="android之inputType属性"></a>android之inputType属性</h3><pre><code>&lt;EditText android:layout_width=&quot;fill_parent&quot; 
android:layout_height=&quot;wrap_content&quot; 
android:inputType=&quot;phone&quot; /&gt;
</code></pre><p>//文本类型，多为大写、小写和数字符号。</p>
<pre><code>android:inputType=&quot;none&quot;
android:inputType=&quot;text&quot;
android:inputType=&quot;textCapCharacters&quot; 字母大写
android:inputType=&quot;textCapWords&quot; 首字母大写
android:inputType=&quot;textCapSentences&quot; 仅第一个字母大写
android:inputType=&quot;textAutoCorrect&quot; 自动完成
android:inputType=&quot;textAutoComplete&quot; 自动完成
android:inputType=&quot;textMultiLine&quot; 多行输入
android:inputType=&quot;textImeMultiLine&quot; 输入法多行（如果支持）
android:inputType=&quot;textNoSuggestions&quot; 不提示
android:inputType=&quot;textUri&quot; 网址
android:inputType=&quot;textEmailAddress&quot; 电子邮件地址
android:inputType=&quot;textEmailSubject&quot; 邮件主题
android:inputType=&quot;textShortMessage&quot; 短讯
android:inputType=&quot;textLongMessage&quot; 长信息
android:inputType=&quot;textPersonName&quot; 人名
android:inputType=&quot;textPostalAddress&quot; 地址
android:inputType=&quot;textPassword&quot; 密码
android:inputType=&quot;textVisiblePassword&quot; 可见密码
android:inputType=&quot;textWebEditText&quot; 作为网页表单的文本
android:inputType=&quot;textFilter&quot; 文本筛选过滤
android:inputType=&quot;textPhonetic&quot; 拼音输入
</code></pre><p>//数值类型</p>
<pre><code>android:inputType=&quot;number&quot; 数字
android:inputType=&quot;numberSigned&quot; 带符号数字格式
android:inputType=&quot;numberDecimal&quot; 带小数点的浮点格式
android:inputType=&quot;phone&quot; 拨号键盘
android:inputType=&quot;datetime&quot; 时间日期
android:inputType=&quot;date&quot; 日期键盘
android:inputType=&quot;time&quot; 时间键盘
</code></pre><h3 id="ImageView-ScaleType"><a href="#ImageView-ScaleType" class="headerlink" title="ImageView.ScaleType"></a>ImageView.ScaleType</h3><pre><code>（1）ImageView.ScaleType.center:图片位于视图中间，但不执行缩放。
（2）ImageView.ScaleType.CENTER_CROP 按统一比例缩放图片（保持图片的尺寸比例）便于图片的两维（宽度和高度）等于或者大于相应的视图的维度
（3）ImageView.ScaleType.CENTER_INSIDE按统一比例缩放图片（保持图片的尺寸比例）便于图片的两维（宽度和高度）等于或者小于相应的视图的维度
（4）ImageView.ScaleType.FIT_CENTER缩放图片使用center
（5）ImageView.ScaleType.FIT_END缩放图片使用END
（6）ImageView.ScaleType.FIT_START缩放图片使用START
（7）ImageView.ScaleType.FIT_XY缩放图片使用XY
（8）ImageView.ScaleType.MATRIX当绘制时使用图片矩阵缩放
</code></pre><h3 id="u8C03_u7528_u7CFB_u7EDF_u53D1_u9001_u77ED_u4FE1_u754C_u9762"><a href="#u8C03_u7528_u7CFB_u7EDF_u53D1_u9001_u77ED_u4FE1_u754C_u9762" class="headerlink" title="调用系统发送短信界面"></a>调用系统发送短信界面</h3><pre><code>/**
* 发送短信
* @param smsBody
*/
private void sendSMS(String smsBody)
{
//Uri smsToUri = Uri.parse(&quot;smsto:10000&quot;); //如果想指定发送人
Uri smsToUri = Uri.parse(&quot;smsto:&quot;);
Intent intent = new Intent(Intent.ACTION_SENDTO, smsToUri);
intent.putExtra(&quot;sms_body&quot;, smsBody);
startActivity(intent);
}
</code></pre><h3 id="u8DF3_u8F6C_u5E02_u573A_u641C_u7D22_u67D0_u6B3E_u8F6F_u4EF6"><a href="#u8DF3_u8F6C_u5E02_u573A_u641C_u7D22_u67D0_u6B3E_u8F6F_u4EF6" class="headerlink" title="跳转市场搜索某款软件"></a>跳转市场搜索某款软件</h3><pre><code>Intent intent = new Intent(
                &quot;android.intent.action.VIEW&quot;);
        intent.setData(Uri
                .parse(&quot;market://details?id=com.adobe.flashplayer&quot;));
        startActivity(intent);
</code></pre><h3 id="u68C0_u6D4B_u7CFB_u7EDF_u4E2D_u662F_u5426_u5B89_u88C5_u67D0_u6B3E_u8F6F_u4EF6"><a href="#u68C0_u6D4B_u7CFB_u7EDF_u4E2D_u662F_u5426_u5B89_u88C5_u67D0_u6B3E_u8F6F_u4EF6" class="headerlink" title="检测系统中是否安装某款软件"></a>检测系统中是否安装某款软件</h3><pre><code>//检测系统中是否已经安装了adobe flash player插件，插件的packageName是com.adobe.flashplayer：
private boolean check() {
        PackageManager pm = getPackageManager();
        List&lt;PackageInfo&gt; infoList = pm
                .getInstalledPackages(PackageManager.GET_SERVICES);
        for (PackageInfo info : infoList) {
            if (&quot;com.adobe.flashplayer&quot;.equals(info.packageName)) {
                return true;
            }
        }
        return false;
}

private void isAvilible(String packageName) {

        PackageInfo packageInfo;
        try {
            packageInfo = this.getPackageManager().getPackageInfo(packageName,
                    0);

        } catch (NameNotFoundException e) {
            packageInfo = null;
            e.printStackTrace();
        }
        if (packageInfo != null) {

        //1、通过包名
        Intent intent = new Intent();
        intent = getPackageManager().getLaunchIntentForPackage(packageName);
        startActivity(intent);

        //2、通过类名： 
        Intent intent=new Intent();  
        intent.setComponent(new ComponentName(packageName, &quot;com.joe.internet.Main&quot;));  
        startActivity(intent);  
            } 

        }
</code></pre><h3 id="u5BF9_u8BDD_u6846_u83DC_u5355"><a href="#u5BF9_u8BDD_u6846_u83DC_u5355" class="headerlink" title="对话框菜单"></a>对话框菜单</h3><pre><code>new AlertDialog.Builder(this)
                    .setTitle(&quot;choice&quot;)
                    .setItems(new String[] { &quot;选择1&quot;, &quot;选择2&quot;, &quot;选择3&quot;, &quot;选择4&quot; },
                            new DialogInterface.OnClickListener() {

                                @Override
                                public void onClick(DialogInterface dialog,
                                        int which) {
                                    Toast.makeText(MyContentActivity.this,
                                            which + &quot;&quot;, Toast.LENGTH_SHORT)
                                            .show();

                                }
                            }).show();
</code></pre><h3 id="u5B9A_u4E49ProgressBar"><a href="#u5B9A_u4E49ProgressBar" class="headerlink" title="定义ProgressBar"></a>定义ProgressBar</h3><pre><code>&lt;ProgressBar
        android:id=&quot;@+id/mProgress&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;          
        android:indeterminateDrawable=&quot;@drawable/progress_rotate&quot; /&gt;
</code></pre><p>progress_rotate：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt;
    &lt;item&gt;
        &lt;rotate
            android:drawable=&quot;@drawable/progressbar&quot;
            android:duration=&quot;300&quot;
            android:fromDegrees=&quot;0.0&quot;
            android:pivotX=&quot;50.0%&quot;
            android:pivotY=&quot;50.0%&quot;
            android:toDegrees=&quot;360.0&quot; /&gt;
    &lt;/item&gt;
&lt;/layer-list&gt;
</code></pre><h3 id="u5E7B_u706F_u7247_u6548_u679C"><a href="#u5E7B_u706F_u7247_u6548_u679C" class="headerlink" title="幻灯片效果"></a>幻灯片效果</h3><p>xml</p>
<pre><code>&lt;ProgressBar
        android:id=&quot;@+id/ProgressBar01&quot;
        style=&quot;@style/animStyle&quot;
        android:layout_width=&quot;fill_parent&quot;
        android:layout_height=&quot;fill_parent&quot;
        android:layout_centerInParent=&quot;true&quot; /&gt;
</code></pre><p>style</p>
<pre><code>&lt;style name=&quot;animStyle&quot; parent=&quot;@android:style/Widget.ProgressBar.Large&quot;&gt;
        &lt;item name=&quot;android:indeterminateDrawable&quot;&gt;@anim/test&lt;/item&gt;
&lt;/style&gt;
</code></pre><p>anim</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:oneshot=&quot;false&quot; &gt;

    &lt;item
        android:drawable=&quot;@drawable/t1&quot;
        android:duration=&quot;500&quot;/&gt;
    &lt;item
        android:drawable=&quot;@drawable/t2&quot;
        android:duration=&quot;500&quot;/&gt;
    &lt;item
        android:drawable=&quot;@drawable/t3&quot;
        android:duration=&quot;500&quot;/&gt;
    &lt;item
        android:drawable=&quot;@drawable/t4&quot;
        android:duration=&quot;500&quot;/&gt;
    &lt;item
        android:drawable=&quot;@drawable/t5&quot;
        android:duration=&quot;500&quot;/&gt;

&lt;/animation-list&gt;
</code></pre><h3 id="MD5_u52A0_u5BC6"><a href="#MD5_u52A0_u5BC6" class="headerlink" title="MD5加密"></a>MD5加密</h3><pre><code>public String Md5(String plainText) {
        String result = &quot;&quot;;
        try {
            MessageDigest md = MessageDigest.getInstance(&quot;MD5&quot;);
            md.update(plainText.getBytes());
            byte b[] = md.digest();

            int i;

            StringBuffer buf = new StringBuffer(&quot;&quot;);
            for (int offset = 0; offset &lt; b.length; offset++) {
                i = b[offset];
                if (i &lt; 0)
                    i += 256;
                if (i &lt; 16)
                    buf.append(&quot;0&quot;);
                buf.append(Integer.toHexString(i));
            }
            result = buf.toString().toUpperCase();// 32位的加密（转成大写）

            buf.toString().substring(8, 24);// 16位的加密

        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
        return result;
    }
</code></pre><h3 id="u8BBE_u7F6E_u81EA_u52A8_u8DF3_u8F6C_u9875_u9762"><a href="#u8BBE_u7F6E_u81EA_u52A8_u8DF3_u8F6C_u9875_u9762" class="headerlink" title="设置自动跳转页面"></a>设置自动跳转页面</h3><p>Timer</p>
<pre><code>Timer timer = new Timer();
        timer.schedule(new TimerTask() {
            @Override
            public void run() {
                // TODO Auto-generated method stub
                Intent goIntent = new Intent();
                goIntent.setClass(LauncherActivity.this, DemoActivity.class);
                startActivity(goIntent);
            }
        }, 3 * 1000);
    }
</code></pre><h3 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h3><pre><code>new Handler().postDelayed(new Runnable() {
            @Override
            public void run() {
                startActivity(new Intent(SplashScreen.this,
                        DomobSampleActivity.class));
                finish();
            }
        }, 1000);
</code></pre><h3 id="u968F_u673A_u53D6_u6570"><a href="#u968F_u673A_u53D6_u6570" class="headerlink" title="随机取数"></a>随机取数</h3><pre><code>List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
        for (int i = 0; i &lt; 10; i++) {
            list.add(i);
        }
        Collections.shuffle(list);
        for (int v : list) {
            Log.d(&quot;wxl&quot;, &quot;V===&quot; + v);
        }
</code></pre><p>或：</p>
<pre><code>Random random = new Random();
int ran = random.nextInt(keywordsList.size());
String tmp = keywordsList.get(ran).get(&quot;keyword&quot;).toString();
</code></pre><h3 id="selector_u4E0B_u7684_u5C5E_u6027_u503C"><a href="#selector_u4E0B_u7684_u5C5E_u6027_u503C" class="headerlink" title="selector下的属性值"></a>selector下的属性值</h3><pre><code>android:state_pressed
如果是true，当被点击时显示该图片，如果是false没被按下时显示默认。
android:state_focused
true，获得焦点时显示；false，没获得焦点显示默认。
android:state_selected
true，当被选择时显示该图片；false，当未被选择时显示该图片。
android:state_checkable
true，当 能使用时显示该图片；false，当CheckBox不能使用时显示该图片。
android:state_checked
true，当CheckBox选中时显示该图片；false，当CheckBox为选中时显示该图片。
android:state_enabled
true，当该组件能使用时显示该图片；false，当该组件不能使用时显示该图片。
android:state_window_focused
true，当此activity获得焦点在最前面时显示该图片；false，当没在最前面时显示该图片。


&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
    &lt;item android:state_pressed=&quot;true&quot;
        android:drawable=&quot;@drawable/button_pressed&quot;/&gt;&lt;!-- pressed --&gt;
    &lt;item android:state_focused=&quot;true&quot;
        android:drawable=&quot;@drawable/button_focused&quot;/&gt;&lt;!-- focused --&gt;
    &lt;item android:drawable=&quot;@drawable/button_normal&quot;/&gt;&lt;!-- default --&gt;
&lt;/selector&gt;
</code></pre><h3 id="u5E26_u4E0B_u5212_u7EBF_u7684EditText"><a href="#u5E26_u4E0B_u5212_u7EBF_u7684EditText" class="headerlink" title="带下划线的EditText"></a>带下划线的EditText</h3><pre><code>public class LinedEditText extends EditText {
    private Paint linePaint;
    private float margin;
    private int paperColor;

    public LinedEditText(Context paramContext, AttributeSet paramAttributeSet) {
        super(paramContext, paramAttributeSet);
        this.linePaint = new Paint();
    }
    @Override
    protected void onDraw(Canvas paramCanvas) {
        paramCanvas.drawColor(this.paperColor);
        int i = getLineCount();// 得到总的行數
        int j = getHeight();// 获得TextView的高度
        int k = getLineHeight();// 获得TextView的行高
        int m = j / k + 1;// 总的线数
        if (i &lt; m)
            i = m;
        int n = getCompoundPaddingTop();
        Log.d(&quot;wxl&quot;, &quot;n----&quot; + n);
        paramCanvas.drawLine(0.0F, n, getRight(), n, this.linePaint);
        for (int i2 = 0;; i2++) {
            if (i2 &gt;= i) {
                setPadding(10 + (int) this.margin, 0, 0, 0);
                super.onDraw(paramCanvas);
                paramCanvas.restore();
                return;
            }
            n += k;
            paramCanvas.drawLine(0.0F, n, getRight(), n, this.linePaint);
            paramCanvas.save();
        }
    }
}
</code></pre><p>主要工作就是重载onDraw方法，利用从TextView继承下来的getLineCount函数获取文本所占的行数，以及getLineBounds来获取特定行的基准高度值，而且这个函数第二个参数会返回此行的“外包装”值。再利用这些值绘制这一行的线条。为了让界面的View使用自定义的EditText类，必须在配置文件中进行设置</p>
<h3 id="u5173_u95ED_u952E_u76D8"><a href="#u5173_u95ED_u952E_u76D8" class="headerlink" title="关闭键盘"></a>关闭键盘</h3><pre><code>public static void hideSoftInput(Activity activity) {
        if (activity.getCurrentFocus() != null)
            ((InputMethodManager) activity
                    .getSystemService(Context.INPUT_METHOD_SERVICE))
                    .hideSoftInputFromWindow(activity.getCurrentFocus()
                            .getWindowToken(), InputMethodManager.HIDE_NOT_ALWAYS);
    }
</code></pre><p>界面不被弹出的键盘盖住<br>一进入activity就弹出键盘</p>
<pre><code>android:windowSoftInputMode=&quot;adjustResize&quot; 
android:windowSoftInputMode=&quot;adjustPan|stateAlwaysVisible&quot;
</code></pre><p>第一个软键盘和输入框会完全分离，而第二个输入框还是会被软键盘盖住一点点<br>而且第二个要把两个属性叠加起来，为什么要叠加起来呢，因为如果只用adjustPan 的话需要点击输入框才会弹出软键盘</p>
<p>在 AndroidMainfest.xml中选择哪个activity，设置windowSoftInputMode属性为</p>
<pre><code>adjustUnspecified|stateHidden
android:windowSoftInputMode=&quot;adjustUnspecified|stateHidden&quot;
</code></pre><h3 id="windowSoftInputMode_u5404_u503C_u7684_u542B_u4E49_uFF1A"><a href="#windowSoftInputMode_u5404_u503C_u7684_u542B_u4E49_uFF1A" class="headerlink" title="windowSoftInputMode各值的含义："></a>windowSoftInputMode各值的含义：</h3><pre><code>stateUnspecified：软键盘的状态并没有指定，系统将选择一个合适的状态或依赖于主题的设置
stateUnchanged：当这个activity出现时，软键盘将一直保持在上一个activity里的状态，无论是隐藏还是显示
stateHidden：用户选择activity时，软键盘总是被隐藏
stateAlwaysHidden：当该Activity主窗口获取焦点时，软键盘也总是被隐藏的
stateVisible：软键盘通常是可见的
stateAlwaysVisible：用户选择activity时，软键盘总是显示的状态
adjustUnspecified：默认设置，通常由系统自行决定是隐藏还是显示
adjustResize：该Activity总是调整屏幕的大小以便留出软键盘的空间
adjustPan：当前窗口的内容将自动移动以便当前焦点从不被键盘覆盖和用户能总是看到输入内容的部分
</code></pre><h3 id="u63A7_u4EF6_u7F8E_u5316Shape"><a href="#u63A7_u4EF6_u7F8E_u5316Shape" class="headerlink" title="控件美化Shape"></a>控件美化Shape</h3><p><a href="http://wuxiaolong.me/2013/07/09/shape/" target="_blank" rel="external">http://wuxiaolong.me/2013/07/09/shape/</a></p>
<h3 id="u83B7_u53D6_u7248_u672C_u540D_u79F0_VersionName"><a href="#u83B7_u53D6_u7248_u672C_u540D_u79F0_VersionName" class="headerlink" title="获取版本名称 VersionName"></a>获取版本名称 VersionName</h3><pre><code>public String getVersionName(Context context) {
        PackageManager manager = context.getPackageManager();
        String packageName = context.getPackageName();
        try {
            PackageInfo info = manager.getPackageInfo(packageName, 0);
            return info.versionName;
        } catch (NameNotFoundException e) {
            return &quot;1.0&quot;;
        }
    }
</code></pre><h3 id="u83B7_u53D6Android_u624B_u673A_u8BBE_u5907_u7684IMSI_/_IMEI__u4FE1_u606F"><a href="#u83B7_u53D6Android_u624B_u673A_u8BBE_u5907_u7684IMSI_/_IMEI__u4FE1_u606F" class="headerlink" title="获取Android手机设备的IMSI / IMEI 信息"></a>获取Android手机设备的IMSI / IMEI 信息</h3><pre><code>TelephonyManager mTelephonyMgr = (TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE);
String imsi = mTelephonyMgr.getSubscriberId(); 
String imei = mTelephonyMgr.getDeviceId(); 
Log.i(&quot;wxl&quot;, &quot;imsi=&quot;+imsi);为null
Log.i(&quot;wxl&quot;, &quot;imei=&quot;+imei); 
</code></pre><p> 另外不要忘了在AndroidManifest.xml中加上读取手机状态的权限</p>
<pre><code>&lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot;/&gt;
</code></pre><h3 id="u81EA_u5B9A_u4E49Log_u662F_u5426_u663E_u793A"><a href="#u81EA_u5B9A_u4E49Log_u662F_u5426_u663E_u793A" class="headerlink" title="自定义Log是否显示"></a>自定义Log是否显示</h3><pre><code>public class Log {
    private static final String TAG = &quot;wxl&quot;;
    private static final boolean LOG = true;
    public static void i(String msg) {
        if (LOG)
            android.util.Log.i(TAG , msg);
    }
    public static void d(String msg) {
        if (LOG)
            android.util.Log.d(TAG , msg);
    }
    public static void w(String msg) {
        if (LOG)
            android.util.Log.w(TAG , msg);
    }
    public static void w(String msg, Throwable throwable) {
        if (LOG)
            android.util.Log.w(TAG , msg, throwable);
    }
    public static void v(String msg) {
        if (LOG)
            android.util.Log.v(TAG , msg);
    }
    public static void e(String msg) {
        android.util.Log.e(TAG , msg);
    }
    public static void e(String msg, Throwable throwable) {
        android.util.Log.e(TAG , msg, throwable);
    }
}
</code></pre><h3 id="u5F02_u6B65_u64CD_u4F5CAsyncTask"><a href="#u5F02_u6B65_u64CD_u4F5CAsyncTask" class="headerlink" title="异步操作AsyncTask"></a>异步操作AsyncTask</h3><pre><code>//参数1：向后台任务的执行方法传递参数的类型 ； 
//参数2：在后台任务执行过程中，要求主UI线程处理中间状态，通常是一些UI处理中传递的参数类型；
//参数3：后台任务执行完返回时的参数类型。
private class MyAsyncTask extends AsyncTask&lt;Integer, String, Void&gt; {

        // 实现抽象方法doInBackground()，代码将在后台线程中执行，由execute()触发
        protected Void doInBackground(Integer... params) {
            return null;
        }

        // 任务启动，可以在这里显示一个对话框，这里简单处理
        protected void onPreExecute() {
            super.onPreExecute();
        }

        // 取消
        protected void onCancelled() {
            super.onCancelled();
        }

        // 定义后台进程执行完后的处理
        protected void onPostExecute(Void result) {
            super.onPostExecute(result);
            Toast.makeText(MainActivity.this, &quot;OK&quot;, Toast.LENGTH_SHORT).show();
        }

        // 更新进度,在UI主线程执行的内容，将item加入list中。方法中的参数为范式方式，实质为数组，由于我们只传递了item一个String，要获取，为values[0]
        protected void onProgressUpdate(String... values) {
            super.onProgressUpdate(values);
        }

    }
</code></pre><p>调用：</p>
<pre><code>new MyAsyncTask().execute(参数1);// 创建后台任务的对象
</code></pre><p>检查网络状态</p>
<pre><code>public boolean checkNetworkInfo() {
        ConnectivityManager conMan = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);
        // mobile 3G Data Network
        State mobile = conMan.getNetworkInfo(ConnectivityManager.TYPE_MOBILE)
                .getState();
        // wifi
        State wifi = conMan.getNetworkInfo(ConnectivityManager.TYPE_WIFI)
                .getState();
        // 如果3G网络和wifi网络都未连接，且不是处于正在连接状态 则进入Network Setting界面 由用户配置网络连接
        if (mobile == State.CONNECTED || mobile == State.CONNECTING)
            return true;
        if (wifi == State.CONNECTED || wifi == State.CONNECTING)
            return true;
        AlertDialog.Builder builder = new AlertDialog.Builder(this);
        builder.setMessage(getResources().getString(R.string.no_network))
                .setCancelable(false)
                .setPositiveButton(
                        getResources().getString(R.string.configuration),
                        new DialogInterface.OnClickListener() {
                            public void onClick(DialogInterface dialog, int id) {

                                // 进入无线网络配置界面
                                startActivity(new Intent(
                                        Settings.ACTION_WIRELESS_SETTINGS));
                                MainActivity.this.finish();
                            }
                        })
                .setNegativeButton(getResources().getString(R.string.quit),
                        new DialogInterface.OnClickListener() {
                            public void onClick(DialogInterface dialog, int id) {
                                MainActivity.this.finish();
                            }
                        });
        builder.show();
        return false;
    }
</code></pre><p>代码判断调用：</p>
<pre><code>// 检查网络状态
if (!checkNetworkInfo()) {
    return;
}
</code></pre><h3 id="u8BA9_u6570_u636E_u63A5_u53D7_u7F51_u9875_u7684_u683C_u5F0F"><a href="#u8BA9_u6570_u636E_u63A5_u53D7_u7F51_u9875_u7684_u683C_u5F0F" class="headerlink" title="让数据接受网页的格式"></a>让数据接受网页的格式</h3><pre><code>Html.fromHtml（）

URLEncoder.encode(String s); 网址请求中文解析
&amp;#8230;代表省略号
URLEncoder.encode
网址请求带中文

URLEncoder.encode(content, &quot;utf-8&quot;)
</code></pre><p>Android中字体加粗<br>在xml文件中使用</p>
<pre><code>android:textStyle=”bold”
</code></pre><p>Java 代码<br>（网上查XML不能将中文设置成粗体，只能通过Java code。Android 2.2 可以通过XML将中文设置成粗体）</p>
<pre><code>TextView tv = (TextView)findViewById(R.id.TextView01); 
TextPaint tp = tv.getPaint();
tp.setFakeBoldText(true);
Html.fromHtml(“\&lt;\b&gt;”)


(1)viewHolder.title.setText(Html.fromHtml(&quot;&lt;b&gt;&quot;+ listTitle.get(position).get(&quot;title&quot;) + &quot;&lt;/b&gt;&quot;));
(2)TextView.setText(Html.fromHtml(&quot;&lt;font color=#FF0000&gt;hello&lt;/font&gt;&quot;));
</code></pre><h3 id="u4EE3_u7801_u8BBE_u7F6E_u80CC_u666F_u56FEsetImageResource/setBackgroundResource"><a href="#u4EE3_u7801_u8BBE_u7F6E_u80CC_u666F_u56FEsetImageResource/setBackgroundResource" class="headerlink" title="代码设置背景图setImageResource/setBackgroundResource"></a>代码设置背景图setImageResource/setBackgroundResource</h3><pre><code>textView.setBackgroundResource(R.drawable.bg_menu_1);设置背景图片
textView.setBackgroundColor(0xffffffff);
setImageResource與xml中的src的屬性才是相匹配的，而setBackgroundResource是與xml中的background屬性相匹配
的
holder.chat_sound_iv_right.setBackgroundResource(0);//没有图片
</code></pre><h3 id="android_u4E2D_u7684ellipsize"><a href="#android_u4E2D_u7684ellipsize" class="headerlink" title="android中的ellipsize"></a>android中的ellipsize</h3><p>用法如下：<br>在xml中</p>
<pre><code>android:ellipsize = &quot;end&quot;　　  省略号在结尾
android:ellipsize = &quot;start&quot; 　　省略号在开头
android:ellipsize = &quot;middle&quot;     省略号在中间
android:ellipsize = &quot;marquee&quot;  跑马灯
</code></pre><p>最好加一个约束android:singleline = “true”<br>跑马灯</p>
<pre><code>android:singleLine=&quot;true&quot;
android:ellipsize=&quot;marquee&quot;
android:focusableInTouchMode=&quot;true&quot;
android:focusable=&quot;true&quot;
android:marqueeRepeatLimit=&quot;marquee_forever&quot;
android:singleLine=true 表示使用单行文字，多行文字也就无所谓使用Marquee效果了。
android:marqueeRepeatLimit，设置走马灯滚动的次数。
android:ellipsize，设置了文字过长时如何切断文字，可以有none, start,middle, end, 如果使用走马灯效果则设为marquee.
android:focusable，Android的缺省行为是在控件获得Focus时才会显示走马灯效果
</code></pre><p>###控件点击效果</p>
<pre><code>&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
    &lt;item android:state_focused=&quot;true&quot; android:state_pressed=&quot;false&quot; android:drawable=&quot;@drawable/professional_1&quot;/&gt;
    &lt;item android:state_focused=&quot;false&quot; android:state_pressed=&quot;true&quot; android:drawable=&quot;@drawable/professional_1&quot;/&gt;
    &lt;item android:drawable=&quot;@drawable/professional&quot;/&gt;
&lt;/selector&gt;
</code></pre><p>###保留小数点<br>方法一：</p>
<pre><code>private DecimalFormat df;
df = new DecimalFormat(&quot;0.0&quot;);
float data;
df.format(data);//返回值
</code></pre><p>方法二：</p>
<pre><code>double juli = 1569;
String result = String.format(&quot;%.1f&quot;, juli/1000);
</code></pre><h3 id="RadioGroup"><a href="#RadioGroup" class="headerlink" title="RadioGroup"></a>RadioGroup</h3><pre><code>&lt;RadioGroup
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:orientation=&quot;vertical&quot; &gt;

    &lt;RadioButton
        android:id=&quot;@+id/open&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_marginLeft=&quot;10dip&quot;
        android:layout_marginTop=&quot;10dip&quot;
        android:button=&quot;@drawable/radiobutton&quot;
        android:checked=&quot;true&quot;
        android:text=&quot;@string/open_album&quot;
        android:textColor=&quot;#000000&quot;
        android:textSize=&quot;16dip&quot; /&gt;

    &lt;RadioButton
        android:id=&quot;@+id/secrecy&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_marginLeft=&quot;10dip&quot;
        android:button=&quot;@drawable/radiobutton&quot;
        android:text=&quot;@string/secrecy_album&quot;
        android:textColor=&quot;#000000&quot;
        android:textSize=&quot;16dip&quot; /&gt;
&lt;/RadioGroup&gt;
</code></pre><p>android:button=”@null” 去除RadioButton前面的圆点<br>android:background=”@drawable/radio” 使用定义的样式</p>
<h3 id="u5360_u4F4D_u7B26_25s_u66FF_u6362"><a href="#u5360_u4F4D_u7B26_25s_u66FF_u6362" class="headerlink" title="占位符%s替换"></a>占位符%s替换</h3><pre><code>%d （表示整数）
%f （表示浮点数）
%s （表示字符串）
</code></pre><p>txt.setText(String.format (“被替换%1$s”,”替换内容”));</p>
<h3 id="TextView_u4E2D_u5D4C_u5957_u56FE_u7247Drawable"><a href="#TextView_u4E2D_u5D4C_u5957_u56FE_u7247Drawable" class="headerlink" title="TextView中嵌套图片Drawable"></a>TextView中嵌套图片Drawable</h3><pre><code>Drawable drawable = getResources().getDrawable(R.drawable.ji_dot_nor);
drawable.setBounds(0, 0, drawable.getIntrinsicWidth(),drawable.getIntrinsicHeight());
textView.setCompoundDrawablesWithIntrinsicBounds(null, drawable, null, null); 
</code></pre><p>说明：<code>setCompoundDrawablesWithIntrinsicBounds(left, top, right, bottom)</code><br>意思是设置Drawable显示在text的左、上、右、下位置。(Textview、Button都可以)</p>
<p>TextView做成分割线</p>
<pre><code>&lt;TextView
    android:id=&quot;@id/textView2&quot;
    android:layout_width=&quot;fill_parent&quot;
    android:layout_height=&quot;2.0px&quot;
android:background=&quot;@color/orange&quot; /&gt;
</code></pre><h3 id="SpannableString_u5355_u51FB_u6587_u5B57_u94FE_u63A5"><a href="#SpannableString_u5355_u51FB_u6587_u5B57_u94FE_u63A5" class="headerlink" title="SpannableString单击文字链接"></a>SpannableString单击文字链接</h3><pre><code>SpannableString spannableString = new SpannableString(str);
        spannableString.setSpan(new ClickableSpan() {
            public void onClick(View view) {
                // Intent intent = new Intent(ApkTest.this, Apk.class);
                Intent intent = new Intent(Intent.ACTION_CALL, Uri.parse(&quot;tel:&quot;
                        + &quot;15261589767&quot;));
                startActivity(intent);
            }
        }, 0, str.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        TextView.setText(spannableString);
        TextView.setMovementMethod(LinkMovementMethod.getInstance());
</code></pre><p>TextView中文字通过SpannableString来设置超链接、颜色、字体等属性</p>
<pre><code>String  title =”123456”;
SpannableString titleStr = new SpannableString(title);
titleStr.setSpan(new ForegroundColorSpan(Color.RED), 0,
                        titleStr.length(), 0);
textView.setText(titleStr);
</code></pre><h3 id="android_3AdrawableTop_u5C5E_u6027"><a href="#android_3AdrawableTop_u5C5E_u6027" class="headerlink" title="android:drawableTop属性"></a>android:drawableTop属性</h3><pre><code>写在TextView里，实现图片+文字
</code></pre><h3 id="u83B7_u53D6_u5206_u8FA8_u7387"><a href="#u83B7_u53D6_u5206_u8FA8_u7387" class="headerlink" title="获取分辨率"></a>获取分辨率</h3><pre><code>DisplayMetrics displayMetrics = new DisplayMetrics();
getWindowManager().getDefaultDisplay().getMetrics(displayMetrics);

displayMetrics.widthPixels + &quot;x&quot;+ displayMetrics.heightPixels;
</code></pre><h3 id="u4EE3_u7801_u5B8C_u6210_u63A7_u4EF6"><a href="#u4EE3_u7801_u5B8C_u6210_u63A7_u4EF6" class="headerlink" title="代码完成控件"></a>代码完成控件</h3><p>Button</p>
<pre><code>linearLayout = (LinearLayout) findViewById(R.id.linearLayout2);
LayoutParams layoutParams = new LinearLayout.LayoutParams(0,
                LinearLayout.LayoutParams.WRAP_CONTENT, 1);//1均分属性
layoutParams.setMargins(10, 10, 10, 10);

Button button = new Button(MainActivity.this);
button.setLayoutParams(layoutParams);
linearLayout.addView(button);
</code></pre><p>TextView</p>
<pre><code>private TextView overlay;
private void initOverlay() {
        LayoutInflater inflater = LayoutInflater.from(this);
        overlay = (TextView) inflater.inflate(R.layout.overlay, null);
        overlay.setVisibility(View.INVISIBLE);
        WindowManager.LayoutParams lp = new WindowManager.LayoutParams(
                LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT,
                WindowManager.LayoutParams.TYPE_APPLICATION,
                WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE
                        | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE,
                PixelFormat.TRANSLUCENT);
        WindowManager windowManager = (WindowManager) this
                .getSystemService(Context.WINDOW_SERVICE);
        windowManager.addView(overlay, lp);
    }
</code></pre><p> xml：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;TextView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:background=&quot;#ffffff&quot;
    android:gravity=&quot;center&quot;
    android:maxWidth=&quot;80dip&quot;
    android:minWidth=&quot;80dip&quot;
    android:padding=&quot;5dip&quot;
    android:textColor=&quot;#3399ff&quot;
    android:textSize=&quot;70sp&quot; /&gt;
</code></pre><p>代码：</p>
<pre><code>private LinearLayout.LayoutParams layoutParams = null;
        private LinearLayout.LayoutParams btnParmas;

layoutParams = new LinearLayout.LayoutParams(
                            LinearLayout.LayoutParams.WRAP_CONTENT,
                            LinearLayout.LayoutParams.WRAP_CONTENT);
                    layoutParams.setMargins(
                            (int) getResources().getDimension(
                                    R.dimen.lable_left), 0, 0, 0);
                    btnParmas = new LinearLayout.LayoutParams(
                            LinearLayout.LayoutParams.WRAP_CONTENT,
                            (int) getResources().getDimension(
                                    R.dimen.lable_height));

                    for (int i = 0; i &lt; lables.length; i++) {
                        LinearLayout linearLayout = new LinearLayout(activity);
                        lableColor = random.nextInt(lableColors.length);
                        Button lable = new Button(activity);
                        lable.setText(lables[i]);
                        lable.setGravity(Gravity.CENTER_HORIZONTAL
                                | Gravity.CENTER_VERTICAL);
                        lable.setTextSize(getResources().getDimension(
                                R.dimen.lable));
                        lable.setTextColor(getResources().getColor(
                                R.color.white));
                        lable.setBackgroundResource(lableColors[i]);
                        linearLayout.addView(lable, btnParmas);
                        holder.play_lables.addView(linearLayout, layoutParams);
                    }
</code></pre><h3 id="TextWatcher"><a href="#TextWatcher" class="headerlink" title="TextWatcher"></a>TextWatcher</h3><pre><code>editText1.addTextChangedListener(watcher);
TextWatcher watcher = new TextWatcher() {
        public void onTextChanged(CharSequence arg0, int arg1, int arg2,
                int arg3) {
        }
        public void beforeTextChanged(CharSequence arg0, int arg1, int arg2,
                int arg3) {
        }
        public void afterTextChanged(Editable arg0) {            
        }
    };
</code></pre><h3 id="u5C4F_u5E55_u65CB_u8F6C_u65F6_u4E0D_u9500_u6BC1"><a href="#u5C4F_u5E55_u65CB_u8F6C_u65F6_u4E0D_u9500_u6BC1" class="headerlink" title="屏幕旋转时不销毁"></a>屏幕旋转时不销毁</h3><p>AndroidManifest加入</p>
<pre><code>android:configChanges=&quot;orientation|keyboardHidden&quot;
</code></pre><p>###获取屏幕方向</p>
<pre><code>Configuration newConfig = getResources().getConfiguration();    
        if (newConfig.orientation == Configuration.ORIENTATION_LANDSCAPE){    
            //横屏    
        }else if(newConfig.orientation == Configuration.ORIENTATION_PORTRAIT){    
            //竖屏    
        }else if(newConfig.hardKeyboardHidden == Configuration.KEYBOARDHIDDEN_NO){    
            //键盘没关闭。屏幕方向为横屏    
        }else if(newConfig.hardKeyboardHidden == Configuration.KEYBOARDHIDDEN_YES){    
            //键盘关闭。屏幕方向为竖屏    
        }
</code></pre><h3 id="List_u589E_u52A0_u6570_u636E"><a href="#List_u589E_u52A0_u6570_u636E" class="headerlink" title="List增加数据"></a>List增加数据</h3><p>简单</p>
<pre><code>private List&lt;String&gt; getData() {
        List&lt;String&gt; data = new ArrayList&lt;String&gt;();
        data.add(&quot;123&quot;);
        data.add(&quot;345&quot;);
        data.add(&quot;456&quot;);
        data.add(&quot;567&quot;);
        return data;
    }
</code></pre><p>键值对</p>
<pre><code>private List&lt;Map&lt;String, Object&gt;&gt; getData() {
        List&lt;Map&lt;String, Object&gt;&gt; list = new ArrayList&lt;Map&lt;String, Object&gt;&gt;();

        Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();
        map.put(&quot;title&quot;, &quot;G1&quot;);
        map.put(&quot;info&quot;, &quot;google 1&quot;);
        map.put(&quot;img&quot;, R.drawable.i1);
        list.add(map);

        map = new HashMap&lt;String, Object&gt;();
        map.put(&quot;title&quot;, &quot;G2&quot;);
        map.put(&quot;info&quot;, &quot;google 2&quot;);
        map.put(&quot;img&quot;, R.drawable.i2);
        list.add(map);

        map = new HashMap&lt;String, Object&gt;();
        map.put(&quot;title&quot;, &quot;G3&quot;);
        map.put(&quot;info&quot;, &quot;google 3&quot;);
        map.put(&quot;img&quot;, R.drawable.i3);
        list.add(map);

        return list;
    }
</code></pre><p>清除数据：</p>
<pre><code>data.clear();
listView.setAdapter(new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_expandable_list_item_1,getData()));
</code></pre><p>LinkedList</p>
<pre><code>LinkedList&lt;String&gt; list = new LinkedList&lt;String&gt;();
list.addFirst(&quot;000&quot;);
</code></pre><h3 id="u9A8C_u8BC1_u662F_u5426_u624B_u673A_u53F7_u7801"><a href="#u9A8C_u8BC1_u662F_u5426_u624B_u673A_u53F7_u7801" class="headerlink" title="验证是否手机号码"></a>验证是否手机号码</h3><pre><code>public boolean isMobileNO(String mobiles) {
        String expression = &quot;((^(13|15|18)[0-9]{9}$)|(^0[1,2]{1}\\d{1}-?\\d{8}$)|(^0[3-9] {1}\\d{2}-?\\d{7,8}$)|(^0[1,2]{1}\\d{1}-?\\d{8}-(\\d{1,4})$)|(^0[3-9]{1}\\d{2}-? \\d{7,8}-(\\d{1,4})$))&quot;;
        Pattern pattern = Pattern.compile(expression);
        Matcher matcher = pattern.matcher(mobiles);
        Log.d(&quot;wxl&quot;, matcher.matches() + &quot;&quot;);
        return matcher.matches();
    }
</code></pre><p>正则表达式数字验证</p>
<pre><code>public boolean isNumber(String str)
    {
        java.util.regex.Pattern pattern=java.util.regex.Pattern.compile(&quot;[0-9]*&quot;);
        java.util.regex.Matcher match=pattern.matcher(str);
        if(match.matches()==false)
        {
            return false;
        }
        else
        {
            return true;
        }
    }
</code></pre><h3 id="SharedPreferences"><a href="#SharedPreferences" class="headerlink" title="SharedPreferences"></a>SharedPreferences</h3><p>SharedPreferences存数据</p>
<pre><code>SharedPreferences sharedPreferences = getSharedPreferences(&quot;test&quot;, Context.MODE_PRIVATE);
Editor editor = sharedPreferences.edit();//获取编辑器
editor.putString(&quot;name&quot;, &quot;张三&quot;);
editor.putInt(&quot;age&quot;, 24);
editor.putBoolean(&quot;AutoLogin&quot;, false);
editor.commit();//提交修改
</code></pre><p>SharedPreferences取数据</p>
<pre><code>SharedPreferences sharedPreferences = getSharedPreferences(&quot;test&quot;, Context.MODE_PRIVATE);
//getString()第二个参数为缺省值,如果preference中不存在该key,将返回缺省值
String name = sharedPreferences.getString(&quot;name&quot;, &quot;&quot;);
int age = sharedPreferences.getInt(&quot;age&quot;, 1);
boolean autoLogin= sharedPreferences. getBoolean(&quot;AutoLogin&quot;, false);
</code></pre><h3 id="Intent__u4F20_u503C"><a href="#Intent__u4F20_u503C" class="headerlink" title="Intent 传值"></a>Intent 传值</h3><p>简单传值<br>ActivityPage</p>
<pre><code>Intent intent = new Intent(ActivityPage.this, Player.class);
            //保存信息
            Bundle mBundle = new Bundle();
            mBundle.putString(&quot;realname &quot;, realname);
            intent.putExtras(mBundle);
</code></pre><p>Player接受</p>
<pre><code>realname = this.getIntent().getStringExtra(&quot;realname&quot;);
Intent intent = new Intent();
intent.setClass(HomeActivity.this, CompanyActivity.class);
intent.putExtra(&quot;mCompanySupply&quot;, mCompanySupply);
                startActivity(intent);
CompanyActivity.class:
ArrayList&lt;ClassifySub3Bean&gt;  mCompanySupply = (ArrayList&lt;ClassifySub3Bean&gt;) getIntent()
                .getSerializableExtra(&quot;mCompanySupply&quot;);
</code></pre><p>复杂传值<br>A页面：</p>
<pre><code>private static final int REQUEST_CODE_A = 0;
private static final int RESULT_CODE_B = 0;
Intent intent = new Intent();
                Bundle bundle = new Bundle();
                intent.setClass(MainActivity.this, TestBActivity.class);
                bundle.putString(&quot;msg&quot;, textView.getText().toString());
                intent.putExtras(bundle);
                startActivityForResult(intent, REQUEST_CODE_A);

protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        if (requestCode == REQUEST_CODE_A &amp;&amp; resultCode == RESULT_OK) {
            String str=data.getExtras().getString(&quot;result&quot;);
        }
    }
</code></pre><p>B页面</p>
<pre><code>private static final int RESULT_CODE_B = 0;

Intent intent = new Intent();
                intent.putExtra(&quot;result&quot;, textView.getText().toString());
                setResult(RESULT_OK, intent);
                finish();

public boolean onKeyDown(int keyCode, KeyEvent event) {
        if (keyCode == KeyEvent.KEYCODE_BACK) {
            Intent intent = new Intent();
            intent.putExtra(&quot;result&quot;, &quot;直接返回&quot;);
            setResult(RESULT_OK, intent);
            this.finish();
            return true;
        } else {
            return super.onKeyDown(keyCode, event);
        }
    }
</code></pre><p>List</p>
<pre><code>Intent intent = new Intent();
                    intent.putStringArrayListExtra(&quot;mSelectedPhotos&quot;,
                            mSelectedPhotos);
                    setResult(RESULT_OK, intent);


                    ArrayList&lt;String&gt; mSelectedPhotos = (ArrayList&lt;String&gt;) intent
                        .getStringArrayListExtra(&quot;mSelectedPhotos&quot;);
</code></pre><h3 id="xml_u6587_u4EF6_u4E2D_u5BFC_u5165_u53E6_u4E00_u4E2Axml_u6587_u4EF6_u7684_u65B9_u6CD5include"><a href="#xml_u6587_u4EF6_u4E2D_u5BFC_u5165_u53E6_u4E00_u4E2Axml_u6587_u4EF6_u7684_u65B9_u6CD5include" class="headerlink" title="xml文件中导入另一个xml文件的方法include"></a>xml文件中导入另一个xml文件的方法include</h3><pre><code>&lt;include 
android:id=&quot;@+id/included1&quot;
layout=&quot;@layout/anotherlayout&quot; /&gt;
</code></pre><h3 id="u5355_u51FB_u8FD4_u56DE_u952E_u4E24_u6B21_u9000_u51FA"><a href="#u5355_u51FB_u8FD4_u56DE_u952E_u4E24_u6B21_u9000_u51FA" class="headerlink" title="单击返回键两次退出"></a>单击返回键两次退出</h3><pre><code>private static Boolean isExit = false;
        @Override
        public boolean onKeyDown(int keyCode, KeyEvent event) {
                if (keyCode == KeyEvent.KEYCODE_BACK) {
                        if (isExit == false) {
                                isExit = true;
                                Toast.makeText(this, &quot;再按一次退出程序&quot;, Toast.LENGTH_SHORT).show();
                                new Timer().schedule(new TimerTask() {
                                        @Override
                                        public void run() {
                                                isExit = false;
                                        }
                                }, 2000);
                        } else {
                                finish();
                                System.exit(0);
                        }
                }
                return false;
        }
</code></pre><p>或者</p>
<pre><code>@Override 
public boolean onKeyUp(int keyCode, KeyEvent event) { 
    if (keyCode == KeyEvent.KEYCODE_BACK) { 
        long secondTime = System.currentTimeMillis(); 
        if (secondTime - firstTime &gt; 800) {//如果两次按键时间间隔大于800毫秒，则不退出 
            Toast.makeText(MainActivity.this, &quot;再按一次退出程序...&quot;, 
                    Toast.LENGTH_SHORT).show(); 
            firstTime = secondTime;//更新firstTime 
            return true; 
        } else { 
            System.exit(0);//否则退出程序 
        } 
    } 
    return super.onKeyUp(keyCode, event); 
}
</code></pre><h3 id="u56FE_u7247_u5DE6_u53F3_u5FAA_u73AF_u79FB_u52A8"><a href="#u56FE_u7247_u5DE6_u53F3_u5FAA_u73AF_u79FB_u52A8" class="headerlink" title="图片左右循环移动"></a>图片左右循环移动</h3><pre><code>TranslateAnimation left, right;
right = new TranslateAnimation(Animation.RELATIVE_TO_PARENT, -1f,
                Animation.RELATIVE_TO_PARENT, -2f,
                Animation.RELATIVE_TO_PARENT, 0f, Animation.RELATIVE_TO_PARENT,
                0f);
        left = new TranslateAnimation(Animation.RELATIVE_TO_PARENT, -2f,
                Animation.RELATIVE_TO_PARENT, -1f,
                Animation.RELATIVE_TO_PARENT, 0f, Animation.RELATIVE_TO_PARENT,
                0f);
        right.setDuration(25000);
        left.setDuration(25000);
        right.setFillAfter(true);
        left.setFillAfter(true);

        right.setAnimationListener(new Animation.AnimationListener() {
            @Override
            public void onAnimationStart(Animation animation) {
            }

            @Override
            public void onAnimationRepeat(Animation animation) {
            }

            @Override
            public void onAnimationEnd(Animation animation) {
                runImage.startAnimation(left);
            }
        });
        left.setAnimationListener(new Animation.AnimationListener() {
            @Override
            public void onAnimationStart(Animation animation) {
            }

            @Override
            public void onAnimationRepeat(Animation animation) {
            }

            @Override
            public void onAnimationEnd(Animation animation) {
                runImage.startAnimation(right);
            }
        });
        runImage.startAnimation(right);
</code></pre><h3 id="u63A7_u4EF6_u5DE6_u53F3_u6296_u52A8"><a href="#u63A7_u4EF6_u5DE6_u53F3_u6296_u52A8" class="headerlink" title="控件左右抖动"></a>控件左右抖动</h3><p>res下anim<br>animlayout.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;translate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:duration=&quot;1000&quot;
    android:fromXDelta=&quot;0&quot;
    android:interpolator=&quot;@anim/cycle_7&quot;
    android:toXDelta=&quot;10&quot; /&gt;
</code></pre><p>cycle_7.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;cycleInterpolator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
android:cycles=&quot;7&quot; /&gt;
</code></pre><p>(2)java代码</p>
<p>Animation shake = AnimationUtils.loadAnimation(<br>                        MainActivity.this, R.anim.animlayout);<br>                btn.setAnimation(shake);</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这份是我工作以来，总结的小知识库，有些知识点现在看来太LOW了，把还觉得有用的分享出来！</p>
<h3 id="Genymotion_u4E0B_u8F7D_u865A_u62DF_u955C_u50CFConnection_timeout"><a href="#Genymotion_u4E0B_u8F7D_u865A_u62DF_u955C_u50CFConnection_timeout" class="headerlink" title="Genymotion下载虚拟镜像Connection timeout"></a>Genymotion下载虚拟镜像Connection timeout</h3><p>Add new device出现的问题：</p>
<p>Failed to deploy virtual device.<br>Unable to create virtual device.Connection timeout occurred.</p>
<p>解决方案：</p>
<p>当选择Google Nexus 5 - 6.0.0 - API 23 - 1080x1920下载device失败后，到C:\Users\用户主目录\AppData\Local\Genymobile\Genymotion\ova下看到genymotion_vbox86p_6.0_160114_090449.ova，大小却是0KB，在C:\Users\用户主目录\AppData\Local\Genymobile\genymotion.log，打开该文件，找到类似“<a href="http://files2.genymotion.com/dists/6.0.0/ova/genymotion_vbox86p_6.0_160114_090449.ova”路径，即您想要下载的镜像文件URL；">http://files2.genymotion.com/dists/6.0.0/ova/genymotion_vbox86p_6.0_160114_090449.ova”路径，即您想要下载的镜像文件URL；</a><br>用迅雷去下载，下载完成后放到C:\Users\用户主目录\AppData\Local\Genymobile\Genymotion\ova；<br>重新点击Google Nexus 5 - 6.0.0 - API 23 - 1080x1920去下载，验证安装后即会显示在设备列表中。<br>]]>
    
    </summary>
    
      <category term="知识库" scheme="http://yoursite.com/tags/%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Webview上传文件的那些坑]]></title>
    <link href="http://yoursite.com/2016/02/22/Webview%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9D%91/"/>
    <id>http://yoursite.com/2016/02/22/Webview上传文件的那些坑/</id>
    <published>2016-02-22T13:01:14.000Z</published>
    <updated>2016-02-22T05:35:13.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>要说Android中最厉害的组件莫过于Webview 了，夸张点说把这个组件放在屏幕上就可以算作一个简单地浏览器应用了。但你若认为这就万事大吉了，可太小看Webview这个磨人的妖精了，下面单就上传文件的这个坑来做展开。</p>
</blockquote>
<a id="more"></a>
<h3 id="u652F_u6301_u4E0A_u4F20_u6587_u4EF6"><a href="#u652F_u6301_u4E0A_u4F20_u6587_u4EF6" class="headerlink" title="支持上传文件"></a>支持上传文件</h3><p>Webview执行上传操作的逻辑是这样的：首先准备上传时会回调WebChromeClient类下的<code>openFileChooser</code>方法，在这个方法中给我们机会发起Intent来打开支持提供文件的第三方应用，最后在<code>onActivityResult</code>回调中将第三方应用提供的内容通过一个叫做<code>ValueCallback</code>的参数返回给<code>Webview</code>（详细点来说：ValueCallback是在openFileChooser 方法里由webview提供给我们的，里面包裹一个Uri，我们在<code>onActivityResult</code> 里将选中的Uri反馈给<code>ValueCallback</code>，这时候相当于Webview就知道我们选择了什么文件），因此，我们需要为<code>Webview</code>设置一个提供<code>openFileChooser</code>方法的<code>WebChromeClient</code>，这个方法在不同版本的<code>Android</code>中参数是不同的，为此我们一般需要写三个重载函数，大致像这个样子：</p>
<pre><code>private ValueCallback&lt;Uri&gt; mUploadMessage;
    //设置`WebChromeClient`:
webview.setWebChromeClient(new WebChromeClient(){
     public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg) {
            Log.d(TAG, &quot;openFileChoose(ValueCallback&lt;Uri&gt; uploadMsg)&quot;);
            mUploadMessage = uploadMsg;
            Intent i = new Intent(Intent.ACTION_GET_CONTENT);
            i.addCategory(Intent.CATEGORY_OPENABLE);
            i.setType(&quot;*/*&quot;);
            MainActivity.this.startActivityForResult(Intent.createChooser(i, &quot;File Chooser&quot;), FILECHOOSER_RESULTCODE);
      }
      public void openFileChooser( ValueCallback uploadMsg, String acceptType ) {
            Log.d(TAG, &quot;openFileChoose( ValueCallback uploadMsg, String acceptType )&quot;);
            mUploadMessage = uploadMsg;
            Intent i = new Intent(Intent.ACTION_GET_CONTENT);
            i.addCategory(Intent.CATEGORY_OPENABLE);
            i.setType(&quot;*/*&quot;);
            MainActivity.this.startActivityForResult(
                    Intent.createChooser(i, &quot;File Browser&quot;),
                    FILECHOOSER_RESULTCODE);
      }
      public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg, String acceptType, String capture){
            Log.d(TAG, &quot;openFileChoose(ValueCallback&lt;Uri&gt; uploadMsg, String acceptType, String capture)&quot;);
            mUploadMessage = uploadMsg;
            Intent i = new Intent(Intent.ACTION_GET_CONTENT);
            i.addCategory(Intent.CATEGORY_OPENABLE);
            i.setType(&quot;*/*&quot;);
            MainActivity.this.startActivityForResult( Intent.createChooser( i, &quot;File Browser&quot; ), MainActivity.FILECHOOSER_RESULTCODE );
        }
});

//onActivityResult回调   
@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        if(requestCode==FILECHOOSER_RESULTCODE)
         {
                if (null == mUploadMessage &amp;&amp; null == mUploadCallbackAboveL) return;
                 Uri result = data == null || resultCode != RESULT_OK ? null : data.getData();
                 if (mUploadMessage != null) {
                    mUploadMessage.onReceiveValue(result);
                    mUploadMessage = null;
               }
          }
       }
</code></pre><p>还有重要的一点：如果这个上传操作涉及到JS操作，别忘记对Webview开启对JS的支持：</p>
<pre><code>WebSettings settings = webview.getSettings();
settings.setJavaScriptEnabled(true);
</code></pre><h3 id="u4EE3_u7801_u6DF7_u6DC6"><a href="#u4EE3_u7801_u6DF7_u6DC6" class="headerlink" title="代码混淆"></a>代码混淆</h3><pre><code>-keepclassmembers class * extends android.webkit.WebChromeClient{
    public void openFileChooser(...);
}
</code></pre><h3 id="u517C_u5BB95-0"><a href="#u517C_u5BB95-0" class="headerlink" title="兼容5.0"></a>兼容5.0</h3><pre><code>webview.setWebChromeClient(new WebChromeClient(){
public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg) {
     ...
}
public void openFileChooser( ValueCallback uploadMsg, String acceptType ) {
       ...
}
public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg, String acceptType, String capture){
                ...
}

// For Android 5.0+
public boolean onShowFileChooser (WebView webView, ValueCallback&lt;Uri[]&gt; filePathCallback, WebChromeClient.FileChooserParams fileChooserParams) {
         mUploadCallbackAboveL = filePathCallback;
         Intent i = new Intent(Intent.ACTION_GET_CONTENT);
         i.addCategory(Intent.CATEGORY_OPENABLE);
         i.setType(&quot;*/*&quot;);
         MainActivity.this.startActivityForResult(
                    Intent.createChooser(i, &quot;File Browser&quot;),
                    FILECHOOSER_RESULTCODE);
         return true;
        }
});

@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {
    super.onActivityResult(requestCode, resultCode, data);
    if(requestCode==FILECHOOSER_RESULTCODE)
    {
        if (null == mUploadMessage &amp;&amp; null == mUploadCallbackAboveL) return;
        Uri result = data == null || resultCode != RESULT_OK ? null : data.getData();
        if (mUploadCallbackAboveL != null) {
            onActivityResultAboveL(requestCode, resultCode, data);
        }
        else  if (mUploadMessage != null) {
            mUploadMessage.onReceiveValue(result);
            mUploadMessage = null;
        }
    }
}
@TargetApi(Build.VERSION_CODES.LOLLIPOP)
private void onActivityResultAboveL(int requestCode, int resultCode, Intent data) {
    if (requestCode != FILECHOOSER_RESULTCODE
            || mUploadCallbackAboveL == null) {
        return;
    }
    Uri[] results = null;
    if (resultCode == Activity.RESULT_OK) {
        if (data == null) {
        } else {
            String dataString = data.getDataString();
            ClipData clipData = data.getClipData();
            if (clipData != null) {
                results = new Uri[clipData.getItemCount()];
                for (int i = 0; i &lt; clipData.getItemCount(); i++) {
                    ClipData.Item item = clipData.getItemAt(i);
                    results[i] = item.getUri();
                }
            }
            if (dataString != null)
                results = new Uri[]{Uri.parse(dataString)};
        }
    }
    mUploadCallbackAboveL.onReceiveValue(results);
    mUploadCallbackAboveL = null;
    return;
}
</code></pre><blockquote>
<p>代码转自: <a href="http://blog.saymagic.cn/2015/11/08/webview-upload.html" target="_blank" rel="external">http://blog.saymagic.cn/2015/11/08/webview-upload.html</a></p>
<p>源码地址: <a href="https://gitcafe.com/saymagic/Webviewdemo" target="_blank" rel="external">https://gitcafe.com/saymagic/Webviewdemo</a></p>
</blockquote>
<pre><code>* 说明:实际上我使用了该段代码只能够 完成5.0+的支持,对于5.0以下的机器支持的并不完美,比如说上传完成之后,并不能显示图片到目标位置.
</code></pre><ul>
<li>没办法继续爬文 终于发现了</li>
</ul>
<pre><code>package com.fuiou.webviewupload;
import java.io.File;
import android.app.Activity;
import android.app.AlertDialog;
import android.content.ContentValues;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.database.Cursor;
import android.graphics.Bitmap;
import android.net.Uri;
import android.os.Bundle;
import android.os.Environment;
import android.provider.MediaStore;
import android.util.Log;
import android.view.KeyEvent;
import android.webkit.ValueCallback;
import android.webkit.WebChromeClient;
import android.webkit.WebView;
import android.webkit.WebViewClient;
import android.widget.Toast;

public class MainActivity extends Activity {
    public static final String TAG = &quot;MainActivity&quot;;
    ValueCallback&lt;Uri&gt; mUploadMessage;
    private WebView mWebView;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        initView();
    }

    private void initView() {
        mWebView = (WebView) findViewById(R.id.web_view);
        mWebView.setWebChromeClient(new MyWebChromeClient());

        mWebView.setWebViewClient(new MyWebViewClient(this));
//        webView.loadUrl(&quot;file:///android_asset/upload_image.html&quot;);
        mWebView.loadUrl(&quot;http://192.168.72.62:8080/fileUpload&quot;);
    }


    private class MyWebViewClient extends WebViewClient{
        private Context mContext;
        public MyWebViewClient(Context context){
            super();
            mContext = context;
        }

        @Override
        public void onPageStarted(WebView view, String url, Bitmap favicon) {
            Log.d(TAG,&quot;URL地址:&quot; + url);
            super.onPageStarted(view, url, favicon);
        }

        @Override
        public void onPageFinished(WebView view, String url) {
            Log.i(TAG, &quot;onPageFinished&quot;);
            super.onPageFinished(view, url);
        }
    }

    public static final int FILECHOOSER_RESULTCODE = 1;
    private static final int REQ_CAMERA = FILECHOOSER_RESULTCODE+1;
    private static final int REQ_CHOOSE = REQ_CAMERA+1;

    private class MyWebChromeClient extends WebChromeClient {

        // For Android 3.0+
           public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg, String acceptType) {  
               if (mUploadMessage != null) return;
               mUploadMessage = uploadMsg;   
               selectImage();
//               Intent i = new Intent(Intent.ACTION_GET_CONTENT);
//               i.addCategory(Intent.CATEGORY_OPENABLE);
//               i.setType(&quot;*/*&quot;);
//                   startActivityForResult( Intent.createChooser( i, &quot;File Chooser&quot; ), FILECHOOSER_RESULTCODE );
           }
            // For Android &lt; 3.0
            public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg) {
                   openFileChooser( uploadMsg, &quot;&quot; );
            }
            // For Android  &gt; 4.1.1
          public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg, String acceptType, String capture) {
                  openFileChooser(uploadMsg, acceptType);
          }

    }

    /**
     * 检查SD卡是否存在
     *
     * @return
     */
    public final boolean checkSDcard() {
        boolean flag = Environment.getExternalStorageState().equals(
                Environment.MEDIA_MOUNTED);
        if (!flag) {
            Toast.makeText(this, &quot;请插入手机存储卡再使用本功能&quot;,Toast.LENGTH_SHORT).show();
        }
        return flag;
    }
    String compressPath = &quot;&quot;;

    protected final void selectImage() {
        if (!checkSDcard())
            return;
        String[] selectPicTypeStr = { &quot;camera&quot;,&quot;photo&quot; };
        new AlertDialog.Builder(this)
                .setItems(selectPicTypeStr,
                        new DialogInterface.OnClickListener() {
                            @Override
                            public void onClick(DialogInterface dialog,
                                    int which) {
                                switch (which) {
                                // 相机拍摄
                                case 0:
                                    openCarcme();
                                    break;
                                // 手机相册
                                case 1:
                                    chosePic();
                                    break;
                                default:
                                    break;
                                }
                                compressPath = Environment
                                        .getExternalStorageDirectory()
                                        .getPath()
                                        + &quot;/fuiou_wmp/temp&quot;;
                                new File(compressPath).mkdirs();
                                compressPath = compressPath + File.separator
                                        + &quot;compress.jpg&quot;;
                            }
                        }).show();
    }

    String imagePaths;
    Uri  cameraUri;
    /**
     * 打开照相机
     */
    private void openCarcme() {
        Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);

        imagePaths = Environment.getExternalStorageDirectory().getPath()
                + &quot;/fuiou_wmp/temp/&quot;
                + (System.currentTimeMillis() + &quot;.jpg&quot;);
        // 必须确保文件夹路径存在，否则拍照后无法完成回调
        File vFile = new File(imagePaths);
        if (!vFile.exists()) {
            File vDirPath = vFile.getParentFile();
            vDirPath.mkdirs();
        } else {
            if (vFile.exists()) {
                vFile.delete();
            }
        }
        cameraUri = Uri.fromFile(vFile);
        intent.putExtra(MediaStore.EXTRA_OUTPUT, cameraUri);
        startActivityForResult(intent, REQ_CAMERA);
    }

    /**
     * 拍照结束后
     */
    private void afterOpenCamera() {
        File f = new File(imagePaths);
        addImageGallery(f);
        File newFile = FileUtils.compressFile(f.getPath(), compressPath);
    }

    /** 解决拍照后在相册中找不到的问题 */
    private void addImageGallery(File file) {
        ContentValues values = new ContentValues();
        values.put(MediaStore.Images.Media.DATA, file.getAbsolutePath());
        values.put(MediaStore.Images.Media.MIME_TYPE, &quot;image/jpeg&quot;);
        getContentResolver().insert(
                MediaStore.Images.Media.EXTERNAL_CONTENT_URI, values);
    }

    /**
     * 本地相册选择图片
     */
    private void chosePic() {
        FileUtils.delFile(compressPath);
        Intent innerIntent = new Intent(Intent.ACTION_GET_CONTENT); // &quot;android.intent.action.GET_CONTENT&quot;
        String IMAGE_UNSPECIFIED = &quot;image/*&quot;;
        innerIntent.setType(IMAGE_UNSPECIFIED); // 查看类型
        Intent wrapperIntent = Intent.createChooser(innerIntent, null);
        startActivityForResult(wrapperIntent, REQ_CHOOSE);
    }

    /**
     * 选择照片后结束
     *
     * @param data
     */
    private Uri afterChosePic(Intent data) {

        // 获取图片的路径：
        String[] proj = { MediaStore.Images.Media.DATA };
        // 好像是android多媒体数据库的封装接口，具体的看Android文档
        Cursor cursor = managedQuery(data.getData(), proj, null, null, null);
        if(cursor == null ){
            Toast.makeText(this, &quot;上传的图片仅支持png或jpg格式&quot;,Toast.LENGTH_SHORT).show();
            return null;
        }
        // 按我个人理解 这个是获得用户选择的图片的索引值
        int column_index = cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DATA);
        // 将光标移至开头 ，这个很重要，不小心很容易引起越界
        cursor.moveToFirst();
        // 最后根据索引值获取图片路径
        String path = cursor.getString(column_index);
        if(path != null &amp;&amp; (path.endsWith(&quot;.png&quot;)||path.endsWith(&quot;.PNG&quot;)||path.endsWith(&quot;.jpg&quot;)||path.endsWith(&quot;.JPG&quot;))){
            File newFile = FileUtils.compressFile(path, compressPath);
            return Uri.fromFile(newFile);
        }else{
            Toast.makeText(this, &quot;上传的图片仅支持png或jpg格式&quot;,Toast.LENGTH_SHORT).show();
        }
        return null;
    }



    /**
     * 返回文件选择
     */
    @Override
    protected void onActivityResult(int requestCode, int resultCode,
            Intent intent) {
    //        if (requestCode == FILECHOOSER_RESULTCODE) {
    //            if (null == mUploadMessage)
    //                return;
    //            Uri result = intent == null || resultCode != RESULT_OK ? null
    //                    : intent.getData();
    //            mUploadMessage.onReceiveValue(result);
    //            mUploadMessage = null;
    //        }

        if (null == mUploadMessage)
            return;
        Uri uri = null;
        if(requestCode == REQ_CAMERA ){
            afterOpenCamera();
            uri = cameraUri;
        }else if(requestCode == REQ_CHOOSE){
            uri = afterChosePic(intent);
        }
        mUploadMessage.onReceiveValue(uri);
        mUploadMessage = null;
        super.onActivityResult(requestCode, resultCode, intent);
    }

    public boolean onKeyDown(int keyCode, KeyEvent event) {
        if ((keyCode == KeyEvent.KEYCODE_BACK) &amp;&amp; mWebView.canGoBack()) {  
            mWebView.goBack();  
            return true;  
        }else{
                finish();
        }
        return super.onKeyDown(keyCode, event);  
        }
}
</code></pre><p>根据这个哥们的代码进行精简,符合自己的需求,而且发现了这个代码的一个问题,没有能够进行判空操作,如果没有选择图片,直接返回APP会奔溃!</p>
<p>下面是我的开发源码:</p>
<pre><code>private class MyWebChromeClient extends WebChromeClient {


        // For Android 5.0+
        public boolean onShowFileChooser(WebView webView, ValueCallback&lt;Uri[]&gt; filePathCallback, WebChromeClient.FileChooserParams fileChooserParams) {
            mUploadCallbackAboveL = filePathCallback;
//            Intent i = new Intent(Intent.ACTION_GET_CONTENT);
//            i.addCategory(Intent.CATEGORY_OPENABLE);
//            i.setType(&quot;*/*&quot;);
//            HomePageViewActivity.this.startActivityForResult(
//                    Intent.createChooser(i, &quot;File Browser&quot;),
//                    FILECHOOSER_RESULTCODE);
            selectImage();
            return true;
        }


        //For Android 3.0+
        public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg, String acceptType) {
            if (mUploadMessage != null) return;
            mUploadMessage = uploadMsg;
            selectImage();
        }

        // For Android &lt; 3.0
        public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg) {
            if (mUploadMessage != null) return;
            mUploadMessage = uploadMsg;
            selectImage();
        }

        // For Android  &gt; 4.1.1
        public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg, String acceptType, String capture) {
            if (mUploadMessage != null) return;
            mUploadMessage = uploadMsg;
            selectImage();
        }


    }


    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        if (requestCode == FILECHOOSER_RESULTCODE) {
            if (null == mUploadMessage &amp;&amp; null == mUploadCallbackAboveL) return;
            Uri result = data == null || resultCode != RESULT_OK ? null : data.getData();
            if (mUploadCallbackAboveL != null) {
                onActivityResultAboveL(requestCode, resultCode, data);
            } else if (mUploadMessage != null) {
                mUploadMessage.onReceiveValue(result);
                mUploadMessage = null;
            }
        }


        if (null == mUploadMessage)
            return;
        Uri uri = null;
        if (requestCode == REQ_CHOOSE) {
            uri = afterChosePic(data);
        }
        mUploadMessage.onReceiveValue(uri);
        mUploadMessage = null;
        super.onActivityResult(requestCode, resultCode, data);
    }


    @TargetApi(Build.VERSION_CODES.LOLLIPOP)
    private void onActivityResultAboveL(int requestCode, int resultCode, Intent data) {
        if (requestCode != FILECHOOSER_RESULTCODE
                || mUploadCallbackAboveL == null) {
            return;
        }

        Uri[] results = null;
        if (resultCode == Activity.RESULT_OK) {
            if (data == null) {

            } else {
                String dataString = data.getDataString();
                ClipData clipData = data.getClipData();

                if (clipData != null) {
                    results = new Uri[clipData.getItemCount()];
                    for (int i = 0; i &lt; clipData.getItemCount(); i++) {
                        ClipData.Item item = clipData.getItemAt(i);
                        results[i] = item.getUri();
                    }
                }

                if (dataString != null)
                    results = new Uri[]{Uri.parse(dataString)};
            }
        }
        mUploadCallbackAboveL.onReceiveValue(results);
        mUploadCallbackAboveL = null;
        return;
    }


    /**
     * 检查SD卡是否存在
     *
     * @return
     */
    public final boolean checkSDcard() {
        boolean flag = Environment.getExternalStorageState().equals(
                Environment.MEDIA_MOUNTED);
        if (!flag) {
            Toast.makeText(this, &quot;请插入手机存储卡再使用本功能&quot;, Toast.LENGTH_SHORT).show();
        }
        return flag;
    }

    String compressPath = &quot;&quot;;

    protected final void selectImage() {
        if (!checkSDcard())
            return;

        chosePic();
        compressPath = Environment
                .getExternalStorageDirectory()
                .getPath()
                + &quot;/fuiou_wmp/temp&quot;;
        new File(compressPath).mkdirs();
        compressPath = compressPath + File.separator
                + &quot;compress.jpg&quot;;
    }


    /**
     * 本地相册选择图片
     */
    private void chosePic() {
        FileUtils.delFile(compressPath);
        Intent innerIntent = new Intent(Intent.ACTION_GET_CONTENT); // &quot;android.intent.action.GET_CONTENT&quot;
        String IMAGE_UNSPECIFIED = &quot;image/*&quot;;
        innerIntent.setType(IMAGE_UNSPECIFIED); // 查看类型
        Intent wrapperIntent = Intent.createChooser(innerIntent, null);
        startActivityForResult(wrapperIntent, REQ_CHOOSE);
    }

    /**
     * 选择照片后结束
     *
     * @param data
     */
    private Uri afterChosePic(Intent data) {

        if (data != null) {
            // 获取图片的路径：
            String[] proj = {MediaStore.Images.Media.DATA};
            // 好像是android多媒体数据库的封装接口，具体的看Android文档
            Cursor cursor = managedQuery(data.getData(), proj, null, null, null);
//        if (cursor == null) {
//            Toast.makeText(this, &quot;上传的图片仅支持png或jpg格式&quot;, Toast.LENGTH_SHORT).show();
//            return null;
//        }
            // 按我个人理解 这个是获得用户选择的图片的索引值
            int column_index = cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DATA);
            // 将光标移至开头 ，这个很重要，不小心很容易引起越界
            cursor.moveToFirst();
            // 最后根据索引值获取图片路径
            String path = cursor.getString(column_index);
//            if (path != null &amp;&amp; (path.endsWith(&quot;.png&quot;) || path.endsWith(&quot;.PNG&quot;) || path.endsWith(&quot;.jpg&quot;) || path.endsWith(&quot;.JPG&quot;))) {
//            } else {
//                Toast.makeText(this, &quot;上传的图片仅支持png或jpg格式&quot;, Toast.LENGTH_SHORT).show();
//            }
            File newFile = FileUtils.compressFile(path, compressPath);
            return Uri.fromFile(newFile);
        }
        return null;
    }
</code></pre><p>都目前位置 问题得到完美的解决!!</p>
<p>参考:<a href="http://blog.isming.me/2015/12/21/android-webview-upload-file/" target="_blank" rel="external">http://blog.isming.me/2015/12/21/android-webview-upload-file/</a><br><a href="http://www.huochai.mobi/p/d/900504/?share_tid=846ea82e2685&amp;fmid=0" target="_blank" rel="external">http://www.huochai.mobi/p/d/900504/?share_tid=846ea82e2685&amp;fmid=0</a><br><a href="http://www.lai18.com/content/1191983.html" target="_blank" rel="external">http://www.lai18.com/content/1191983.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>要说Android中最厉害的组件莫过于Webview 了，夸张点说把这个组件放在屏幕上就可以算作一个简单地浏览器应用了。但你若认为这就万事大吉了，可太小看Webview这个磨人的妖精了，下面单就上传文件的这个坑来做展开。</p>
</blockquote>]]>
    
    </summary>
    
      <category term="Webview" scheme="http://yoursite.com/tags/Webview/"/>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android源码编译和内核编译]]></title>
    <link href="http://yoursite.com/2016/02/21/Android%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/"/>
    <id>http://yoursite.com/2016/02/21/Android源码编译/</id>
    <published>2016-02-21T06:33:45.000Z</published>
    <updated>2016-02-26T07:27:49.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u6E90_u7801_u7F16_u8BD1"><a href="#u6E90_u7801_u7F16_u8BD1" class="headerlink" title="源码编译"></a>源码编译</h2><h4 id="1_u3001_u7CFB_u7EDF_uFF1A_Ubuntu14-04_u4EE5_u4E0A__u6216_u8005_Mac"><a href="#1_u3001_u7CFB_u7EDF_uFF1A_Ubuntu14-04_u4EE5_u4E0A__u6216_u8005_Mac" class="headerlink" title="1、系统： Ubuntu14.04以上 或者 Mac"></a>1、系统： Ubuntu14.04以上 或者 Mac</h4><blockquote>
<p>下面的介绍都是在ubuntu下进行的</p>
</blockquote>
<h4 id="2_u3001JdK_u5B89_u88C5"><a href="#2_u3001JdK_u5B89_u88C5" class="headerlink" title="2、JdK安装"></a>2、JdK安装</h4><pre><code>$ sudo add-apt-repository &quot;deb http://archive.canonical.com/ lucid partner&quot;
$ sudo apt-get update
$ sudo apt-get install sun-java8-jdk
</code></pre><a id="more"></a> 
<h4 id="3_u3001_u5FC5_u5907_u8F6F_u4EF6_u5305_u5B89_u88C5"><a href="#3_u3001_u5FC5_u5907_u8F6F_u4EF6_u5305_u5B89_u88C5" class="headerlink" title="3、必备软件包安装"></a>3、必备软件包安装</h4><pre><code>$ sudo apt-get install git-core gnupg flex bison gperf build-essential \
  zip curl zlib1g-dev libc6-dev lib32ncurses5-dev ia32-libs \
  x11proto-core-dev libx11-dev lib32readline5-dev lib32z-dev \
  libgl1-mesa-dev g++-multilib mingw32 tofrodos python-markdown \
  libxml2-utils
</code></pre><h4 id="uFF14__u4E0B_u8F7Drepo_u5DE5_u5177"><a href="#uFF14__u4E0B_u8F7Drepo_u5DE5_u5177" class="headerlink" title="４　下载repo工具"></a>４　下载repo工具</h4><pre><code>$ cd ~
$ mkdir ~/bin
$ PATH=~/bin:$PATH
$ curl https://dl-ssl.google.com/dl/googlesource/git-repo/repo &gt; ~/bin/repo
$ chmod a+x ~/bin/repo
</code></pre><h4 id="uFF15__u4E0B_u8F7D_u6E90_u7801"><a href="#uFF15__u4E0B_u8F7D_u6E90_u7801" class="headerlink" title="５　下载源码"></a>５　下载源码</h4><blockquote>
<p>注意，下面最后一条命令，-b 后面的 Gingerbread 可以替换成 IceCreamSandwich 或者是 Froyo 中的任何一个。当然，还有其它选择，这个名字，就是 Android 版本的英文名，<a href="http://source.android.com/source/build-numbers.html" target="_blank" rel="external">http://source.android.com/source/build-numbers.html</a> 里面有所有的名字</p>
</blockquote>
<pre><code>$ mkdir CMROM
$ cd CMROM
$ repo init -u git://github.com/CyanogenMod/android.git
</code></pre><blockquote>
<p>如果是使用Google官方的源码编译</p>
</blockquote>
<pre><code>$ repo init -u https://android.googlesource.com/platform/manifest -b [Gingerbread]

[?]部分是Android的版本名称--详见http://source.android.com/source/build-numbers.html
</code></pre><ul>
<li>注意事项</li>
</ul>
<blockquote>
<p>默认情况下，访问Android源码是匿名的，为了防止下载服务器压力过大，下载服务器对每个ip都有下载限制。如果和别人共享一个公网IP(和别人共享路由器时，便是如此),Android源码服务器便会阻止多人同时下载，容易报错。为了解决该问题，需要使用带授权的访问，源码服务器此时对用户进行限制，而不是对ip进行限制。方法如下：<br>先创建密码：<a href="https://android.googlesource.com/new-password" target="_blank" rel="external">https://android.googlesource.com/new-password</a><br>该地址也经常无法访问，需多次尝试(可相隔几分钟)，若使用代理，就没法获得有用的密钥<br>再将密码保存在~/.netrc里<br>然后强制使用带授权的访问：<br> $repo init -u <a href="https://android.googlesource.com/a/platform/manifest" target="_blank" rel="external">https://android.googlesource.com/a/platform/manifest</a><br>在国内用repo初始化时，会经常遇到101的错误，因为有墙的原因，重试多次，运气好时便可以完成，设置代理的话会更顺利一点</p>
</blockquote>
<ul>
<li><p>源代码的目录结构</p>
<p>  在讲述Android源码编译的三个步骤之前，将先介绍Android源码目录结构，以便读者理清Android编译系统核心代码在Android源代码的位置。<br>Android源代码顶层目录结构如下所示：</p>
<p>../CyanogenMod/</p>
<pre><code>├──abi#应用二进制接口，不同的操作系统，应用二进制接口不同，因此linux上的二进制可执行文件在windows上无法执行
├──android#存放了一些xml文件，用于描述工程路径及其对应的远程仓库地址，repo工具将使用这些信息同步代码
├──bionic#bionic C库,Android没有使用标准的glibc库，而是自己重新实现了一套c/C++库，包括libc libdl libm libstdc++ libthread_db
├──bootable# 包含两个工程，recovery和diskinstaller，刷机或者系统升级都是由recovery完成的，
├──build#Android编译系统核心代码都存放在该目录，我们也将对该目录下的文件做详细分析
├──cts#Android兼容性测试套件标准
├──dalvik#dalvik JAVA虚拟机，Android用的java虚拟机和pc上用的jvm不一样
├──development#应用程序开发工具 有eclipse开发用的formatter配置
├──device#设备相关配置文件，存放规则 device/$vendor/$product
├──docs#网站文档
├──external#用到的第三方库 象busybox bash openssl等工具都存放在该目录
├──filelist#使用godir命令生成的索引文件
├──frameworks#核心框架——java及C++语言，可生成framework.jar
├──gdk#glass开发Sdk
├──hardware#部分厂家开源的硬件适配层HAL代码
├──kernel#内核源码目录 存放规则kernel/$vendor/$product
├──libcore#一些有用的库 像xml Jason luni
├──libnativehelper#Support functions for Android’s class libraries
├──Makefile#在顶层目录编译，利用的默认Makefile，它只是简单包含了build/core/main.mk
├──ndk#ndk开发工具
├──packages#Android apk程序所在目录,象settings，gallery等程序
├──pdk#Platform Development Kit The goal of the PDK release is to help chipset vendors and OEMs to migrate to a new relelase
├──prebuilt#x86和arm架构下预编译的一些资源
├──prebuilts#有clang eclipse gcc misc ndk qemu-kernel sdk tools等子目录，交叉编译工具链所在目录
├──sdk#sdk及模拟器
├──system#核心代码，包含了最小化可启动的环境，还有底层调试及检查工具，adbd也在system/core目录
├──tools#有子目录build和motodev，可能跟摩托罗拉有关
├──vendor#设备制造商专用的配置存放目录，存放规则vendor/$vendor/$product，cm编写的apk也放在该目录
</code></pre><p>build子目录存放编译系统的核心代码，包含着138个makefile，15个shell脚本，19个python脚本，7个C文件，7个C++文件，16个头文件，因此如果想分析编译系统核心代码，使用的IDE需支持这些编程语言，推荐使用eclipse，安装一些插件就可以很方便地查看这些代码<br>build子文件夹的目录结构如下所示：<br>build/</p>
<pre><code>├── buildspec.mk.default#buildspec的模版文件，可定义一些变量比如TARGET_BUILD_VARIANT:=user，TARGET_BUILD_TYPE:=release
├── CleanSpec.mk#增量编译时，会执行该文件里的命令，这些命令一般用于清除中间文件
├── core#编译系统的核心文件放在该目录，主要是一些makefile
├── envsetup.sh#编译时需先用source envsetup.sh设置好环境变量，该脚本提供了许多有用的命令，比如cout,croot,cgrep,在详细介绍Android编译步骤时会列出来
├── libs#是一个C++模块，编译后可生成libhost.a静态库，里面的函数主要用于与编译主机交互
├── target#包含编译目标相关的makefile，它有两个子文件夹 board和product，产品都在该目录下定义，比如generic,full产品，定义设备产品时，会从这里继承产品
└── tools#各种工具，多数使用python编写，工具有用于签名的signpak, 用于下载device配置的roomservice.py等，后续将详细介绍
</code></pre><p>我们在阅读build核心代码时，可能最头疼的就是变量，编译系统里有成百上千的变量，我们常常不知道其含义，容易一头雾水，为此我做了一个编译系统的参考手册供大家查阅， 可以很方便地检索变量，查看变量的意义，并有示例值。链接：<a href="http://android.cloudchou.com/" target="_blank" rel="external">http://android.cloudchou.com/</a></p>
</li>
</ul>
<h4 id="uFF16__u540C_u6B65_u6E90_u7801"><a href="#uFF16__u540C_u6B65_u6E90_u7801" class="headerlink" title="６　同步源码"></a>６　同步源码</h4><blockquote>
<p>别看只有一条命令，但是，下载的时间，很长的，推荐这条命令，晚上的时候，挂机执行，第二天早上，差不多能下载完。毕竟是 3GB 多的东西呢。</p>
</blockquote>
<pre><code>$ repo sync -j 10
</code></pre><ul>
<li>注意事项<blockquote>
<p>在工作目录里使用repo sync同步代码，期间可能会多次卡死，需要ctrl+z，然后杀掉进程，然后再次使用repo sync，因为其支持断点续传，不需要担心会从头开始下载 还可以开启多个进程同时下载，使用repo sync -j4<br>j4代表开启4个线程,建议i5以上的开4,i7开8</p>
</blockquote>
</li>
</ul>
<h4 id="4-_u7F16_u8BD1_u6E90_u4EE3_u7801"><a href="#4-_u7F16_u8BD1_u6E90_u4EE3_u7801" class="headerlink" title="4.编译源代码"></a>4.编译源代码</h4><ul>
<li><p>初始化编译环境</p>
<pre><code>$source build/envsetup.sh
</code></pre></li>
</ul>
<ul>
<li><p>选择一个目标设备，以cm下编译htc one为例</p>
<pre><code>$lunch cm_m7ul-eng
</code></pre></li>
<li><p>此时会从网站下载m7ul的device配置以及内核源代码<br>所有目标设备的格式为BUILD-BUILDTYPE， BUILD是选择的目标设备，比如cm_m7,而BUILD_TYPE是eng，user或者userdebug</p>
<pre><code>user: 适合发布产品时使用，访问受限
userdebug: 和user类型类似，有root权限和调试能力，适合调试
eng: 开发配置，有额外的调试工具
</code></pre></li>
<li><p>编译源代码：</p>
<pre><code>$mka
</code></pre></li>
</ul>
<h2 id="u5185_u6838_u7F16_u8BD1"><a href="#u5185_u6838_u7F16_u8BD1" class="headerlink" title="内核编译"></a>内核编译</h2><h4 id="uFF11__u4E0B_u8F7D_u5185_u6838_u6E90_u7801"><a href="#uFF11__u4E0B_u8F7D_u5185_u6838_u6E90_u7801" class="headerlink" title="１　下载内核源码"></a>１　下载内核源码</h4><p>　　每一个 Android 手机厂商，都会在自己的网站上公布已经生产的手机的内核源码，大家去小米手机的官方网站下载即可。</p>
<h4 id="uFF12__u89E3_u538B_u5185_u6838_u6E90_u7801_u5305"><a href="#uFF12__u89E3_u538B_u5185_u6838_u6E90_u7801_u5305" class="headerlink" title="２　解压内核源码包"></a>２　解压内核源码包</h4><p>　　内核源码，一般是以压缩包的形式提供下载的。大家下载之后，在 Ubuntu 中解压即可，因为命令非常简单，这里不提供。</p>
<h4 id="uFF13__u914D_u7F6E_u4EA4_u53C9_u5DE5_u5177_u94FE_uFF08_u7F16_u8BD1_u5668_uFF09_u8DEF_u5F84"><a href="#uFF13__u914D_u7F6E_u4EA4_u53C9_u5DE5_u5177_u94FE_uFF08_u7F16_u8BD1_u5668_uFF09_u8DEF_u5F84" class="headerlink" title="３　配置交叉工具链（编译器）路径"></a>３　配置交叉工具链（编译器）路径</h4><p>　　学过编程的人都知道，源码要编译成程序，必须要用编译器编译。而且手机的 CPU 不同于 PC 机，所以，得用专用的工具，即“交叉工具链”。<br>　　打开内核源码目录下的 Makefile 文件，找到“CROSS_COMPILE”定义的地方，确保和下面一模一样。</p>
<pre><code>CROSS_COMPILE := $(shell if [ -f .cross_compile ]; then \
    cat .cross_compile; \
    fi)
</code></pre><p>　　接着，在内核源码目录下面，新建一个叫“.cross_compile”的文件，在文件中，输入以下分隔线中间的一行内容</p>
<pre><code>/（这前面，是 Android 源码的绝对路径，要求您有一点 Ubuntu 使用经验，否则不能完成）/ANDROID_SRC/prebuilt/linux-x86/toolchain/arm-eabi-4.4.0/bin/arm-eabi-
</code></pre><p>　　打开已经下载的 Android 源码（前面有提到如何下载）目录，在 ANDROID_SRC/prebuilt/linux-x86/toolchain 下面，你会发现有几个工具链文件夹，名字为别是 arm-eabi-4.2.1（4.3.1，4.4.0，4.4.3），如果，你是用 64位 系统，用哪个都可以。如果是 32位 系统，貌似用 4.4.3 会出错。建议用 4.4.0。<br>　注：ANDROID_SRC 是指您电脑上，Android 源码存储的目录，请根据实际情况，进行替换。</p>
<h4 id="uFF14__u201C-config_u201D_u914D_u7F6E_u6587_u4EF6"><a href="#uFF14__u201C-config_u201D_u914D_u7F6E_u6587_u4EF6" class="headerlink" title="４　“.config”配置文件"></a>４　“.config”配置文件</h4><p>　　在内核源码的目录下面，一定要有一个名字为“.config”的文件，这个文件，是小米手机的内核配置。如果内核源码的根目录下，没有发现这个文件，或者，发现的文件不是针对小米手机配置的，在 LINUX_SRC/arch/arm/configs 下面，找到针对小米手机的配置文件，复制到内核源码根目录，即可。<br>　注：LINUX_SRC 是指您电脑上，内核源码存储的目录，请根据实际情况，进行替换。</p>
<h4 id="uFF15__u9009_u62E9_u5185_u6838_u914D_u7F6E_u9009_u9879"><a href="#uFF15__u9009_u62E9_u5185_u6838_u914D_u7F6E_u9009_u9879" class="headerlink" title="５　选择内核配置选项"></a>５　选择内核配置选项</h4><pre><code>$ cd LINUX_SRC
$ make config
</code></pre><p>这里的config文件,是在内核源码根目录下的 config文件,如果没有直接名称为config文件的,看看是否有前缀,例如:menuconfig<br>　　输入上面的命令后，会出现一个怪怪的列表，通过按“空格键”，进行“选择”或“取消”某些选项。完成后，记得保存。<br>　注：在手机使用中，有的用户总抱怨不能使用“Wifi Tether”，不能“使用笔记本共享出来的宽带上网”，都是因为这一步，内核的选项没有被正确设置。读完这篇文章之后，大家可以自己动手了。</p>
<h4 id="uFF16__u201C_u6700_u540E_u4E00_u6B65_u201D"><a href="#uFF16__u201C_u6700_u540E_u4E00_u6B65_u201D" class="headerlink" title="６　“最后一步”"></a>６　“最后一步”</h4><pre><code>$ cd LINUX_SRC
$ make
</code></pre><p>　编译完成之后，会在“kernel/goldfish/arch/arm/boot/”目录下生成名为zImage的文件。 </p>
<h2 id="u7528_u5230_u7684_u547D_u4EE4"><a href="#u7528_u5230_u7684_u547D_u4EE4" class="headerlink" title="用到的命令"></a>用到的命令</h2><h4 id="u4E0B_u8F7DAndroid_u6E90_u7801_u7B80_u8981_u6D41_u7A0B"><a href="#u4E0B_u8F7DAndroid_u6E90_u7801_u7B80_u8981_u6D41_u7A0B" class="headerlink" title="下载Android源码简要流程"></a>下载Android源码简要流程</h4><pre><code>a. 获取repo文件: curl http://commondatastorage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo .注意执行该文件需要python2.5以上版本,如果是2.4.3的python版本就无法执行这个文件脚本;
b. 修改repo权限 : chmod a+x ~/bin/repo , 如果repo没有执行权限, 该脚本也无法执行;
c. 初始化repo文件 : repo init -u https://android.googlesource.com/platform/manifest -b android-2.3.3_r1 , 这里要下载2.3.3版本的源码;
d. 开始下载 :repo sync , 执行该命令就可以开始下载Android源码;
</code></pre><h4 id="u4E0B_u8F7DAndroid_u5185_u6838_u6E90_u7801_u7B80_u8981_u6D41_u7A0B"><a href="#u4E0B_u8F7DAndroid_u5185_u6838_u6E90_u7801_u7B80_u8981_u6D41_u7A0B" class="headerlink" title="下载Android内核源码简要流程"></a>下载Android内核源码简要流程</h4><pre><code>a. 使用git下载 : git clone https://android.googlesource.com/kernel/goldfish.git ;
b. 查看分支 : git branch -a ;
c. 检出版本 : git checkout remotes/origin/android-goldfish-2.6.29 ;
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u6E90_u7801_u7F16_u8BD1"><a href="#u6E90_u7801_u7F16_u8BD1" class="headerlink" title="源码编译"></a>源码编译</h2><h4 id="1_u3001_u7CFB_u7EDF_uFF1A_Ubuntu14-04_u4EE5_u4E0A__u6216_u8005_Mac"><a href="#1_u3001_u7CFB_u7EDF_uFF1A_Ubuntu14-04_u4EE5_u4E0A__u6216_u8005_Mac" class="headerlink" title="1、系统： Ubuntu14.04以上 或者 Mac"></a>1、系统： Ubuntu14.04以上 或者 Mac</h4><blockquote>
<p>下面的介绍都是在ubuntu下进行的</p>
</blockquote>
<h4 id="2_u3001JdK_u5B89_u88C5"><a href="#2_u3001JdK_u5B89_u88C5" class="headerlink" title="2、JdK安装"></a>2、JdK安装</h4><pre><code>$ sudo add-apt-repository &quot;deb http://archive.canonical.com/ lucid partner&quot;
$ sudo apt-get update
$ sudo apt-get install sun-java8-jdk
</code></pre>]]>
    
    </summary>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Kotlin 1.0 正式版发布啦]]></title>
    <link href="http://yoursite.com/2016/02/18/Kotlin1.0%E6%AD%A3%E5%BC%8F%E7%89%88%E5%8F%91%E5%B8%83/"/>
    <id>http://yoursite.com/2016/02/18/Kotlin1.0正式版发布/</id>
    <published>2016-02-18T15:01:14.000Z</published>
    <updated>2016-02-19T09:12:40.000Z</updated>
    <content type="html"><![CDATA[<p><code>就在昨天，Android领域的Swift--Kotlin 1.0发布了，详细的新版本发布介绍请「阅读原文」查看官方发行说明。</code></p>
<h3 id="u4F55_u4E3AKotlin_uFF1F"><a href="#u4F55_u4E3AKotlin_uFF1F" class="headerlink" title="何为Kotlin？"></a>何为Kotlin？</h3><p><code>Kotlin 是一门实用的编程语言，可用于 JVM 和 Android 程序开发，Kotlin 结合了面向对象和函数式特性，致力于互操作性，安全，简洁和工具支持。</code><br><a id="more"></a><br><code>Kotlin 是一门通用的语言，只要能用 Java 的地方就能用 Kotlin，包含：服务器程序开发，移动应用开发（Android），桌面客户端程序开发。 Kotlin 支持所有主要的开发工具以及服务，比如：</code></p>
<pre><code>IntelliJ IDEA，Android Studio 和 Eclipse
Maven, Gradle 和Ant
Spring Boot（Kotlin 支持今天正式发布！）
GitHub，Slack，甚至 Minecraft
</code></pre><p><code>Kotlin 的主要特点之一是Java+Kotlin 混合工程的互操作性以及无缝兼容，使引入Kotlin的过程简单容易，并达成更少的重复性代码(boilerplate code)和更佳的类型安全(type-safety)。</code><br><code>Kotlin 还有一个扩展标准库(extensive standard library)能让日常工作变得简单顺畅，它能帮助保持低内存占用 (bytecode footprint)。当然，Kotlin 中自然可以使用 Java 库，反之亦然。</code></p>
<h3 id="u4E3A_u4F55_u8BF4Kotlin_u975E_u5E38_u9002_u5408_u4E8EAndroid_uFF1F"><a href="#u4E3A_u4F55_u8BF4Kotlin_u975E_u5E38_u9002_u5408_u4E8EAndroid_uFF1F" class="headerlink" title="为何说Kotlin非常适合于Android？"></a>为何说Kotlin非常适合于Android？</h3><p><code>基本上，这是因为Kotlin的所有特性都非常适合于Android生态圈。Kotlin的库非常小，我们在开发过程中不会引入额外的成本。其大小 相当于support-v4库，我们在很多项目中所使用的库都比Kotlin大。除此之外，Android Studio（官方的Android IDE）是基于IntelliJ构建的。这意味着我们的IDE对该语言提供了非常棒的支持。我们可以很快就配置好项目，并且使用熟悉的IDE进行开发。我 们可以继续使用Gradle以及IDE所提供的各种运行与调试特性。这与使用Java开发应用别无二致。归功于互操作性，我们可以在Kotlin代码中使 用Android SDK而不会遇到任何问题。实际上，部分SDK使用起来会变得更加简单，这是因为互操作性是非常智能的，比如说它可以将getters与setters映 射到Kotlin属性上，我们也可以以闭包的形式编写监听器。</code></p>
<h3 id="u5982_u4F55_u5728Android_u5F00_u53D1_u4E2D_u4F7F_u7528Kotlin_uFF1F"><a href="#u5982_u4F55_u5728Android_u5F00_u53D1_u4E2D_u4F7F_u7528Kotlin_uFF1F" class="headerlink" title="如何在Android开发中使用Kotlin？"></a>如何在Android开发中使用Kotlin？</h3><p><code>过程非常简单，只需按照下面的步骤来即可：</code></p>
<blockquote>
<p>从IDE plugins中下载Kotlin插件<br>在模块中创建Kotlin类<br>使用“Configure Kotlin in Project…”<br>开始编码</p>
</blockquote>
<h3 id="Kotlin_u7684_u4E00_u4E9B_u7279_u6027"><a href="#Kotlin_u7684_u4E00_u4E9B_u7279_u6027" class="headerlink" title="Kotlin的一些特性"></a>Kotlin的一些特性</h3><p><code>Kotlin拥有大量非常打动人心的特性，这里无法一一进行介绍，不过我们来看一下其中最为重要的一些。</code></p>
<h4 id="Null_u5B89_u5168"><a href="#Null_u5B89_u5168" class="headerlink" title="Null安全"></a>Null安全</h4><p><code>如前所述，Kotlin是null安全的。如果一个类型可能为null，那么我们就需要在类型后面加上一个?。这样，每次在使用该类型的变量时，我们都需要进行null检查。比如说，如下代码将无法编译通过：</code></p>
<pre><code>var artist: Artist? = null?
artist.print()
</code></pre><p><code>第2行会显示一个错误，因为没有对变量进行null检查。我们可以这样做：</code></p>
<pre><code>if (artist != null) {
?    artist.print()?
}
</code></pre><p><code>这展示了Kotlin另一个出色的特性：智能类型转换。如果检查了变量的类型，那就无需在检查作用域中对其进行类型转换。这样，我们现在就可以在 if中将artist作为Artist类型的变量了。这对于其他检查也是适用的。还有一种更简单的方式来检查null，即在调用对象的函数前使用?。甚至 还可以通过Elvis运算符?提供另外一种做法：</code></p>
<pre><code>val name = artist?.name ?: &quot;&quot;
</code></pre><h4 id="u6570_u636E_u7C7B"><a href="#u6570_u636E_u7C7B" class="headerlink" title="数据类"></a>数据类</h4><p><code>在Java中，如果想要创建数据类或是POJO类（只保存了一些状态的类），我们需要创建一个拥有大量字段、getters与setters的类，也许还要提供toString与equals方法：</code></p>
<pre><code>public class Artist {
    private long id;
    private String name;
    private String url;
    private String mbid;

    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getUrl() {
        return url;
    }

    public void setUrl(String url) {
        this.url = url;
    }

    public String getMbid() {
        return mbid;
    }

    public void setMbid(String mbid) {
        this.mbid = mbid;
    }

    @Override
    public String toString() {
        return &quot;Artist{&quot; +
                &quot;id=&quot; + id +
                &quot;, name=&apos;&quot; + name + &apos;\&apos;&apos; +
                &quot;, url=&apos;&quot; + url + &apos;\&apos;&apos; +
                &quot;, mbid=&apos;&quot; + mbid + &apos;\&apos;&apos; +
                &apos;}&apos;;
    }
}
</code></pre><p><code>在Kotlin中，上述代码可以写成下面这样：</code></p>
<pre><code>data class Artist (?
    var id: Long,
    var name: String,
    var url: String,
    var mbid: String)
</code></pre><p><code>Kotlin使用属性而非字段。基本上，属性就是字段加上其getter与setter。</code></p>
<h4 id="u4E92_u64CD_u4F5C"><a href="#u4E92_u64CD_u4F5C" class="headerlink" title="互操作"></a>互操作</h4><p><code>Kotlin提供了一些非常棒的互操作特性，这对于Android开发帮助非常大。其中之一就是拥有单个方法的接口与lambda表达式之间的映射。这样，下面这个单击监听器：</code></p>
<pre><code>view.setOnClickListener(object : View.OnClickListener {
    override fun onClick(v: View) {
        toast(&quot;Click&quot;)?
    }
?})
</code></pre><p><code>可以写成这样：</code></p>
<pre><code>view.setOnClickListener { toast(&quot;Click&quot;) }
</code></pre><p><code>此外，getters与setters都会自动映射到属性上。这并不会造成性能上的损失，因为字节码实际上只是调用原来的getters与setters。如下代码所示：</code></p>
<pre><code>supportActionBar.title = title
textView.text = title
contactsList.adapter = ContactsAdapter()
</code></pre><p>####Lambda表达式</p>
<p><code>Lambda表达式会在极大程度上精简代码，不过重要的是借助于Lambda表达式，我们可以做到之前无法实现或是实现起来非常麻烦的事情。借助于 Lambda表达式，我们可以以一种更加函数式的方式来思考问题。Lambda表达式其实就是一种指定类型，并且该类型定义了一个函数的方式。比如说，我 们可以像下面这样定义一个变量：</code></p>
<pre><code>val listener: (View) -&gt; Boolean
</code></pre><p><code>该变量可以声明一个函数，它接收一个view并返回这个函数。我们需要通过闭包的方式来定义函数的行为：</code></p>
<pre><code>val listener = { view: View -&gt; view is TextView }
</code></pre><p><code>上面这个函数会接收一个View，如果该view是TextView的实例，那么它就会返回true。由于编译器可以推断出类型，因此我们无需指定。还可以更加明确一些：</code></p>
<pre><code>val listener: (View) -&gt; Boolean = { view -&gt; view is TextView }
</code></pre><p><code>借助于Lambda表达式，我们可以抛弃回调接口的使用。只需设置希望后面会被调用的函数即可：</code></p>
<pre><code>fun asyncOperation(value: Int, callback: (Boolean) -&gt; Unit) {
    ...
    callback(true)?
}

asyncOperation(5) { result -&gt; println(&quot;result: $result&quot;) }
</code></pre><p><code>还有一种更加简洁的方式，如果函数只接收一个参数，那就可以使用保留字it：</code></p>
<pre><code>asyncOperation(5) { println(&quot;result: $it&quot;) }
</code></pre><h4 id="Anko"><a href="#Anko" class="headerlink" title="Anko"></a>Anko</h4><p><code>Anko是Kotlin团队开发的一个库，旨在简化Android开发。其主要目标在于提供一个DSL，使用Kotlin代码来声明视图：</code></p>
<pre><code>verticalLayout {
    val name = editText()
    button(&quot;Say Hello&quot;) {
        onClick { toast(&quot;Hello, ${name.text}!&quot;) }
    }
}
</code></pre><p><code>它还提供了其他一些很有用的特性。比如说，导航到其他Activity：</code></p>
<pre><code>startActivity(&quot;id&quot; to res.id, &quot;name&quot; to res.name)
</code></pre><h3 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h3><p><code>如你所见，Kotlin在很多方面都简化了Android的开发工作。它会提升你的生产力，并且可以通过非常不同且更加简单的方式来解决一些常见的问题，你开始学习了么？</code></p>
<h3 id="u53C2_u8003_u8D44_u6599_uFF1A"><a href="#u53C2_u8003_u8D44_u6599_uFF1A" class="headerlink" title="参考资料："></a>参考资料：</h3><pre><code>1. http://www.infoq.com/cn/news/2016/01/kotlin-android?utm_campaign=infoq_content&amp;utm_source=infoq&amp;utm_medium=feed&amp;utm_term=global

2. http://www.oschina.net/news/70734/kotlin-1-0-final
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><code>就在昨天，Android领域的Swift--Kotlin 1.0发布了，详细的新版本发布介绍请「阅读原文」查看官方发行说明。</code></p>
<h3 id="u4F55_u4E3AKotlin_uFF1F"><a href="#u4F55_u4E3AKotlin_uFF1F" class="headerlink" title="何为Kotlin？"></a>何为Kotlin？</h3><p><code>Kotlin 是一门实用的编程语言，可用于 JVM 和 Android 程序开发，Kotlin 结合了面向对象和函数式特性，致力于互操作性，安全，简洁和工具支持。</code><br>]]>
    
    </summary>
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Ibeacon]]></title>
    <link href="http://yoursite.com/2016/01/25/Ibeacon/"/>
    <id>http://yoursite.com/2016/01/25/Ibeacon/</id>
    <published>2016-01-25T04:01:14.000Z</published>
    <updated>2016-02-19T09:12:16.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u662F_u4EC0_u4E48_uFF1F"><a href="#u662F_u4EC0_u4E48_uFF1F" class="headerlink" title="是什么？"></a>是什么？</h3><p>iBeacon是apple公司提出的“一种可以让附近手持电子设备检测到的一种新的低功耗、低成本信号传送器”的一套可用于室内定位系统的协议。 这种技术可以使一个智能手机或其他装置在一个iBeacon基站的感应范围内执行相应的命令。</p>
<p>这是帮助智能手机确定他们大概位置或环境的一个应用程序。在一个iBeacon基站的帮助下，智能手机的软件能大概找到它和这个iBeacon基站的相对位置。iBeacon能让手机收到附近售卖商品的通知，也可以让消费者不用拿出钱包或信用卡就能在销售点的POS机上完成支付。iBeacon技术通过低功耗蓝牙（BLE），也就是我们所说的智能蓝牙来实现。</p>
<p>iBeacon为利用低功耗蓝牙可以近距离感测的功能来传输通用唯一识别码的一个app或操作系统。 这个识别码可以在网上被查找到用以确定设备的物理位置或者可以在设备上触发一个动作比如在社交媒体签到或者推送通知。</p>
<p>各种供应商创造了不同形式的iBeacon硬件设备，包括小硬币电池设备，随身碟和蓝牙4.0通用加密狗。<br><a id="more"></a></p>
<h3 id="u529F_u80FD"><a href="#u529F_u80FD" class="headerlink" title="功能"></a>功能</h3><p>一套iBeacon的部署由一个或多个在一定范围内发射传输他们唯一的识别码iBeacon信标设备组成。接收设备上的软件可以查找iBeacon并实现多种功能，比如通知用户，接收设备也可以通过链接iBeacons从iBeacon的通用属性配置服务来恢复价值。iBeacons不推送通知给接收设备（除了他们自己的ID），然而，手机软件可以使用从iBeacons接收到的信号来自己推送通知。</p>
<h3 id="u533A_u57DF_u76D1_u6D4B"><a href="#u533A_u57DF_u76D1_u6D4B" class="headerlink" title="区域监测"></a>区域监测</h3><p>区域监测仅限20个区域，可以在后台运行，即使app在后台运行或者手机锁屏，依然有不同的应用通知监听app（用户）进入/退出该区。区域监测也给了关闭的app一个反应的机会，在进入相关区域时允许弹出小窗口。</p>
<h3 id="u5206_u7C7B"><a href="#u5206_u7C7B" class="headerlink" title="分类"></a>分类</h3><p>分类工作仅应用在前端，但是将返回数组iBeacons的所有属性（UUID等）。</p>
<p>一个iOS设备接收一个iBeacon的传输可以近乎于iBeacon的距离，iBeacon的传输距离分为3个不同的范围：</p>
<p>最近：几厘米<br>中距：几米<br>远距：大于10米<br>当用户进入、退出或者在区域内徘徊时，iBeacon的广播有能力进行传播，根据用户和Beacon的距离，这三个距离范围可以相互交互。</p>
<p>iBeacon传输的最大射程将取决于位置、现场布置、障碍物(例如在一个皮革手袋或厚情况下)。标准信号有近似的70米，远程信号可达450米。</p>
<h3 id="u7535_u529B_u6D88_u8017"><a href="#u7535_u529B_u6D88_u8017" class="headerlink" title="电力消耗"></a>电力消耗</h3><p>Comparison of 16 major beacon hardware of battery life in months (higher is better) by Aislelabs’ The Hitchickers Guide to iBeacon Hardware[15]<br>低功耗蓝牙相比于传统蓝牙在功耗和效率方面有显著提高，在16个不同的iBeacon厂商的一项研究报告称，电池的寿命在1到24个月的范围之内。苹果公司，用一枚纽扣电池提供了1-3个月的生活，设置了100ms的广告频率，这样如果电池提供时间增加到2~3年就相当于广告频率增到到900ms。</p>
<p>在部署beacon启用手机app时，手机电池的消耗是一个必须要考虑的因素。最新的报告显示附近有ibeacon时，旧的手机会消耗更多的电量，然而新一点的手机在同样的环境下则更加高效。除了浏览手机消耗的时间，扫描附近的浏览量和信标数依然是电池消耗很重要的因素，正如Aislelabs指出的报告一样。在后续的报告中，Aislelabs发现了苹果5s，苹果5c和旧版的苹果4s在电池消耗方面的一个大幅的改善。在10个ibeacons的周围，苹果4s每小时消耗了11%的电量而苹果5s则每小时比它少消耗5%的电量。一个高效节能的ibeacon应用程序需要考虑这些方面去保持应用的响应性和电池消耗之间的平衡。</p>
<h3 id="u6700_u65B0_u8FDB_u5C55"><a href="#u6700_u65B0_u8FDB_u5C55" class="headerlink" title="最新进展"></a>最新进展</h3><p>2013年中苹果公司介绍了iBeacons，专家撰写了文章表示iBeacons怎样通过简化支付提供现场支持来帮助零售业。随着IOS7的推出，零售商和其他中小型企业将能够使用蓝牙4.0技术。据报道，2013年12月6日苹果在其254个零售店中使用了iBeacons。</p>
<p>2014年5月，花费最低5美金到30美金以上就可购买不同的iBeacons硬件设备。每一个不同的设备对自己的默认发射功率和广告频率都有不同的默认设置。一些硬件的广告频率可以快到每100毫秒一次而还有一些的可以低至1赫兹。 iBeacon技术还在襁褓期，有报道指出一个软件存在的异样，最新安卓系统的蓝牙堆栈在面对许多iBeacons时会崩溃。</p>
<h3 id="u517C_u5BB9_u8BBE_u5907"><a href="#u517C_u5BB9_u8BBE_u5907" class="headerlink" title="兼容设备"></a>兼容设备</h3><p>支持蓝牙4.0的IOS设备（iPhone4s及以上，iPad第三代及以上，iPad mini第一代及以上，iPod Touch第五代）。<br>支持OS X Mavericks 10.9操作系统和蓝牙4.0的苹果计算机。<br>安卓4.3及以上（如三星 Galaxy S3/S4/S4 Mini, 三星 Galaxy Note 2/3, HTC One, Google/LG Nexus 7 2013 version/Nexus 4/Nexus 5, HTC Butterfly, OnePlus One）<br>支持Lumia Cyan及以上更新服务Windows Phone设备（报告显示，不包含Windows Phone 8.1）</p>
<h3 id="u7F3A_u70B9"><a href="#u7F3A_u70B9" class="headerlink" title="缺点"></a>缺点</h3><p>iBeacon协议是开放的，且易于伪造，部署的节点可能被其他人恶意使用，甚至伪造一个ID完全相同的 Beacon，支付安全很难保证。该应用可以搜集用户的位置信息、行为信息，这些隐私信息的安全要如何保障尚待规范。</p>
<p>iBeacon太麻烦，对于用户来说手机上需要下载不同的 App 才能在不同的商场、地段体验，对于商户来说也没有一个通用、快捷的后台。</p>
<p>手机必须支持蓝牙4.0以上并保持蓝牙开启状态</p>
<p>iBeacons由于依赖于蓝牙技术，传输距离较大，而且通过基站传输数据，那么，如果基站被攻击，连接到基站的设备就很危险了。iBeacons是通过蓝牙实现的，一般来说两个设备建立连接都需要几秒甚至十几秒吧，操作也比较繁琐，这个对于用户来说体验就相对较差了。</p>
<p>在再室外环境 Beacon的信号特别不稳定，尤其是一大风，本来已经搜索到的Beacon瞬间就“风逝”了。<br>测距技术主要有三种：AoA（角测距）、RSSI（基于接收信号强度）和ToA（时间测距）。<br>低功耗蓝牙（即BLE）的测距主要是通过RSSI。虽然从一定程度上说RSSI只需较少的通信开销和较低的实现复杂度,这在能量有限的网络节点中是非常重要的。<br>同时它也有一个致命的缺点——过渡依赖环境。RSSI易受环境变化影响，从而只能是大致测距，想要提高精确度，需要至少三个Beacon，利用圆覆盖区重叠区域得到比较精确的距离。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u662F_u4EC0_u4E48_uFF1F"><a href="#u662F_u4EC0_u4E48_uFF1F" class="headerlink" title="是什么？"></a>是什么？</h3><p>iBeacon是apple公司提出的“一种可以让附近手持电子设备检测到的一种新的低功耗、低成本信号传送器”的一套可用于室内定位系统的协议。 这种技术可以使一个智能手机或其他装置在一个iBeacon基站的感应范围内执行相应的命令。</p>
<p>这是帮助智能手机确定他们大概位置或环境的一个应用程序。在一个iBeacon基站的帮助下，智能手机的软件能大概找到它和这个iBeacon基站的相对位置。iBeacon能让手机收到附近售卖商品的通知，也可以让消费者不用拿出钱包或信用卡就能在销售点的POS机上完成支付。iBeacon技术通过低功耗蓝牙（BLE），也就是我们所说的智能蓝牙来实现。</p>
<p>iBeacon为利用低功耗蓝牙可以近距离感测的功能来传输通用唯一识别码的一个app或操作系统。 这个识别码可以在网上被查找到用以确定设备的物理位置或者可以在设备上触发一个动作比如在社交媒体签到或者推送通知。</p>
<p>各种供应商创造了不同形式的iBeacon硬件设备，包括小硬币电池设备，随身碟和蓝牙4.0通用加密狗。<br>]]>
    
    </summary>
    
      <category term="Ibeacon" scheme="http://yoursite.com/tags/Ibeacon/"/>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[React-Native学习指南]]></title>
    <link href="http://yoursite.com/2015/12/19/React-Native%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2015/12/19/React-Native学习指南/</id>
    <published>2015-12-19T15:32:17.000Z</published>
    <updated>2016-02-19T09:13:18.000Z</updated>
    <content type="html"><![CDATA[<p>本指南汇集React-Native各类学习资源，给大家提供便利。指南正在不断的更新，大家有好的资源欢迎Pull Requests！</p>
<p>同时还有Awesome React-Native系列</p>
<p><a href="https://github.com/jondot/awesome-react-native" target="_blank" rel="external">https://github.com/jondot/awesome-react-native</a></p>
<h1 id="u76EE_u5F55"><a href="#u76EE_u5F55" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="/#教程">教程</a><ul>
<li><a href="/#react-native">React Native</a></li>
<li><a href="/#reactjs">React.js</a></li>
<li><a href="/#es6">ES6</a></li>
<li><a href="/#系列教程">系列教程</a></li>
</ul>
</li>
<li><a href="/#开源app">开源APP</a></li>
<li><a href="/#组件">组件</a></li>
<li><a href="/#工具">工具</a></li>
<li><a href="/#资源网站">资源网站</a></li>
<li><a href="/#业界讨论">业界讨论</a></li>
</ul>
<h2 id="u6559_u7A0B"><a href="#u6559_u7A0B" class="headerlink" title="教程"></a>教程</h2><a id="more"></a>
<h3 id="React_Native"><a href="#React_Native" class="headerlink" title="React Native"></a>React Native</h3><ul>
<li><p><strong>React-Native入门指南</strong><br><a href="https://github.com/vczero/react-native-lession" target="_blank" rel="external">https://github.com/vczero/react-native-lession</a></p>
</li>
<li><p><strong>React-Native视频教程(部分免费)</strong><br><a href="https://egghead.io/technologies/react" target="_blank" rel="external">https://egghead.io/technologies/react</a></p>
</li>
<li><p>react-native 官方api文档<br><a href="http://facebook.github.io/react-native/docs/getting-started.html" target="_blank" rel="external">http://facebook.github.io/react-native/docs/getting-started.html</a></p>
</li>
<li><p>react-native中文文档(极客学院)<br><a href="http://wiki.jikexueyuan.com/project/react-native/" target="_blank" rel="external">http://wiki.jikexueyuan.com/project/react-native/</a></p>
</li>
<li><p>react-native中文文档(react native中文网，人工翻译，官网完全同步)<br><a href="http://react-native.cn/docs/getting-started.html" target="_blank" rel="external">http://react-native.cn/docs/getting-started.html</a></p>
</li>
<li><p>react-native第一课<br><a href="http://html-js.com/article/2783" target="_blank" rel="external">http://html-js.com/article/2783</a></p>
</li>
<li><p>深入浅出 React Native：使用 JavaScript 构建原生应用<br><a href="http://zhuanlan.zhihu.com/FrontendMagazine/19996445" target="_blank" rel="external">http://zhuanlan.zhihu.com/FrontendMagazine/19996445</a></p>
</li>
<li><p>React Native通信机制详解<br><a href="http://blog.cnbang.net/tech/2698/" target="_blank" rel="external">http://blog.cnbang.net/tech/2698/</a></p>
</li>
<li><p>React Native布局篇<br><a href="http://segmentfault.com/a/1190000002658374" target="_blank" rel="external">http://segmentfault.com/a/1190000002658374</a></p>
</li>
<li><p>React Native 基础练习指北（一）<br><a href="http://segmentfault.com/a/1190000002645929" target="_blank" rel="external">http://segmentfault.com/a/1190000002645929</a></p>
</li>
<li><p>React Native 基础练习指北（二）<br><a href="http://segmentfault.com/a/1190000002647733" target="_blank" rel="external">http://segmentfault.com/a/1190000002647733</a></p>
</li>
<li><p>Diary of Building an iOS App with React Native<br><a href="http://herman.asia/building-a-flashcard-app-with-react-native" target="_blank" rel="external">http://herman.asia/building-a-flashcard-app-with-react-native</a></p>
</li>
<li><p>Use React Native in Existing iOS App<br><a href="http://blog-en.leapoahead.com/post/use-react-native-in-existing-ios-app" target="_blank" rel="external">http://blog-en.leapoahead.com/post/use-react-native-in-existing-ios-app</a></p>
</li>
<li><p>React Native For Beginners – The Next Big Thing?<br><a href="http://devdactic.com/react-native-for-beginners/" target="_blank" rel="external">http://devdactic.com/react-native-for-beginners/</a></p>
</li>
<li><p>How To Implement A Tab Bar With React Native<br><a href="http://devdactic.com/react-native-tab-bar/" target="_blank" rel="external">http://devdactic.com/react-native-tab-bar/</a></p>
</li>
<li><p>tcomb-form-native使用视频教程(需翻墙)<br><a href="http://react.rocks/example/tcomb-form-native" target="_blank" rel="external">http://react.rocks/example/tcomb-form-native</a></p>
</li>
<li><p>React Native分享记录<br><a href="http://segmentfault.com/a/1190000002678782" target="_blank" rel="external">http://segmentfault.com/a/1190000002678782</a></p>
</li>
<li><p>React Native构建本地视图组件<br><a href="https://www.dobest.me/article/11" target="_blank" rel="external">https://www.dobest.me/article/11</a></p>
</li>
<li><p>react-native-android-lession(安卓系列教程)<br><a href="https://github.com/yipengmu/react-native-android-lession" target="_blank" rel="external">https://github.com/yipengmu/react-native-android-lession</a></p>
</li>
<li><p>React Native模块桥接详解<br><a href="https://www.dobest.me/article/14" target="_blank" rel="external">https://www.dobest.me/article/14</a></p>
</li>
<li><p>React Native: 配置和起步<br><a href="http://www.liaohuqiu.net/cn/posts/react-native-1/" target="_blank" rel="external">http://www.liaohuqiu.net/cn/posts/react-native-1/</a></p>
</li>
<li><p>React Native: Android 的打包<br><a href="http://www.liaohuqiu.net/cn/posts/react-native-android-package/" target="_blank" rel="external">http://www.liaohuqiu.net/cn/posts/react-native-android-package/</a></p>
</li>
<li><p>react-native的第一课<br><a href="https://github.com/coderyi/blog/blob/master/articles/2016/0122_react-native_first_lesson.md" target="_blank" rel="external">https://github.com/coderyi/blog/blob/master/articles/2016/0122_react-native_first_lesson.md</a></p>
</li>
</ul>
<h3 id="React-js"><a href="#React-js" class="headerlink" title="React.js"></a>React.js</h3><ul>
<li><p>react.js中文文档<br><a href="http://reactjs.cn/" target="_blank" rel="external">http://reactjs.cn/</a></p>
</li>
<li><p>react.js入门教程(gitbook)<br><a href="https://hulufei.gitbooks.io/react-tutorial/content/introduction.html" target="_blank" rel="external">https://hulufei.gitbooks.io/react-tutorial/content/introduction.html</a></p>
</li>
<li><p><strong>react.js快速入门教程 - 阮一峰</strong><br><a href="http://www.ruanyifeng.com/blog/2015/03/react.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2015/03/react.html</a></p>
</li>
<li><p>react.js视频教程<br><a href="http://react.nodejs-china.org/t/reactjs/584" target="_blank" rel="external">http://react.nodejs-china.org/t/reactjs/584</a></p>
</li>
</ul>
<h3 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h3><ul>
<li><p>深入浅出ES6（一）：ES6是什么<br><a href="http://www.infoq.com/cn/articles/es6-in-depth-an-introduction" target="_blank" rel="external">http://www.infoq.com/cn/articles/es6-in-depth-an-introduction</a></p>
</li>
<li><p>深入浅出ES6（二）：迭代器和for-of循环<br><a href="http://www.infoq.com/cn/articles/es6-in-depth-iterators-and-the-for-of-loop" target="_blank" rel="external">http://www.infoq.com/cn/articles/es6-in-depth-iterators-and-the-for-of-loop</a></p>
</li>
<li><p>深入浅出ES6（三）：生成器 Generators<br><a href="http://www.infoq.com/cn/articles/es6-in-depth-generators" target="_blank" rel="external">http://www.infoq.com/cn/articles/es6-in-depth-generators</a></p>
</li>
<li><p>深入浅出ES6（四）：模板字符串<br><a href="http://www.infoq.com/cn/articles/es6-in-depth-template-string" target="_blank" rel="external">http://www.infoq.com/cn/articles/es6-in-depth-template-string</a></p>
</li>
<li><p>深入浅出ES6（五）：不定参数和默认参数<br><a href="http://www.infoq.com/cn/articles/es6-in-depth-rest-parameters-and-defaults" target="_blank" rel="external">http://www.infoq.com/cn/articles/es6-in-depth-rest-parameters-and-defaults</a></p>
</li>
</ul>
<h3 id="u7CFB_u5217_u6559_u7A0B"><a href="#u7CFB_u5217_u6559_u7A0B" class="headerlink" title="系列教程"></a>系列教程</h3><ul>
<li><p>深入浅出React（一）：React的设计哲学 - 简单之美<br><a href="http://www.infoq.com/cn/articles/react-art-of-simplity" target="_blank" rel="external">http://www.infoq.com/cn/articles/react-art-of-simplity</a></p>
</li>
<li><p>深入浅出React（二）：React开发神器Webpack<br><a href="http://www.infoq.com/cn/articles/react-and-webpack" target="_blank" rel="external">http://www.infoq.com/cn/articles/react-and-webpack</a></p>
</li>
<li><p>深入浅出React（三）：理解JSX和组件<br><a href="http://www.infoq.com/cn/articles/react-jsx-and-component" target="_blank" rel="external">http://www.infoq.com/cn/articles/react-jsx-and-component</a></p>
</li>
<li><p>深入浅出React（四）：虚拟DOM Diff算法解析<br><a href="http://www.infoq.com/cn/articles/react-dom-diff" target="_blank" rel="external">http://www.infoq.com/cn/articles/react-dom-diff</a></p>
</li>
<li><p>深入浅出React（五）：使用Flux搭建React应用程序架构<br><a href="http://www.infoq.com/cn/articles/react-flux" target="_blank" rel="external">http://www.infoq.com/cn/articles/react-flux</a></p>
</li>
<li><p>react-webpack-cookbook中文版<br><a href="http://fakefish.github.io/react-webpack-cookbook/" target="_blank" rel="external">http://fakefish.github.io/react-webpack-cookbook/</a></p>
</li>
<li><p>Flex 布局语法教程<br><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a></p>
</li>
<li><p>React 初探<br><a href="http://www.alloyteam.com/2015/04/react-explore/" target="_blank" rel="external">http://www.alloyteam.com/2015/04/react-explore/</a></p>
</li>
<li><p>React虚拟DOM浅析<br><a href="http://www.alloyteam.com/2015/10/react-virtual-analysis-of-the-dom/" target="_blank" rel="external">http://www.alloyteam.com/2015/10/react-virtual-analysis-of-the-dom/</a></p>
</li>
<li><p>react组件间通信<br><a href="http://www.alloyteam.com/2015/07/react-zu-jian-jian-tong-xin/" target="_blank" rel="external">http://www.alloyteam.com/2015/07/react-zu-jian-jian-tong-xin/</a></p>
</li>
<li><p>React 数据流管理架构之 Redux 介绍<br><a href="http://www.alloyteam.com/2015/09/react-redux/" target="_blank" rel="external">http://www.alloyteam.com/2015/09/react-redux/</a></p>
</li>
<li><p>React服务器端渲染实践小结<br><a href="http://www.alloyteam.com/2015/10/8783/" target="_blank" rel="external">http://www.alloyteam.com/2015/10/8783/</a></p>
</li>
<li><p>React Native Android 踩坑之旅<br><a href="http://www.alloyteam.com/2015/10/react-native-android-steps-on-tour/" target="_blank" rel="external">http://www.alloyteam.com/2015/10/react-native-android-steps-on-tour/</a></p>
</li>
<li><p>React Native 之 JSBridge<br><a href="http://www.alloyteam.com/2015/05/react-native-zhi-jsbridge/" target="_blank" rel="external">http://www.alloyteam.com/2015/05/react-native-zhi-jsbridge/</a></p>
</li>
</ul>
<h3 id="React_Native_u63A2_u7D22_u7CFB_u5217_u6559_u7A0B"><a href="#React_Native_u63A2_u7D22_u7CFB_u5217_u6559_u7A0B" class="headerlink" title="React Native探索系列教程"></a>React Native探索系列教程</h3><ul>
<li><p>React Native探索（一）：背景、规划和风险<br><a href="http://www.infoq.com/cn/articles/react-native-overview" target="_blank" rel="external">http://www.infoq.com/cn/articles/react-native-overview</a></p>
</li>
<li><p>React Native探索（二）：布局篇<br><a href="http://www.infoq.com/cn/articles/react-native-layout" target="_blank" rel="external">http://www.infoq.com/cn/articles/react-native-layout</a></p>
</li>
<li><p>React Native探索（三）：与 react-web 的融合<br><a href="http://www.infoq.com/cn/articles/react-native-web" target="_blank" rel="external">http://www.infoq.com/cn/articles/react-native-web</a></p>
</li>
</ul>
<h2 id="u5F00_u6E90APP"><a href="#u5F00_u6E90APP" class="headerlink" title="开源APP"></a>开源APP</h2><blockquote>
<p>研究源码也是一个很好的学习方式</p>
</blockquote>
<ul>
<li><p>官方演示App<br><a href="https://github.com/facebook/react-native/tree/master/Examples" target="_blank" rel="external">https://github.com/facebook/react-native/tree/master/Examples</a></p>
</li>
<li><p>react-native-dribbble-app<br><a href="https://github.com/catalinmiron/react-native-dribbble-app" target="_blank" rel="external">https://github.com/catalinmiron/react-native-dribbble-app</a></p>
</li>
<li><p><strong>Leanote for iOS(云笔记)</strong><br><a href="https://github.com/leanote/leanote-ios-rn" target="_blank" rel="external">https://github.com/leanote/leanote-ios-rn</a></p>
</li>
<li><p><strong>ReactNativeRubyChina</strong><br><a href="https://github.com/henter/ReactNativeRubyChina" target="_blank" rel="external">https://github.com/henter/ReactNativeRubyChina</a></p>
</li>
<li><p>HackerNews-React-Native<br><a href="https://github.com/iSimar/HackerNews-React-Native" target="_blank" rel="external">https://github.com/iSimar/HackerNews-React-Native</a></p>
</li>
<li><p>React-Native新闻客户端<br><a href="https://github.com/tabalt/ReactNativeNews" target="_blank" rel="external">https://github.com/tabalt/ReactNativeNews</a></p>
</li>
<li><p><strong>newswatch(新闻客户端)</strong><br><a href="https://github.com/bradoyler/newswatch-react-native" target="_blank" rel="external">https://github.com/bradoyler/newswatch-react-native</a></p>
</li>
<li><p><strong>buyscreen(购买页面)</strong><br><a href="https://github.com/appintheair/react-native-buyscreen" target="_blank" rel="external">https://github.com/appintheair/react-native-buyscreen</a></p>
</li>
<li><p><strong>V2EX客户端</strong><br><a href="https://github.com/samuel1112/v2er" target="_blank" rel="external">https://github.com/samuel1112/v2er</a></p>
</li>
<li><p>react-native-todo<br><a href="https://github.com/joemaddalone/react-native-todo" target="_blank" rel="external">https://github.com/joemaddalone/react-native-todo</a></p>
</li>
<li><p>react-native-beer<br><a href="https://github.com/muratsu/react-native-beer" target="_blank" rel="external">https://github.com/muratsu/react-native-beer</a></p>
</li>
<li><p>react-native-stars<br><a href="https://github.com/86/react-native-stars" target="_blank" rel="external">https://github.com/86/react-native-stars</a></p>
</li>
<li><p><strong>模仿天猫首页的app</strong><br><a href="https://github.com/hugohua/react-native-demo" target="_blank" rel="external">https://github.com/hugohua/react-native-demo</a></p>
</li>
<li><p>ReactNativeChess<br><a href="https://github.com/csarsam/ReactNativeChess" target="_blank" rel="external">https://github.com/csarsam/ReactNativeChess</a></p>
</li>
<li><p>react native 编写的音乐软件<br><a href="https://github.com/Johnqing/miumiu" target="_blank" rel="external">https://github.com/Johnqing/miumiu</a></p>
</li>
<li><p>react-native-pokedex<br><a href="https://github.com/ababol/react-native-pokedex" target="_blank" rel="external">https://github.com/ababol/react-native-pokedex</a></p>
</li>
<li><p>CNode-React-Native<br><a href="https://github.com/SFantasy/CNode-React-Native" target="_blank" rel="external">https://github.com/SFantasy/CNode-React-Native</a></p>
</li>
<li><p>8tracks电台客户端<br><a href="https://github.com/voronianski/EightTracksReactNative" target="_blank" rel="external">https://github.com/voronianski/EightTracksReactNative</a></p>
</li>
<li><p>React-Native实现的计算器<br><a href="https://github.com/yoxisem544/Calculator-using-React-Native" target="_blank" rel="external">https://github.com/yoxisem544/Calculator-using-React-Native</a></p>
</li>
<li><p><strong>房产搜索app</strong><br><a href="https://github.com/jawee/react-native-PropertyFinder" target="_blank" rel="external">https://github.com/jawee/react-native-PropertyFinder</a></p>
</li>
<li><p>知乎专栏app<br><a href="https://github.com/LeezQ/react-native-zhihu-app" target="_blank" rel="external">https://github.com/LeezQ/react-native-zhihu-app</a></p>
</li>
<li><p>ForeignExchangeApp<br><a href="https://github.com/peralmq/ForeignExchangeApp" target="_blank" rel="external">https://github.com/peralmq/ForeignExchangeApp</a></p>
</li>
<li><p>Segmentfault 客户端<br><a href="https://github.com/fakefish/sf-react-native" target="_blank" rel="external">https://github.com/fakefish/sf-react-native</a></p>
</li>
<li><p>糗事百科app<br><a href="https://github.com/stormhouse/QiuShiReactNative" target="_blank" rel="external">https://github.com/stormhouse/QiuShiReactNative</a></p>
</li>
<li><p>孢子社区app<br><a href="https://github.com/Hi-Rube/baoz-ReactNative" target="_blank" rel="external">https://github.com/Hi-Rube/baoz-ReactNative</a></p>
</li>
<li><p><strong>深JS app</strong><br><a href="https://github.com/fraserxu/shenjs" target="_blank" rel="external">https://github.com/fraserxu/shenjs</a></p>
</li>
<li><p>Den - 房屋销售app*<br><a href="https://github.com/asamiller/den" target="_blank" rel="external">https://github.com/asamiller/den</a></p>
</li>
<li><p><strong>Noder-cnodejs客户端</strong><br><a href="https://github.com/soliury/noder-react-native" target="_blank" rel="external">https://github.com/soliury/noder-react-native</a></p>
</li>
<li><p>知乎日报Android版<br><a href="https://github.com/race604/ZhiHuDaily-React-Native" target="_blank" rel="external">https://github.com/race604/ZhiHuDaily-React-Native</a></p>
</li>
<li><p>ziliun-react-native<br><a href="https://github.com/sonnylazuardi/ziliun-react-native" target="_blank" rel="external">https://github.com/sonnylazuardi/ziliun-react-native</a></p>
</li>
<li><p>react-native-weather-app<br><a href="https://github.com/shevawen/react-native-weather-app" target="_blank" rel="external">https://github.com/shevawen/react-native-weather-app</a></p>
</li>
<li><p>React Native Sample App(Navigation,Flux)<br><a href="https://github.com/taskrabbit/ReactNativeSampleApp" target="_blank" rel="external">https://github.com/taskrabbit/ReactNativeSampleApp</a></p>
</li>
<li><p>TesterHome社区app<br><a href="https://github.com/qddegtya/A-ReactNative-TesterHome" target="_blank" rel="external">https://github.com/qddegtya/A-ReactNative-TesterHome</a></p>
</li>
<li><p>Finance - 股票报价app<br><a href="https://github.com/7kfpun/FinanceReactNative" target="_blank" rel="external">https://github.com/7kfpun/FinanceReactNative</a></p>
</li>
<li><p>shopping - 购物app<br><a href="https://github.com/bigsui/shopping-react-native" target="_blank" rel="external">https://github.com/bigsui/shopping-react-native</a></p>
</li>
<li><p>zhuiyuan - 追源cms app<br><a href="https://github.com/kazaff/ZhuiYuanDemo" target="_blank" rel="external">https://github.com/kazaff/ZhuiYuanDemo</a></p>
</li>
<li><p>uestc-bbs-react-native - UESTC清水河畔RN客户端(with Redux)<br><a href="https://github.com/just4fun/uestc-bbs-react-native" target="_blank" rel="external">https://github.com/just4fun/uestc-bbs-react-native</a></p>
</li>
<li><p><strong>react-native-nw-react-calculator</strong>(iOS/Android、Web、桌面多端)<br><a href="https://github.com/benoitvallon/react-native-nw-react-calculator" target="_blank" rel="external">https://github.com/benoitvallon/react-native-nw-react-calculator</a></p>
</li>
<li><p>react-native-nba-app<br><a href="https://github.com/wwayne/react-native-nba-app" target="_blank" rel="external">https://github.com/wwayne/react-native-nba-app</a></p>
</li>
</ul>
<h2 id="u7EC4_u4EF6"><a href="#u7EC4_u4EF6" class="headerlink" title="组件"></a>组件</h2><blockquote>
<p>由于已经有较好的组件库网站，这里就不做总结。可以直接查看如下网站，过后可能精选一部分优质组件出来 :P</p>
</blockquote>
<ul>
<li><p><strong>React-native组件库</strong>（比较全的组件库）<br><a href="http://react.parts/" target="_blank" rel="external">http://react.parts/</a></p>
</li>
<li><p><strong>React Native Modules</strong><br><a href="http://reactnativemodules.com/" target="_blank" rel="external">http://reactnativemodules.com/</a></p>
</li>
<li><p><strong>最佳轮播类组件</strong><br><a href="https://github.com/leecade/react-native-swiper" target="_blank" rel="external">https://github.com/leecade/react-native-swiper</a></p>
</li>
<li><p>React Native Router<br><a href="https://github.com/t4t5/react-native-router" target="_blank" rel="external">https://github.com/t4t5/react-native-router</a></p>
</li>
<li><p>下拉刷新组件<br><a href="https://github.com/jsdf/react-native-refreshable-listview" target="_blank" rel="external">https://github.com/jsdf/react-native-refreshable-listview</a></p>
</li>
<li><p>模态框<br><a href="https://github.com/brentvatne/react-native-modal" target="_blank" rel="external">https://github.com/brentvatne/react-native-modal</a></p>
</li>
<li><p>react-native-navbar<br><a href="https://github.com/react-native-fellowship/react-native-navbar" target="_blank" rel="external">https://github.com/react-native-fellowship/react-native-navbar</a></p>
</li>
<li><p>滚动轮播组件<br><a href="https://github.com/appintheair/react-native-looped-carousel" target="_blank" rel="external">https://github.com/appintheair/react-native-looped-carousel</a></p>
</li>
<li><p>HTML显示组件<br><a href="https://github.com/jsdf/react-native-htmlview" target="_blank" rel="external">https://github.com/jsdf/react-native-htmlview</a></p>
</li>
<li><p><strong>Material React Native (MRN)</strong> - Material Design组件库<br><a href="https://github.com/binggg/mrn" target="_blank" rel="external">https://github.com/binggg/mrn</a></p>
</li>
</ul>
<h2 id="u5DE5_u5177"><a href="#u5DE5_u5177" class="headerlink" title="工具"></a>工具</h2><ul>
<li><p>react-native-snippets(代码提示)<br><a href="https://github.com/Shrugs/react-native-snippets" target="_blank" rel="external">https://github.com/Shrugs/react-native-snippets</a></p>
</li>
<li><p>react-native-babel(使用ES6+)<br><a href="https://github.com/roman01la/react-native-babel" target="_blank" rel="external">https://github.com/roman01la/react-native-babel</a></p>
</li>
<li><p>sqlite for react-native<br><a href="https://github.com/almost/react-native-sqlite" target="_blank" rel="external">https://github.com/almost/react-native-sqlite</a></p>
</li>
<li><p>gulp-react-native-css(就像写css一样写React Style)<br><a href="https://github.com/soliury/gulp-react-native-css" target="_blank" rel="external">https://github.com/soliury/gulp-react-native-css</a></p>
</li>
<li><p>rnpm(React Native Package Manager)<br><a href="https://github.com/rnpm/rnpm" target="_blank" rel="external">https://github.com/rnpm/rnpm</a></p>
</li>
</ul>
<h2 id="u8D44_u6E90_u7F51_u7AD9"><a href="#u8D44_u6E90_u7F51_u7AD9" class="headerlink" title="资源网站"></a>资源网站</h2><ul>
<li><p>React-native官网<br><a href="http://facebook.github.io/react-native/" target="_blank" rel="external">http://facebook.github.io/react-native/</a></p>
</li>
<li><p><strong>React-China社区</strong><br><a href="http://react-china.org/" target="_blank" rel="external">http://react-china.org/</a></p>
</li>
<li><p><strong>React Native中文社区</strong><br><a href="http://bbs.react-native.cn/" target="_blank" rel="external">http://bbs.react-native.cn/</a></p>
</li>
<li><p><strong>React-native组件库</strong>（比较全的组件库）<br><a href="http://react.parts/" target="_blank" rel="external">http://react.parts/</a></p>
</li>
<li><p><strong>React Native Modules</strong><br><a href="http://reactnativemodules.com/" target="_blank" rel="external">http://reactnativemodules.com/</a></p>
</li>
<li><p><strong>Use React Native 资讯站</strong>(使用技巧及新闻)<br><a href="http://www.reactnative.com/" target="_blank" rel="external">http://www.reactnative.com/</a></p>
</li>
<li><p>11款React Native开源移动 UI 组件<br><a href="http://www.oschina.net/news/61214/11-react-native-ui-components" target="_blank" rel="external">http://www.oschina.net/news/61214/11-react-native-ui-components</a></p>
</li>
<li><p><strong>稀土掘金的 React 标签</strong><br><a href="http://gold.xitu.io/#/tag/React.js" target="_blank" rel="external">http://gold.xitu.io/#/tag/React.js</a> <a href="http://gold.xitu.io/#/tag/React%20Native" target="_blank" rel="external">http://gold.xitu.io/#/tag/React%20Native</a></p>
</li>
</ul>
<h2 id="u4E1A_u754C_u8BA8_u8BBA"><a href="#u4E1A_u754C_u8BA8_u8BBA" class="headerlink" title="业界讨论"></a>业界讨论</h2><ul>
<li><p>跨平台开发时代的 (再次) 到来？（ Xamarin，NativeScript 和 React Native 对比）<br><a href="http://onevcat.com/2015/03/cross-platform/" target="_blank" rel="external">http://onevcat.com/2015/03/cross-platform/</a></p>
</li>
<li><p>谈谈 React Native - 唐巧<br><a href="http://blog.devtang.com/blog/2015/02/01/talk-about-react-native/" target="_blank" rel="external">http://blog.devtang.com/blog/2015/02/01/talk-about-react-native/</a></p>
</li>
<li><p>如何评价React-Native?<br><a href="http://www.zhihu.com/question/27852694/answer/43990708" target="_blank" rel="external">http://www.zhihu.com/question/27852694/answer/43990708</a></p>
</li>
<li><p>React Native概述：背景、规划和风险<br><a href="http://div.io/topic/938" target="_blank" rel="external">http://div.io/topic/938</a></p>
</li>
<li><p>Native与Web的融合 - Qcon中React-Native演讲<br><a href="http://www.infoq.com/cn/presentations/the-fusion-of-native-and-web" target="_blank" rel="external">http://www.infoq.com/cn/presentations/the-fusion-of-native-and-web</a></p>
</li>
</ul>
<p>本文转自:<a href="https://github.com/jondot/awesome-react-native" target="_blank" rel="external">https://github.com/jondot/awesome-react-native</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本指南汇集React-Native各类学习资源，给大家提供便利。指南正在不断的更新，大家有好的资源欢迎Pull Requests！</p>
<p>同时还有Awesome React-Native系列</p>
<p><a href="https://github.com/jondot/awesome-react-native">https://github.com/jondot/awesome-react-native</a></p>
<h1 id="u76EE_u5F55"><a href="#u76EE_u5F55" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="/#教程">教程</a><ul>
<li><a href="/#react-native">React Native</a></li>
<li><a href="/#reactjs">React.js</a></li>
<li><a href="/#es6">ES6</a></li>
<li><a href="/#系列教程">系列教程</a></li>
</ul>
</li>
<li><a href="/#开源app">开源APP</a></li>
<li><a href="/#组件">组件</a></li>
<li><a href="/#工具">工具</a></li>
<li><a href="/#资源网站">资源网站</a></li>
<li><a href="/#业界讨论">业界讨论</a></li>
</ul>
<h2 id="u6559_u7A0B"><a href="#u6559_u7A0B" class="headerlink" title="教程"></a>教程</h2>]]>
    
    </summary>
    
      <category term="React-Native" scheme="http://yoursite.com/tags/React-Native/"/>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[RecyclerView 列表控件中简单实现时间线]]></title>
    <link href="http://yoursite.com/2015/12/18/RecyclerView%20%E5%88%97%E8%A1%A8%E6%8E%A7%E4%BB%B6%E4%B8%AD%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E6%97%B6%E9%97%B4%E7%BA%BF/"/>
    <id>http://yoursite.com/2015/12/18/RecyclerView 列表控件中简单实现时间线/</id>
    <published>2015-12-17T17:01:14.000Z</published>
    <updated>2016-02-19T09:20:12.000Z</updated>
    <content type="html"><![CDATA[<p>看见很多软件中都有时间线的东西，貌似天气啊，旅游啊什么的最多了；具体实现方式很多，在本篇文章中讲解一种自定义View封装的方式。</p>
<h3 id="u6548_u679C"><a href="#u6548_u679C" class="headerlink" title="效果"></a>效果</h3><p>先来看看效果。<br><img src="http://www.jcodecraeer.com/uploads/20150825/1440469250572021.png" alt=""><br><a id="more"></a></p>
<h3 id="u5206_u6790"><a href="#u5206_u6790" class="headerlink" title="分析"></a>分析</h3><p>软件中，可以看见前面的时间线也就是线条加上圆圈组成；当然这里的圆圈与线条也都是可以随意换成其他的，比如图片等等。</p>
<p>当然这里最简单的来说，是上面一个线条，然后一个圆圈，然后下面一个线条；上线条在第一条数据时不做显示，下线条在最后一条数据时不做显示。</p>
<p><img src="http://www.jcodecraeer.com/uploads/20150825/1440469277121276.png" alt=""></p>
<p>这里自定义布局部分也就是把旁边的线条与圆圈封装到一起，并使用简单的方法来控制是否显示。<br>当封装好了后，与旁边的文字部分也就是水瓶方向的线性布局了，然后设置为每一个的RecyclerView 的Item的布局也就完成了。</p>
<h3 id="u63A7_u4EF6"><a href="#u63A7_u4EF6" class="headerlink" title="控件"></a>控件</h3><p>控件很简单，首先我们继承View，取名为 TimeLineMarker 就OK。</p>
<h3 id="Attrs__u5C5E_u6027"><a href="#Attrs__u5C5E_u6027" class="headerlink" title="Attrs 属性"></a>Attrs 属性</h3><p>开始控件之前先准备好需要的属性。</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;resources&gt;
    &lt;declare-styleable name=&quot;TimeLineMarker&quot;&gt;
        &lt;attr name=&quot;markerSize&quot; format=&quot;dimension&quot; /&gt;
        &lt;attr name=&quot;marker&quot; format=&quot;color|reference&quot; /&gt;
        &lt;attr name=&quot;beginLine&quot; format=&quot;color|reference&quot; /&gt;
        &lt;attr name=&quot;endLine&quot; format=&quot;color|reference&quot; /&gt;
        &lt;attr name=&quot;lineSize&quot; format=&quot;dimension&quot; /&gt;
    &lt;/declare-styleable&gt;
&lt;/resources&gt;
</code></pre><p>在这里也就准备了线条的大小、开始线条、结束线条、中间标示部分及大小。</p>
<h3 id="u5C5E_u6027_u4E0E_u73B0_u5B9E"><a href="#u5C5E_u6027_u4E0E_u73B0_u5B9E" class="headerlink" title="属性与现实"></a>属性与现实</h3><pre><code>private int mMarkerSize = 24;
private int mLineSize = 12;
private Drawable mBeginLine;
private Drawable mEndLine;
private Drawable mMarkerDrawable;

@Override
protected void onDraw(Canvas canvas) {
    if (mBeginLine != null) {
        mBeginLine.draw(canvas);
    }

    if (mEndLine != null) {
        mEndLine.draw(canvas);
    }

    if (mMarkerDrawable != null) {
        mMarkerDrawable.draw(canvas);
    }

    super.onDraw(canvas);
}
</code></pre><p>两个大小属性，3个具体的Drawable，然后在onDraw方法中进行具体的显示也就OK。</p>
<h3 id="u6784_u9020_u4E0E_u5C5E_u6027_u521D_u59CB_u5316"><a href="#u6784_u9020_u4E0E_u5C5E_u6027_u521D_u59CB_u5316" class="headerlink" title="构造与属性初始化"></a>构造与属性初始化</h3><p>在上面我们定义了属性，在这里我们在构造函数中获取XML所设置的属性。</p>
<pre><code>public TimeLineMarker(Context context) {
    this(context, null);
}

public TimeLineMarker(Context context, AttributeSet attrs) {
    this(context, attrs, 0);
}

public TimeLineMarker(Context context, AttributeSet attrs, int defStyle) {
    super(context, attrs, defStyle);
    init(attrs);
}

private void init(AttributeSet attrs) {
    // Load attributes
    final TypedArray a = getContext().obtainStyledAttributes(
            attrs, R.styleable.TimeLineMarker, 0, 0);

    mMarkerSize = a.getDimensionPixelSize(
            R.styleable.TimeLineMarker_markerSize,
            mMarkerSize);

    mLineSize = a.getDimensionPixelSize(
            R.styleable.TimeLineMarker_lineSize,
            mLineSize);

    mBeginLine = a.getDrawable(
            R.styleable.TimeLineMarker_beginLine);

    mEndLine = a.getDrawable(
            R.styleable.TimeLineMarker_endLine);

    mMarkerDrawable = a.getDrawable(
            R.styleable.TimeLineMarker_marker);

    a.recycle();

    if (mBeginLine != null)
        mBeginLine.setCallback(this);

    if (mEndLine != null)
        mEndLine.setCallback(this);

    if (mMarkerDrawable != null)
        mMarkerDrawable.setCallback(this);
}
</code></pre><h3 id="Drawable__u7684_u4F4D_u7F6E_u4E0E_u5927_u5C0F_u521D_u59CB_u5316"><a href="#Drawable__u7684_u4F4D_u7F6E_u4E0E_u5927_u5C0F_u521D_u59CB_u5316" class="headerlink" title="Drawable 的位置与大小初始化"></a>Drawable 的位置与大小初始化</h3><p>属性啥的有了，具体的Drawable 也有了，要显示的地方调用也是OK了；但是如果没有进行进行具体的位置调整这一切也都没有意义。</p>
<pre><code>@Override
protected void onSizeChanged(int w, int h, int oldw, int oldh) {
    super.onSizeChanged(w, h, oldw, oldh);
    initDrawableSize();
}

private void initDrawableSize() {
    int pLeft = getPaddingLeft();
    int pRight = getPaddingRight();
    int pTop = getPaddingTop();
    int pBottom = getPaddingBottom();

    int width = getWidth();
    int height = getHeight();

    int cWidth = width - pLeft - pRight;
    int cHeight = height - pTop - pBottom;

    Rect bounds;

    if (mMarkerDrawable != null) {
        // Size
        int markerSize = Math.min(mMarkerSize, Math.min(cWidth, cHeight));
        mMarkerDrawable.setBounds(pLeft, pTop,
                pLeft + markerSize, pTop + markerSize);

        bounds = mMarkerDrawable.getBounds();
    } else {
        bounds = new Rect(pLeft, pTop, pLeft + cWidth, pTop + cHeight);
    }


    int halfLineSize = mLineSize &gt;&gt; 1;
    int lineLeft = bounds.centerX() - halfLineSize;

    if (mBeginLine != null) {
        mBeginLine.setBounds(lineLeft, 0, lineLeft + mLineSize, bounds.top);
    }

    if (mEndLine != null) {
        mEndLine.setBounds(lineLeft, bounds.bottom, lineLeft + mLineSize, height);
    }
}
</code></pre><p>initDrawableSize 方法进行具体的运算，而运算的时间点就是当控件的大小改变（onSizeChanged）的时候。</p>
<p>在初始化中采用了一定的投机取巧；这里利用了上内边距与下内边距分别作为上线条与下线条的长度；而线条与中间的标识都采用了水平距中。</p>
<h3 id="u5176_u4ED6_u8BBE_u7F6E_u65B9_u6CD5"><a href="#u5176_u4ED6_u8BBE_u7F6E_u65B9_u6CD5" class="headerlink" title="其他设置方法"></a>其他设置方法</h3><pre><code>public void setLineSize(int lineSize) {
    if (mLineSize != lineSize) {
        this.mLineSize = lineSize;
        initDrawableSize();
        invalidate();
    }
}

public void setMarkerSize(int markerSize) {
    if (this.mMarkerSize != markerSize) {
        mMarkerSize = markerSize;
        initDrawableSize();
        invalidate();
    }
}

public void setBeginLine(Drawable beginLine) {
    if (this.mBeginLine != beginLine) {
        this.mBeginLine = beginLine;
        if (mBeginLine != null) {
            mBeginLine.setCallback(this);
        }
        initDrawableSize();
        invalidate();
    }
}

public void setEndLine(Drawable endLine) {
    if (this.mEndLine != endLine) {
        this.mEndLine = endLine;
        if (mEndLine != null) {
            mEndLine.setCallback(this);
        }
        initDrawableSize();
        invalidate();
    }
}

public void setMarkerDrawable(Drawable markerDrawable) {
    if (this.mMarkerDrawable != markerDrawable) {
        this.mMarkerDrawable = markerDrawable;
        if (mMarkerDrawable != null) {
            mMarkerDrawable.setCallback(this);
        }
        initDrawableSize();
        invalidate();
    }
}
</code></pre><p>在设置中，首先判断是否更改，如果更改那么就更新并重新计算位置；随后刷新界面。</p>
<blockquote>
<p>到这里，控件差不多准备OK了，其中还有很多可以完善的地方，比如加上快捷设置颜色什么的，也可以加上大小计算的东西。同时还可以加上时间线是水瓶还是垂直等等。在这里就不累赘介绍哪些了。下面来看看如何使用。</p>
</blockquote>
<h3 id="u4F7F_u7528"><a href="#u4F7F_u7528" class="headerlink" title="使用"></a>使用</h3><h4 id="XML_u5E03_u5C40"><a href="#XML_u5E03_u5C40" class="headerlink" title="XML布局"></a>XML布局</h4><h5 id="ITEM_u5E03_u5C40item_time_line-xml"><a href="#ITEM_u5E03_u5C40item_time_line-xml" class="headerlink" title="ITEM布局item_time_line.xml"></a>ITEM布局item_time_line.xml</h5><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:orientation=&quot;horizontal&quot;
    android:paddingLeft=&quot;@dimen/lay_16&quot;
    android:paddingRight=&quot;@dimen/lay_16&quot;
    tools:ignore=&quot;MissingPrefix&quot;&gt;

    &lt;net.qiujuer.example.timeline.widget.TimeLineMarker
        android:id=&quot;@+id/item_time_line_mark&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;match_parent&quot;
        android:paddingBottom=&quot;@dimen/lay_16&quot;
        android:paddingLeft=&quot;@dimen/lay_4&quot;
        android:paddingRight=&quot;@dimen/lay_4&quot;
        android:paddingTop=&quot;@dimen/lay_16&quot;
        app:beginLine=&quot;@color/black_alpha_32&quot;
        app:endLine=&quot;@color/black_alpha_32&quot;
        app:lineSize=&quot;2dp&quot;
        app:marker=&quot;@drawable/ic_timeline_default_marker&quot;
        app:markerSize=&quot;24dp&quot; /&gt;

    &lt;TextView
        android:id=&quot;@+id/item_time_line_txt&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_gravity=&quot;center&quot;
        android:paddingBottom=&quot;@dimen/lay_16&quot;
        android:paddingLeft=&quot;@dimen/lay_4&quot;
        android:paddingRight=&quot;@dimen/lay_4&quot;
        android:paddingTop=&quot;@dimen/lay_16&quot;
        android:textColor=&quot;@color/grey_600&quot;
        android:textSize=&quot;@dimen/font_16&quot; /&gt;

&lt;/LinearLayout&gt;
</code></pre><p>在这里我们之间使用顺序布局，左边是TimelIne控件，右边是一个简单的字体控件，具体使用中可以细化一些。</p>
<p>在TImeLine控件中我们的Mark是使用的drawable/ic_timeline_default_marker；这个就是一个简单的圆圈而已；对于自己美化可以使用一张图片代替或者更加复杂的布局；当然上面的线条就更加简单了，就直接使用颜色代替。</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:shape=&quot;oval&quot;&gt;
    &lt;solid android:color=&quot;@color/cyan_500&quot; /&gt;
    &lt;stroke
        android:width=&quot;1dp&quot;
        android:color=&quot;@color/black_alpha_32&quot; /&gt;
&lt;/shape&gt;
</code></pre><h5 id="u4E3B_u754C_u9762XML_RecyclerView"><a href="#u4E3B_u754C_u9762XML_RecyclerView" class="headerlink" title="主界面XML RecyclerView"></a>主界面XML RecyclerView</h5><pre><code>&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:paddingBottom=&quot;@dimen/activity_vertical_margin&quot;
    android:paddingLeft=&quot;@dimen/activity_horizontal_margin&quot;
    android:paddingRight=&quot;@dimen/activity_horizontal_margin&quot;
    android:paddingTop=&quot;@dimen/activity_vertical_margin&quot;
    tools:context=&quot;.MainActivity&quot;&gt;

    &lt;android.support.v7.widget.RecyclerView
        android:id=&quot;@+id/time_line_recycler&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:clickable=&quot;true&quot;
        android:fadeScrollbars=&quot;true&quot;
        android:fadingEdge=&quot;none&quot;
        android:focusable=&quot;true&quot;
        android:focusableInTouchMode=&quot;true&quot;
        android:overScrollMode=&quot;never&quot;
        android:scrollbarSize=&quot;2dp&quot;
        android:scrollbarThumbVertical=&quot;@color/cyan_500&quot;
        android:scrollbars=&quot;vertical&quot; /&gt;

&lt;/RelativeLayout&gt;
</code></pre><p>在这里就是加上了一个RecyclerView 控件在主界面就OK。</p>
<h5 id="Java_u4EE3_u7801_u90E8_u5206"><a href="#Java_u4EE3_u7801_u90E8_u5206" class="headerlink" title="Java代码部分"></a>Java代码部分</h5><p>在开始之前先来看看我们的文件具体有些神马。</p>
<p><img src="http://www.jcodecraeer.com/uploads/20150825/1440469609114998.png" alt=""></p>
<p>widget中就是具体的自定义控件，model是具体的数据模型，adapter部分，这里有一个Recyclerview的adapter文件，以及一个具体的Item TimeLineViewHolder，当然在这里还定义了一个ItemType类，该类用来标示每个Item的类型，比如头部，第一个，普通，最后一个，底部等等。</p>
<h6 id="TimeLineModel-java"><a href="#TimeLineModel-java" class="headerlink" title="TimeLineModel.java"></a>TimeLineModel.java</h6><pre><code>package net.qiujuer.example.timeline.model;

/**
 * Created by qiujuer
 * on 15/8/23.
 */
public class TimeLineModel {
    private String name;
    private int age;

    public TimeLineModel() {

    }

    public TimeLineModel(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public int getAge() {
        return age;
    }

    public String getName() {
        return name;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public void setName(String name) {
        this.name = name;
    }
}
</code></pre><p>一个名字，一个年龄也就OK。</p>
<h6 id="ItemType-java"><a href="#ItemType-java" class="headerlink" title="ItemType.java"></a>ItemType.java</h6><pre><code>package net.qiujuer.example.timeline.adapter;

/**
 * Created by qiujuer
 * on 15/8/23.
 */
public class ItemType {
    public final static int NORMAL = 0;

    public final static int HEADER = 1;
    public final static int FOOTER = 2;

    public final static int START = 4;
    public final static int END = 8;

    public final static int ATOM = 16;
}
</code></pre><p>分别定义了几个静态值，分别代表普通、头部、底部、开始、结束、原子；当然其中有些可以不用定义。</p>
<h6 id="TimeLineViewHolder-java"><a href="#TimeLineViewHolder-java" class="headerlink" title="TimeLineViewHolder.java"></a>TimeLineViewHolder.java</h6><pre><code>package net.qiujuer.example.timeline.adapter;

import android.support.v7.widget.RecyclerView;
import android.view.View;
import android.widget.TextView;

import net.qiujuer.example.timeline.R;
import net.qiujuer.example.timeline.model.TimeLineModel;
import net.qiujuer.example.timeline.widget.TimeLineMarker;

/**
 * Created by qiujuer
 * on 15/8/23.
 */
public class TimeLineViewHolder extends RecyclerView.ViewHolder {
    private TextView mName;

    public TimeLineViewHolder(View itemView, int type) {
        super(itemView);

        mName = (TextView) itemView.findViewById(R.id.item_time_line_txt);

        TimeLineMarker mMarker = (TimeLineMarker) itemView.findViewById(R.id.item_time_line_mark);
        if (type == ItemType.ATOM) {
            mMarker.setBeginLine(null);
            mMarker.setEndLine(null);
        } else if (type == ItemType.START) {
            mMarker.setBeginLine(null);
        } else if (type == ItemType.END) {
            mMarker.setEndLine(null);
        }

    }

    public void setData(TimeLineModel data) {
        mName.setText(&quot;Name:&quot; + data.getName() + &quot; Age:&quot; + data.getAge());
    }
}
</code></pre><p>该文件为RecyclerView 的Adapter中每个Item需要实现的Holder类。<br>在该类中，我们在构造函数中需要传入一个根View同时传入一个当然item的状态。<br>随后使用find….找到控件，在这里我们把TextView保存起来，而TimeLineView找到后直接进行初始化设置。<br>根据传入的ItemType来判断是否是第一个，最后一个，以及原子；然后设置TimeLineView的属性。<br>在下面的setData方法中我们显示具体的Model数据。</p>
<h6 id="TimeLineAdapter-java"><a href="#TimeLineAdapter-java" class="headerlink" title="TimeLineAdapter.java"></a>TimeLineAdapter.java</h6><p>适配器部分，我们需要做的工作是；根据具体的数据渲染上对应的界面就OK。</p>
<pre><code>package net.qiujuer.example.timeline.adapter;

import android.support.v7.widget.RecyclerView;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;

import net.qiujuer.example.timeline.R;
import net.qiujuer.example.timeline.model.TimeLineModel;

import java.util.List;

/**
 * Created by qiujuer
 * on 15/8/23.
 */
public class TimeLineAdapter extends RecyclerView.Adapter&lt;TimeLineViewHolder&gt; {
    private List&lt;TimeLineModel&gt; mDataSet;

    public TimeLineAdapter(List&lt;TimeLineModel&gt; models) {
        mDataSet = models;
    }

    @Override
    public int getItemViewType(int position) {
        final int size = mDataSet.size() - 1;
        if (size == 0)
            return ItemType.ATOM;
        else if (position == 0)
            return ItemType.START;
        else if (position == size)
            return ItemType.END;
        else return ItemType.NORMAL;
    }

    @Override
    public TimeLineViewHolder onCreateViewHolder(ViewGroup viewGroup, int viewType) {
        // Create a new view.
        View v = LayoutInflater.from(viewGroup.getContext())
                .inflate(R.layout.item_time_line, viewGroup, false);
        return new TimeLineViewHolder(v, viewType);
    }

    @Override
    public void onBindViewHolder(TimeLineViewHolder timeLineViewHolder, int i) {
        timeLineViewHolder.setData(mDataSet.get(i));
    }

    @Override
    public int getItemCount() {
        return mDataSet.size();
    }
}
</code></pre><blockquote>
<p>在这里需要着重说一下：我复写了getItemViewType方法；在该方法中我们需要设置对应的Item的类型；在这里传入的是item的坐标，需要返回的是item的具体状态，该状态标示是int类型；在这里我使用的是ItemType的静态属性。<br>该方法会在调用onCreateViewHolder方法之前调用；而onCreateViewHolder方法中的第二个参数int值也就是从getItemViewType之中来；所以我们可以在这里进行对应的数据状态标示。<br>而在onCreateViewHolder方法中我们返回一个：TimeLineViewHolder就OK，随后在onBindViewHolder方法中进行数据初始化操作。</p>
</blockquote>
<h6 id="MainActivity-java"><a href="#MainActivity-java" class="headerlink" title="MainActivity.java"></a>MainActivity.java</h6><p>上面所有都准备好了，下面就进行具体的显示。<br>在这里就只贴出核心代码了；篇幅也是有些长。</p>
<pre><code>private RecyclerView mRecycler;

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    mRecycler = (RecyclerView) findViewById(R.id.time_line_recycler);
    initRecycler();
}

private void initRecycler() {
    LinearLayoutManager layoutManager = new LinearLayoutManager(this);
    layoutManager.setOrientation(LinearLayoutManager.VERTICAL);

    TimeLineAdapter adapter = new TimeLineAdapter(getData());

    mRecycler.setLayoutManager(layoutManager);
    mRecycler.setAdapter(adapter);
}

private List&lt;TimeLineModel&gt; getData() {
    List&lt;TimeLineModel&gt; models = new ArrayList&lt;TimeLineModel&gt;();

    models.add(new TimeLineModel(&quot;XiaoMing&quot;, 21));
    models.add(new TimeLineModel(&quot;XiaoFang&quot;, 20));
    models.add(new TimeLineModel(&quot;XiaoHua&quot;, 25));
    models.add(new TimeLineModel(&quot;XiaoA&quot;, 22));
    models.add(new TimeLineModel(&quot;XiaoNiu&quot;, 23));

    return models;
}
</code></pre><p>在这里就是傻瓜的操作了，流程就是准备好对应的数据，装进Adapter，准备好对应的布局方式，然后都设置到RecyclerView中就OK。</p>
<h6 id="u6548_u679C-1"><a href="#u6548_u679C-1" class="headerlink" title="效果"></a>效果</h6><p>来看看具体的效果：</p>
<p><img src="http://www.jcodecraeer.com/uploads/20150825/1440469865127253.png" alt=""></p>
<p>效果虽然简单，但是也算是五脏具全；其中无非就是控件的自定义。这个自定义是可以扩展的，大家可以扩展为水平方向试试。</p>
<h6 id="u4EE3_u7801"><a href="#u4EE3_u7801" class="headerlink" title="代码"></a>代码</h6><p>博客代码都开源到项目中了。<br>地址：<a href="https://github.com/qiujuer/BeFoot/tree/master/blog/sample/TimeLine" target="_blank" rel="external">https://github.com/qiujuer/BeFoot/tree/master/blog/sample/TimeLine</a></p>
<h6 id="u5199_u5728_u6700_u540E"><a href="#u5199_u5728_u6700_u540E" class="headerlink" title="写在最后"></a>写在最后</h6><p>文章的开始截屏来源于：最近没事儿捣鼓了一个APP［UPMiss］，一个简单的生日，纪念日提醒软件；欢迎大家尝鲜。</p>
<hr>
<p>转载出处：<a href="http://blog.csdn.net/qiujuer/article/details/47910185" target="_blank" rel="external">http://blog.csdn.net/qiujuer/article/details/47910185</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>看见很多软件中都有时间线的东西，貌似天气啊，旅游啊什么的最多了；具体实现方式很多，在本篇文章中讲解一种自定义View封装的方式。</p>
<h3 id="u6548_u679C"><a href="#u6548_u679C" class="headerlink" title="效果"></a>效果</h3><p>先来看看效果。<br><img src="http://www.jcodecraeer.com/uploads/20150825/1440469250572021.png" alt=""><br>]]>
    
    </summary>
    
      <category term="时间轴" scheme="http://yoursite.com/tags/%E6%97%B6%E9%97%B4%E8%BD%B4/"/>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[亮点和不足]]></title>
    <link href="http://yoursite.com/2015/11/21/3.5%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E4%BA%AE%E7%82%B9%E5%92%8C%E4%B8%8D%E8%B6%B3/"/>
    <id>http://yoursite.com/2015/11/21/3.5开发中的亮点和不足/</id>
    <published>2015-11-20T18:33:45.000Z</published>
    <updated>2016-02-19T08:25:42.000Z</updated>
    <content type="html"><![CDATA[<h3 id="1_u3001_u4E00_u952E_u52A0_u6CB9_u7684_u6570_u636E_u7F13_u5B58_u64CD_u4F5C"><a href="#1_u3001_u4E00_u952E_u52A0_u6CB9_u7684_u6570_u636E_u7F13_u5B58_u64CD_u4F5C" class="headerlink" title="1、一键加油的数据缓存操作"></a>1、一键加油的数据缓存操作</h3><ul>
<li><p>添加缓存</p>
<pre><code>原因：
    开发过程，由于测试服务器的网络带宽，客户端请求数据超级慢，用户的体验非常不好。
工具：
    sharedPreference：
流程：
    1、将一键加油的数据，在进入到主页的时候，进行请求完成，将JSON,时间，当前请求的位置等数据缓存到本地
    2、在进入到一键加油的流程时候，先拿到本地缓存的数据，对时间和位置进行对比，时间超过5分钟，位置移动超过20m，都会重新向服务器请求数据。
    3、在首页生命周期走到onStop()方法时候，将缓存数据进行致空（json=&quot;&quot;;）操作。
    4、3的操作，保证每次打开首页进入到一键加油流程都是最新的数据，同样也保证再次回到首页的时候，在网络情况差，请求不到数据的情况，不会使用上一次缓存的数据
优点：
    优化用户体验，节省流量
缺点：暂未发现
</code></pre></li>
</ul>
<a id="more"></a>
<h3 id="2_u3001_u70ED_u4FEE_u590D_u529F_u80FD_u7684_u662F_u5B9E_u73B0"><a href="#2_u3001_u70ED_u4FEE_u590D_u529F_u80FD_u7684_u662F_u5B9E_u73B0" class="headerlink" title="2、热修复功能的是实现"></a>2、热修复功能的是实现</h3><ul>
<li><p>添加的热修复框架</p>
<pre><code>来源：
    使用的是阿里开源的一个Android热补丁框架（AndFix）
功能：
    允许APP在不重新发布版本的情况下修复线上的bug。
原理：
    apkpatch将两个apk做一次对比，然后找出不同的部分。可以看到生成的apatch了文件，后缀改成zip再解压开，里面有一个dex文件。通过jadx查看一下源码，
    里面就是被修复的代码所在的类文件,这些更改过的类都加上了一个_CF的后缀，并且变动的方法都被加上了一个叫@MethodReplace的annotation，
    通过clazz和method指定了需要替换的方法。然后客户端sdk得到补丁文件后就会根据annotation来寻找需要替换的方法。最后由JNI层完成方法的替换。
优点：
    1、不需要重启APP即可应用补丁。
    2、安全性更好，Nuwa后面的版本应该也会加上安全方面的内容。
支持：
    Android 2.3 到 6.0。
格式：
    .apatch
安全：
    必须使用签名工具进行操作生成的apatch文件，才能进行patch操作
局限：
    1、不支持YunOS
    2、无法添加新类和新的字段
    3、需要使用加固前的apk制作补丁，但是补丁文件很容易被反编译，也就是修改过的类源码容易泄露。
    4、使用加固平台可能会使热补丁功能失效（看到有人在360加固提了这个问题，自己还未验证）。
缺点：
    无法添加类和字段
使用：
    打补丁的过程，首先生成一个apk文件，然后更改代码，在修复bug后生成另一个apk。
    通过官方提供的工具apkpatch
    生成一个.apatch格式的补丁文件，需要提供原apk，修复后的apk，以及一个签名文件。
    可以直接使用命令apkpatch查看具体的使用方法。
</code></pre></li>
</ul>
<h3 id="3-_u5F00_u53D1_u4E2D_u4E00_u952E_u52A0_u6CB9_u7684_u903B_u8F91_u8003_u8651"><a href="#3-_u5F00_u53D1_u4E2D_u4E00_u952E_u52A0_u6CB9_u7684_u903B_u8F91_u8003_u8651" class="headerlink" title="3.开发中一键加油的逻辑考虑"></a>3.开发中一键加油的逻辑考虑</h3><p>*</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copyright (c) 2015 Copyright Holder All Rights Reserved.</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1_u3001_u4E00_u952E_u52A0_u6CB9_u7684_u6570_u636E_u7F13_u5B58_u64CD_u4F5C"><a href="#1_u3001_u4E00_u952E_u52A0_u6CB9_u7684_u6570_u636E_u7F13_u5B58_u64CD_u4F5C" class="headerlink" title="1、一键加油的数据缓存操作"></a>1、一键加油的数据缓存操作</h3><ul>
<li><p>添加缓存</p>
<pre><code>原因：
    开发过程，由于测试服务器的网络带宽，客户端请求数据超级慢，用户的体验非常不好。
工具：
    sharedPreference：
流程：
    1、将一键加油的数据，在进入到主页的时候，进行请求完成，将JSON,时间，当前请求的位置等数据缓存到本地
    2、在进入到一键加油的流程时候，先拿到本地缓存的数据，对时间和位置进行对比，时间超过5分钟，位置移动超过20m，都会重新向服务器请求数据。
    3、在首页生命周期走到onStop()方法时候，将缓存数据进行致空（json=&quot;&quot;;）操作。
    4、3的操作，保证每次打开首页进入到一键加油流程都是最新的数据，同样也保证再次回到首页的时候，在网络情况差，请求不到数据的情况，不会使用上一次缓存的数据
优点：
    优化用户体验，节省流量
缺点：暂未发现
</code></pre></li>
</ul>]]>
    
    </summary>
    
      <category term="反思" scheme="http://yoursite.com/tags/%E5%8F%8D%E6%80%9D/"/>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ActionBar沉浸式实现]]></title>
    <link href="http://yoursite.com/2015/10/09/ActionBar%E6%B2%89%E6%B5%B8%E5%BC%8F%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2015/10/09/ActionBar沉浸式实现/</id>
    <published>2015-10-09T13:56:17.000Z</published>
    <updated>2016-02-23T04:22:02.000Z</updated>
    <content type="html"><![CDATA[<p>studio，中引入沉浸式兼容库 <code>compile &#39;com.readystatesoftware.systembartint:systembartint:1.0.3&#39;</code><br>eclipse，可以导入相应的那个类。</p>
<h3 id="u7B2C_u4E00_u7C7B_uFF0C_u517C_u5BB9actionbar"><a href="#u7B2C_u4E00_u7C7B_uFF0C_u517C_u5BB9actionbar" class="headerlink" title="第一类，兼容actionbar"></a>第一类，兼容actionbar</h3><ul>
<li><p>第一步：设置activity主题android:theme=”@style/ActionBarTheme”</p>
<a id="more"></a>
  <style name="ActionBarTheme" parent="android:Theme.Holo.Light.DarkActionBar">
    <!--API 14 themecustomizationscangohere. -->
    <item name="android:actionBarStyle">@style/ActionBarStyle</item>
  </style>
  <style name="ActionBarStyle" parent="android:Widget.Holo.Light.ActionBar.Solid.Inverse">
    <item name="android:background">@color/actionbar_bg</item>
  </style>
</li>
<li><p>第二步：设置状态栏透明，然后设置状态栏沉浸的颜色</p>
</li>
</ul>
<pre><code>@TargetApi(19)
private void setTranslucentStatus(boolean on) {
Window win = getWindow();
WindowManager.LayoutParams winParams = win.getAttributes();
final int bits = WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS;
    if (on) {
            winParams.flags |= bits;
        } else {
            winParams.flags &amp;= ~bits;
        }
        win.setAttributes(winParams);
    }
@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main);

if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) {
            setTranslucentStatus(true);
        }

SystemBarTintManager tintManager = new SystemBarTintManager(this);
tintManager.setStatusBarTintEnabled(true);
//设置沉浸的颜色        
tintManager.setStatusBarTintResource(R.color.statusbar_bg);
}
</code></pre><ul>
<li>第三步：设置适应windows，在布局文件设置</li>
</ul>
<pre><code>android:fitsSystemWindows=”true”
如果不设置，应用的ui会顶上去，顶进system ui
ok
</code></pre><h3 id="u7B2C_u4E8C_u7C7B__u6CA1_u6709actionbar_u7684activity"><a href="#u7B2C_u4E8C_u7C7B__u6CA1_u6709actionbar_u7684activity" class="headerlink" title="第二类 没有actionbar的activity"></a>第二类 没有actionbar的activity</h3><ul>
<li>第一步，设置主题，android:theme=”@style/FullBleedTheme”</li>
</ul>
<pre><code>&lt;stylename=&quot;FullBleedTheme&quot;parent=&quot;android:Theme.Holo.Light.NoActionBar&quot;&gt;
&lt;!--API 14 themecustomizationscangohere. --&gt;
&lt;/style&gt;
&lt;stylename=&quot;FullBleedTheme&quot;parent=&quot;android:Theme.Holo.Light.NoActionBar.TranslucentDecor&quot;&gt;
&lt;!--API 19 themecustomizationscangohere. --&gt;
&lt;/style&gt;
</code></pre><blockquote>
<p>或者用toolbar只能设置Theme.AppCompat.NoActionBar主题</p>
</blockquote>
<pre><code>&lt;style name=&quot;AppThemeToolbar&quot; parent=&quot;Theme.AppCompat.NoActionBar&quot;&gt;
    &lt;itemname=&quot;colorPrimary&quot;&gt;#2196F3&lt;/item&gt;
    &lt;itemname=&quot;colorPrimaryDark&quot;&gt;#2196F3&lt;/item&gt;
    &lt;!--&lt;item name=&quot;colorPrimaryDark&quot;&gt;#1565C0&lt;/item&gt;--&gt;
    &lt;itemname=&quot;colorAccent&quot;&gt;#E91E63&lt;/item&gt;
&lt;/style&gt;
</code></pre><ul>
<li>第二步：同上一个第二步。<br>设置状态栏透明+颜色</li>
</ul>
<pre><code>mTintManager = new SystemBarTintManager(this);
mTintManager.setStatusBarTintEnabled(true);
mTintManager.setNavigationBarTintEnabled(true);  mTintManager.setStatusBarTintResource(R.color.statusbar_bg);
</code></pre><ul>
<li>第三步：</li>
</ul>
<pre><code>android:fitsSystemWindows=”true”
android:clipToPadding=”false
&lt;item name=&quot;android:fitsSystemWindows&quot;&gt;true&lt;/item&gt;
&lt;item name=&quot;android:clipToPadding&quot;&gt;false&lt;/item&gt;```
</code></pre><h3 id="u53EF_u80FD_u51FA_u73B0_u7684_u95EE_u9898"><a href="#u53EF_u80FD_u51FA_u73B0_u7684_u95EE_u9898" class="headerlink" title="可能出现的问题"></a>可能出现的问题</h3><ul>
<li>android:fitsSystemWindows属性的奇怪问题</li>
</ul>
<blockquote>
<p>官方解释是布局的时候是否考虑系统的状态栏，标题栏，通知栏之类的。</p>
<p>我的实际使用是，为true：那么布局的时候会把系统的状态栏，标题栏，通知栏的高度考虑进去。布局的内容会在状态栏，标题栏，通知栏的下面，不会被遮挡。</p>
<p>但是在项目开发的过程中，突然发现对话框，AlertDialog的内容会超出背景大小，ProgressDialog的内容会超出背景大小并且不居中。</p>
<p>也是很偶然才发现是这个属性造成的。我也没理清楚，大概是这个属性也使对话框考虑了系统的一些元素的缘故。</p>
<p>所以我们在使用这个属性的时候不用直接把这个属性加到theme中。在相关的布局layout中使用就可以了。</p>
</blockquote>
<ul>
<li>Android Toast显示文字超出了背景，文字布局中</li>
</ul>
<blockquote>
<p>项目中突然出现了上述的情况，先开始以为是theme的问题，但是查了很久的资料，也做了很多实验，但是没有效果，还是之前的样子。一个很偶然的情况，<code>Toast.makeText(getActivity(), “密码不可为空”,Toast.LENGTH_SHORT).show();</code>改成了<code>Toast.makeText(App.getInstance(), “密码不可为空”,Toast.LENGTH_SHORT).show();</code>发现就可以了。</p>
<p>别问我，我也不知道原因。</p>
<p>但是这提醒我们，以后的Toast 的上下文参数，直接用ApplicationContext就对了。</p>
</blockquote>
<p>Copyright (c) 2016 Copyright Holder All Rights Reserved.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>studio，中引入沉浸式兼容库 <code>compile &#39;com.readystatesoftware.systembartint:systembartint:1.0.3&#39;</code><br>eclipse，可以导入相应的那个类。</p>
<h3 id="u7B2C_u4E00_u7C7B_uFF0C_u517C_u5BB9actionbar"><a href="#u7B2C_u4E00_u7C7B_uFF0C_u517C_u5BB9actionbar" class="headerlink" title="第一类，兼容actionbar"></a>第一类，兼容actionbar</h3><ul>
<li><p>第一步：设置activity主题android:theme=”@style/ActionBarTheme”</p>]]>
    
    </summary>
    
      <category term="沉浸式" scheme="http://yoursite.com/tags/%E6%B2%89%E6%B5%B8%E5%BC%8F/"/>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android注解(Annotation)自定义注解入门]]></title>
    <link href="http://yoursite.com/2015/07/22/%E6%B3%A8%E8%A7%A3(Annotation)%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2015/07/22/注解(Annotation)自定义注解入门/</id>
    <published>2015-07-22T15:12:17.000Z</published>
    <updated>2016-02-19T09:06:01.000Z</updated>
    <content type="html"><![CDATA[<p>要深入学习注解，我们就必须能定义自己的注解，并使用注解，在定义自己的注解之前，我们就必须要了解Java为我们提供的元注解和相关定义注解的语法。</p>
<p>元注解：<br>元注解的作用就是负责注解其他注解。Java5.0定义了4个标准的<code>meta-annotation</code>类型，它们被用来提供对其它 <code>annotation</code>类型作说明。Java5.0定义的元注解：<a id="more"></a></p>
<pre><code>1.@Target,
2.@Retention,
3.@Documented,
4.@Inherited
</code></pre><p>这些类型和它们所支持的类在<code>java.lang.annotation</code>包中可以找到。下面我们看一下每个元注解的作用和相应分参数的使用说明。</p>
<h4 id="@Target_uFF1A"><a href="#@Target_uFF1A" class="headerlink" title="@Target："></a>@Target：</h4><blockquote>
<p>@Target说明了Annotation所修饰的对象范围：Annotation可被用于 packages、types（类、接口、枚举、Annotation类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数）。在Annotation类型的声明中使用了target可更加明晰其修饰的目标。<br>作用：用于描述注解的使用范围（即：被描述的注解可以用在什么地方）<br>取值(ElementType)有：</p>
<ul>
<li>1.CONSTRUCTOR:用于描述构造器</li>
<li>2.FIELD:用于描述域</li>
<li>3.LOCAL_VARIABLE:用于描述局部变量</li>
<li>4.METHOD:用于描述方法</li>
<li>5.PACKAGE:用于描述包</li>
<li>6.PARAMETER:用于描述参数</li>
<li>7.TYPE:用于描述类、接口(包括注解类型) 或enum声明</li>
</ul>
</blockquote>
<p>使用实例：</p>
<pre><code>@Target(ElementType.TYPE)
public @interface Table {
    /**
     * 数据表名称注解，默认值为类名称
     * @return
     */
    public String tableName() default &quot;className&quot;;
}
@Target(ElementType.FIELD)
public @interface NoDBColumn {
}
</code></pre><h3 id="u6CE8_u89E3Table"><a href="#u6CE8_u89E3Table" class="headerlink" title="注解Table"></a>注解Table</h3><p>可以用于注解类、接口(包括注解类型) 或enum声明,而注解NoDBColumn仅可用于注解类的成员变量。</p>
<h4 id="@Retention_uFF1A"><a href="#@Retention_uFF1A" class="headerlink" title="@Retention："></a>@Retention：</h4><blockquote>
<p>@Retention定义了该Annotation被保留的时间长短：某些Annotation仅出现在源代码中，而被编译器丢弃；而另一些却被编译在class文件中；编译在class文件中的Annotation可能会被虚拟机忽略，而另一些在class被装载时将被读取（请注意并不影响class的执行，因为Annotation与class在使用上是被分离的）。使用这个meta-Annotation可以对 Annotation的“生命周期”限制。<br>作用：表示需要在什么级别保存该注释信息，用于描述注解的生命周期（即：被描述的注解在什么范围内有效）<br>取值（RetentionPoicy）有：</p>
<ul>
<li>1.SOURCE:在源文件中有效（即源文件保留）</li>
<li>2.CLASS:在class文件中有效（即class保留）</li>
<li>3.RUNTIME:在运行时有效（即运行时保留）</li>
</ul>
</blockquote>
<h4 id="Retention"><a href="#Retention" class="headerlink" title="Retention"></a>Retention</h4><blockquote>
<p>meta-annotation类型有唯一的value作为成员，它的取值来自java.lang.annotation.RetentionPolicy的枚举类型值。具体实例如下：</p>
</blockquote>
<pre><code>@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Column {
    public String name() default &quot;fieldName&quot;;
    public String setFuncName() default &quot;setField&quot;;
    public String getFuncName() default &quot;getField&quot;;
    public boolean defaultDBValue() default false;
}
</code></pre><blockquote>
<p>Column注解的的RetentionPolicy的属性值是RUTIME,这样注解处理器可以通过反射，获取到该注解的属性值，从而去做一些运行时的逻辑处理</p>
</blockquote>
<h4 id="@Documented_3A"><a href="#@Documented_3A" class="headerlink" title="@Documented:"></a>@Documented:</h4><p>@Documented用于描述其它类型的annotation应该被作为被标注的程序成员的公共API，因此可以被例如javadoc此类的工具文档化。Documented是一个标记注解，没有成员。</p>
<pre><code>@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Column {
    public String name() default &quot;fieldName&quot;;
    public String setFuncName() default &quot;setField&quot;;
    public String getFuncName() default &quot;getField&quot;;
    public boolean defaultDBValue() default false;
}
</code></pre><h4 id="@Inherited_uFF1A"><a href="#@Inherited_uFF1A" class="headerlink" title="@Inherited："></a>@Inherited：</h4><p>@Inherited 元注解是一个标记注解，@Inherited阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类。</p>
<blockquote>
<p>注意：@Inherited annotation类型是被标注过的class的子类所继承。类并不从它所实现的接口继承annotation，方法并不从它所重载的方法继承annotation。<br>当@Inherited annotation类型标注的annotation的Retention是RetentionPolicy.RUNTIME，则反射API增强了这种继承性。如果我们使用java.lang.reflect去查询一个@Inherited annotation类型的annotation时，反射代码检查将展开工作：检查class和其父类，直到发现指定的annotation类型被发现，或者到达类继承结构的顶层。</p>
</blockquote>
<p>实例代码：</p>
<pre><code>/**
 *
 * @author peida
 *
 */
@Inherited
public @interface Greeting {
    public enum FontColor{ BULE,RED,GREEN};
    String name();
    FontColor fontColor() default FontColor.GREEN;
}
</code></pre><h3 id="u81EA_u5B9A_u4E49_u6CE8_u89E3_uFF1A"><a href="#u81EA_u5B9A_u4E49_u6CE8_u89E3_uFF1A" class="headerlink" title="自定义注解："></a>自定义注解：</h3><blockquote>
<p>使用@interface自定义注解时，自动继承了java.lang.annotation.Annotation接口，由编译程序自动完成其他细节。在定义注解时，不能继承其他的注解或接口。@interface用来声明一个注解，其中的每一个方法实际上是声明了一个配置参数。方法的名称就是参数的名称，返回值类型就是参数的类型（返回值类型只能是基本类型、Class、String、enum）。可以通过default来声明参数的默认值。</p>
</blockquote>
<hr>
<blockquote>
<p>定义注解格式：<br>public @interface 注解名 {定义体}</p>
</blockquote>
<hr>
<blockquote>
<p>注解参数的可支持数据类型：</p>
</blockquote>
<ul>
<li>1.所有基本数据类型（int,float,boolean,byte,double,char,long,short)</li>
<li>2.String类型</li>
<li>3.Class类型</li>
<li>4.enum类型</li>
<li>5.Annotation类型</li>
<li>6.以上所有类型的数组</li>
</ul>
<p>Annotation类型里面的参数该怎么设定:</p>
<blockquote>
<p>第一,只能用public或默认(default)这两个访问权修饰.例如,String value();这里把方法设为defaul默认类型；</p>
</blockquote>
<hr>
<blockquote>
<p>第二,参数成员只能用基本类型byte,short,char,int,long,float,double,boolean八种基本数据类型和 String,Enum,Class,annotations等数据类型,以及这一些类型的数组.例如,String value();这里的参数成员就为String;</p>
</blockquote>
<hr>
<blockquote>
<p>第三,如果只有一个参数成员,最好把参数名称设为”value”,后加小括号.例:下面的例子FruitName注解就只有一个参数成员。</p>
</blockquote>
<hr>
<p>简单的自定义注解和使用注解实例：</p>
<pre><code>package annotation;
import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * 水果名称注解
 * @author peida
 *
 */
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface FruitName {
    String value() default &quot;&quot;;
}
</code></pre><hr>
<pre><code>package annotation;
import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * 水果颜色注解
 * @author peida
 *
 */
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface FruitColor {
    /**
     * 颜色枚举
     * @author peida
     *
     */
    public enum Color{ BULE,RED,GREEN};

    /**
     * 颜色属性
     * @return
     */
    Color fruitColor() default Color.GREEN;
}
</code></pre><hr>
<pre><code>package annotation;
import annotation.FruitColor.Color;
public class Apple {

    @FruitName(&quot;Apple&quot;)
    private String appleName;

    @FruitColor(fruitColor=Color.RED)
    private String appleColor;




    public void setAppleColor(String appleColor) {
        this.appleColor = appleColor;
    }
    public String getAppleColor() {
        return appleColor;
    }


    public void setAppleName(String appleName) {
        this.appleName = appleName;
    }
    public String getAppleName() {
        return appleName;
    }

    public void displayName(){
        System.out.println(&quot;水果的名字是：苹果&quot;);
    }
}
</code></pre><h4 id="u6CE8_u89E3_u5143_u7D20_u7684_u9ED8_u8BA4_u503C_uFF1A"><a href="#u6CE8_u89E3_u5143_u7D20_u7684_u9ED8_u8BA4_u503C_uFF1A" class="headerlink" title="注解元素的默认值："></a>注解元素的默认值：</h4><blockquote>
<p>注解元素必须有确定的值，要么在定义注解的默认值中指定，要么在使用注解时指定，非基本类型的注解元素的值不可为null。因此, 使用空字符串或0作为默认值是一种常用的做法。这个约束使得处理器很难表现一个元素的存在或缺失的状态，因为每个注解的声明中，所有元素都存在，并且都具有相应的值，为了绕开这个约束，我们只能定义一些特殊的值，例如空字符串或者负数，一次表示某个元素不存在，在定义注解时，这已经成为一个习惯用法。</p>
</blockquote>
<p>例如：</p>
<pre><code> 1 package annotation;
 2
 3 import java.lang.annotation.Documented;
 4 import java.lang.annotation.ElementType;
 5 import java.lang.annotation.Retention;
 6 import java.lang.annotation.RetentionPolicy;
 7 import java.lang.annotation.Target;
 8
 9 /**
10  * 水果供应者注解
11  * @author peida
12  *
13  */
14 @Target(ElementType.FIELD)
15 @Retention(RetentionPolicy.RUNTIME)
16 @Documented
17 public @interface FruitProvider {
18     /**
19      * 供应商编号
20      * @return
21      */
22     public int id() default -1;
23     
24     /**
25      * 供应商名称
26      * @return
27      */
28     public String name() default &quot;&quot;;
29     
30     /**
31      * 供应商地址
32      * @return
33      */
34     public String address() default &quot;&quot;;
35 }
</code></pre><blockquote>
<p>定义了注解，并在需要的时候给相关类，类属性加上注解信息，如果没有响应的注解信息处理流程，注解可以说是没有实用价值。如何让注解真真的发挥作用，主要就在于注解处理方法，下一步我们将学习注解信息的获取和处理！</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>要深入学习注解，我们就必须能定义自己的注解，并使用注解，在定义自己的注解之前，我们就必须要了解Java为我们提供的元注解和相关定义注解的语法。</p>
<p>元注解：<br>元注解的作用就是负责注解其他注解。Java5.0定义了4个标准的<code>meta-annotation</code>类型，它们被用来提供对其它 <code>annotation</code>类型作说明。Java5.0定义的元注解：]]>
    
    </summary>
    
      <category term="Annotation" scheme="http://yoursite.com/tags/Annotation/"/>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android OkHttp完全解析]]></title>
    <link href="http://yoursite.com/2015/07/21/Android%20OkHttp%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2015/07/21/Android OkHttp完全解析/</id>
    <published>2015-07-21T05:56:17.000Z</published>
    <updated>2016-02-19T09:08:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u4E00_u3001_u6982_u8FF0"><a href="#u4E00_u3001_u6982_u8FF0" class="headerlink" title="一、概述"></a>一、概述</h2><blockquote>
<p>最近在群里听到各种讨论okhttp的话题，可见okhttp的口碑相当好了。再加上Google貌似在6.0版本里面删除了HttpClient相关API，对于这个行为不做评价。为了更好的在应对网络访问，学习下okhttp还是蛮必要的，本篇博客首先介绍okhttp的简单使用，主要包含：</p>
</blockquote>
<a id="more"></a>
<pre><code>• 一般的get请求
• 一般的post请求
• 基于Http的文件上传
• 文件下载
• 加载图片
• 支持请求回调，直接返回对象、对象集合
• 支持session的保持
</code></pre><p>最后会对上述几个功能进行封装，完整的封装类的地址见：<code>https://github.com/hongyangAndroid/okhttp-utils</code><br>使用前，对于Android Studio的用户，可以选择添加:<br><code>compile &#39;com.squareup.okhttp:okhttp:2.4.0&#39;</code></p>
<p>或者Eclipse的用户，可以下载最新的jar okhttp he latest JAR ，添加依赖就可以用了。<br>注意:okhttp内部依赖okio，别忘了同时导入okio：<br><code>gradle: compile &#39;com.squareup.okio:okio:1.5.0&#39;</code></p>
<h2 id="u4E8C_u3001_u4F7F_u7528_u6559_u7A0B"><a href="#u4E8C_u3001_u4F7F_u7528_u6559_u7A0B" class="headerlink" title="二、使用教程"></a>二、使用教程</h2><h3 id="uFF08_u4E00_uFF09Http_Get"><a href="#uFF08_u4E00_uFF09Http_Get" class="headerlink" title="（一）Http Get"></a>（一）Http Get</h3><p>对了网络加载库，那么最常见的肯定就是http get请求了，比如获取一个网页的内容。</p>
<pre><code>//创建okHttpClient对象
OkHttpClient mOkHttpClient = new OkHttpClient();
//创建一个Request
final Request request = new Request.Builder()
                .url(&quot;https://github.com/hongyangAndroid&quot;)
                .build();
//new call
Call call = mOkHttpClient.newCall(request);
//请求加入调度
call.enqueue(new Callback()
        {
            @Override
            public void onFailure(Request request, IOException e)
            {
            }
@Override
            public void onResponse(final Response response) throws IOException
            {
                    //String htmlStr =  response.body().string();
            }
        });
</code></pre><h4 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h4><p> 以上就是发送一个get请求的步骤，首先构造一个Request对象，参数最起码有个url，当然你可以通过Request.Builder设置更多的参数比如：header、method等。</p>
<h4 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h4><p> 然后通过request的对象去构造得到一个Call对象，类似于将你的请求封装成了任务，既然是任务，就会有execute()和cancel()等方法。</p>
<h4 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h4><p> 最后，我们希望以异步的方式去执行请求，所以我们调用的是call.enqueue，将call加入调度队列，然后等待任务执行完成，我们在Callback中即可得到结果。<br>看到这，你会发现，整体的写法还是比较长的，所以封装肯定是要做的，不然每个请求这么写，得累死。</p>
<h4 id="ok_uFF0C_u9700_u8981_u6CE8_u610F_u51E0_u70B9_uFF1A"><a href="#ok_uFF0C_u9700_u8981_u6CE8_u610F_u51E0_u70B9_uFF1A" class="headerlink" title="ok，需要注意几点："></a>ok，需要注意几点：</h4><ul>
<li>onResponse回调的参数是response，一般情况下，比如我们希望获得返回的字符串，可以通过<code>response.body().string()``获取；如果希望获得返回的二进制字节数组，则调用</code>response.body().bytes()<code>；如果你想拿到返回的inputStream，则调用`response.body().byteStream()</code><br>看到这，你可能会奇怪，竟然还能拿到返回的<code>inputStream</code>，看到这个最起码能意识到一点，这里支持大文件下载，有<code>inputStream</code>我们就可以通过IO的方式写文件。不过也说明一个问题，这个<code>onResponse</code>执行的线程并不是UI线程。的确是的，如果你希望操作控件，还是需要使用<code>handler</code>等，例如：</li>
</ul>
<pre><code>@Override
public void onResponse(final Response response) throws IOException
{
      final String res = response.body().string();
      runOnUiThread(new Runnable()
      {
          @Override
          public void run()
          {
            mTv.setText(res);
          }

});
}
</code></pre><p> 我们这里是异步的方式去执行，当然也支持阻塞的方式，上面我们也说了Call有一个execute()方法，你也可以直接调用<code>call.execute()</code>通过返回一个Response。</p>
<h3 id="28_u4E8C_29_Http_Post__u643A_u5E26_u53C2_u6570"><a href="#28_u4E8C_29_Http_Post__u643A_u5E26_u53C2_u6570" class="headerlink" title="(二) Http Post 携带参数"></a>(二) Http Post 携带参数</h3><p>看来上面的简单的get请求，基本上整个的用法也就掌握了，比如post携带参数，也仅仅是Request的构造的不同。</p>
<pre><code>Request request = buildMultipartFormRequest(
        url, new File[]{file}, new String[]{fileKey}, null);
FormEncodingBuilder builder = new FormEncodingBuilder();
builder.add(&quot;username&quot;,&quot;张鸿洋&quot;);
Request request = new Request.Builder()
                   .url(url)
                .post(builder.build())
                .build();
 mOkHttpClient.newCall(request).enqueue(new Callback(){});
</code></pre><p>大家都清楚，post的时候，参数是包含在请求体中的；所以我们通过<code>FormEncodingBuilder</code>。添加多个String键值对，然后去构造<code>RequestBody</code>，最后完成我们Request的构造。<br>后面的就和上面一样了。</p>
<h3 id="uFF08_u4E09_uFF09_u57FA_u4E8EHttp_u7684_u6587_u4EF6_u4E0A_u4F20"><a href="#uFF08_u4E09_uFF09_u57FA_u4E8EHttp_u7684_u6587_u4EF6_u4E0A_u4F20" class="headerlink" title="（三）基于Http的文件上传"></a>（三）基于Http的文件上传</h3><p>接下来我们在介绍一个可以构造RequestBody的Builder，叫做<code>MultipartBuilder</code>。当我们需要做类似于表单上传的时候，就可以使用它来构造我们的requestBody。</p>
<pre><code>File file = new File(Environment.getExternalStorageDirectory(), &quot;balabala.mp4&quot;);
RequestBody fileBody = RequestBody.create(MediaType.parse(&quot;application/octet-stream&quot;), file);
RequestBody requestBody = new MultipartBuilder()
     .type(MultipartBuilder.FORM)
     .addPart(Headers.of(
          &quot;Content-Disposition&quot;,
              &quot;form-data; name=\&quot;username\&quot;&quot;),
          RequestBody.create(null, &quot;张鸿洋&quot;))
     .addPart(Headers.of(
         &quot;Content-Disposition&quot;,
         &quot;form-data; name=\&quot;mFile\&quot;;
         filename=\&quot;wjd.mp4\&quot;&quot;), fileBody)
     .build();
Request request = new Request.Builder()
    .url(&quot;http://192.168.1.103:8080/okHttpServer/fileUpload&quot;)
    .post(requestBody)
    .build();
Call call = mOkHttpClient.newCall(request);
call.enqueue(new Callback()
{
    //...
});
</code></pre><p>上述代码向服务器传递了一个键值对username:张鸿洋和一个文件。我们通过MultipartBuilder的addPart方法可以添加键值对或者文件。<br>其实类似于我们拼接模拟浏览器行为的方式，如果你对这块不了解，可以参考：从原理角度解析Android （Java） http 文件上传<br>ok，对于我们最开始的目录还剩下图片下载，文件下载；这两个一个是通过回调的Response拿到byte[]然后decode成图片；文件下载，就是拿到inputStream做写文件操作，我们这里就不赘述了。</p>
<p>接下来我们主要看如何封装上述的代码。</p>
<h2 id="u4E09_u3001_u5C01_u88C5"><a href="#u4E09_u3001_u5C01_u88C5" class="headerlink" title="三、封装"></a>三、封装</h2><p>由于按照上述的代码，写多个请求肯定包含大量的重复代码，所以我希望封装后的代码调用是这样的：</p>
<h3 id="uFF08_u4E00_uFF09_u4F7F_u7528"><a href="#uFF08_u4E00_uFF09_u4F7F_u7528" class="headerlink" title="（一）使用"></a>（一）使用</h3><h4 id="4-__u4E00_u822C_u7684get_u8BF7_u6C42"><a href="#4-__u4E00_u822C_u7684get_u8BF7_u6C42" class="headerlink" title="4. 一般的get请求"></a>4. 一般的get请求</h4><pre><code> OkHttpClientManager.getAsyn(&quot;https://www.baidu.com&quot;, new OkHttpClientManager.ResultCallback&lt;String&gt;()
        {
            @Override
            public void onError(Request request, Exception e)
            {
                e.printStackTrace();
            }

@Override
            public void onResponse(String u)
            {
                mTv.setText(u);//注意这里是UI线程
            }
        });
</code></pre><p>对于一般的请求，我们希望给个url，然后CallBack里面直接操作控件。</p>
<h4 id="5-__u6587_u4EF6_u4E0A_u4F20_u4E14_u643A_u5E26_u53C2_u6570"><a href="#5-__u6587_u4EF6_u4E0A_u4F20_u4E14_u643A_u5E26_u53C2_u6570" class="headerlink" title="5. 文件上传且携带参数"></a>5. 文件上传且携带参数</h4><p>我们希望提供一个方法，传入url,params,file,callback即可。</p>
<pre><code> OkHttpClientManager.postAsyn(&quot;http://192.168.1.103:8080/okHttpServer/fileUpload&quot;,//
    new OkHttpClientManager.ResultCallback&lt;String&gt;()
    {
        @Override
        public void onError(Request request, IOException e)
        {
            e.printStackTrace();
        }

@Override
        public void onResponse(String result)
        {

}
    },//
    file,//
    &quot;mFile&quot;,//
    new OkHttpClientManager.Param[]{
            new OkHttpClientManager.Param(&quot;username&quot;, &quot;zhy&quot;),
            new OkHttpClientManager.Param(&quot;password&quot;, &quot;123&quot;)}
        );
</code></pre><p>键值对没什么说的，参数3为file，参数4为file对应的name，这个name不是文件的名字；<br>对应于http中的</p>
<pre><code>&lt;input type=&quot;file&quot; name=&quot;mFile&quot; &gt;
</code></pre><p>对应的是name后面的值，即mFile.</p>
<h4 id="6-__u6587_u4EF6_u4E0B_u8F7D"><a href="#6-__u6587_u4EF6_u4E0B_u8F7D" class="headerlink" title="6. 文件下载"></a>6. 文件下载</h4><p>对于文件下载，提供url，目标dir，callback即可。</p>
<pre><code>OkHttpClientManager.downloadAsyn(
    &quot;http://192.168.1.103:8080/okHttpServer/files/messenger_01.png&quot;,
    Environment.getExternalStorageDirectory().getAbsolutePath(),
new OkHttpClientManager.ResultCallback&lt;String&gt;()
    {
        @Override
        public void onError(Request request, IOException e)
        {

}

@Override
        public void onResponse(String response)
        {
            //文件下载成功，这里回调的reponse为文件的absolutePath
        }
});
</code></pre><h4 id="7-__u5C55_u793A_u56FE_u7247"><a href="#7-__u5C55_u793A_u56FE_u7247" class="headerlink" title="7. 展示图片"></a>7. 展示图片</h4><p>展示图片，我们希望提供一个url和一个imageview，如果下载成功，直接帮我们设置上即可。</p>
<pre><code>OkHttpClientManager.displayImage(mImageView,
    &quot;http://images.csdn.net/20150817/1.jpg&quot;);
</code></pre><p>内部会自动根据imageview的大小自动对图片进行合适的压缩。虽然，这里可能不适合一次性加载大量图片的场景，但是对于app中偶尔有几个图片的加载，还是可用的。</p>
<h2 id="u56DB_u3001_u6574_u5408Gson"><a href="#u56DB_u3001_u6574_u5408Gson" class="headerlink" title="四、整合Gson"></a>四、整合Gson</h2><p>很多人提出项目中使用时，服务端返回的是Json字符串，希望客户端回调可以直接拿到对象，于是整合进入了Gson，完善该功能。</p>
<h3 id="uFF08_u4E00_uFF09_u76F4_u63A5_u56DE_u8C03_u5BF9_u8C61"><a href="#uFF08_u4E00_uFF09_u76F4_u63A5_u56DE_u8C03_u5BF9_u8C61" class="headerlink" title="（一）直接回调对象"></a>（一）直接回调对象</h3><p>例如现在有个User实体类：</p>
<pre><code>package com.zhy.utils.http.okhttp;
public class User {
public String username ;
    public String password  ;
public User() {
        // TODO Auto-generated constructor stub
    }
public User(String username, String password) {
        this.username = username;
        this.password = password;
    }
@Override
    public String toString()
    {
        return &quot;User{&quot; +
                &quot;username=&apos;&quot; + username + &apos;\&apos;&apos; +
                &quot;, password=&apos;&quot; + password + &apos;\&apos;&apos; +
                &apos;}&apos;;
    }
}
</code></pre><p>服务端返回：</p>
<pre><code>{&quot;username&quot;:&quot;zhy&quot;,&quot;password&quot;:&quot;123&quot;}
</code></pre><p>客户端可以如下方式调用：</p>
<pre><code> OkHttpClientManager.getAsyn(&quot;http://192.168.56.1:8080/okHttpServer/user!getUser&quot;,
new OkHttpClientManager.ResultCallback&lt;User&gt;()
{
    @Override
    public void onError(Request request, Exception e)
    {
        e.printStackTrace();
    }
@Override
    public void onResponse(User user)
    {
        mTv.setText(u.toString());//UI线程
    }
});
</code></pre><p>我们传入泛型User，在onResponse里面直接回调User对象。</p>
<p>这里特别要注意的事，如果在json字符串-&gt;实体对象过程中发生错误，程序不会崩溃，onError方法会被回调。<br>注意：这里做了少许的更新，接口命名从StringCallback修改为ResultCallback。接口中的onFailure方法修改为onError。</p>
<h3 id="28_u4E8C_29__u56DE_u8C03_u5BF9_u8C61_u96C6_u5408"><a href="#28_u4E8C_29__u56DE_u8C03_u5BF9_u8C61_u96C6_u5408" class="headerlink" title="(二) 回调对象集合"></a>(二) 回调对象集合</h3><p>依然是上述的User类，服务端返回</p>
<pre><code>[{&quot;username&quot;:&quot;zhy&quot;,&quot;password&quot;:&quot;123&quot;},{&quot;username&quot;:&quot;lmj&quot;,&quot;password&quot;:&quot;12345&quot;}]
</code></pre><p>则客户端可以如下调用：</p>
<pre><code>OkHttpClientManager.getAsyn(&quot;http://192.168.56.1:8080/okHttpServer/user!getUsers&quot;,
new OkHttpClientManager.ResultCallback&lt;List&lt;User&gt;&gt;()
{
    @Override
    public void onError(Request request, Exception e)
    {
        e.printStackTrace();
    }
    @Override
    public void onResponse(List&lt;User&gt; us)
    {
        Log.e(&quot;TAG&quot;, us.size() + &quot;&quot;);
        mTv.setText(us.get(1).toString());
    }
});
</code></pre><p>唯一的区别，就是泛型变为List<user> ，ok ， 如果发现bug或者有任何意见欢迎留言。</user></p>
<h3 id="u6E90_u7801"><a href="#u6E90_u7801" class="headerlink" title="源码"></a>源码</h3><p>ok，基本介绍完了，对于封装的代码其实也很简单，我就直接贴出来了，因为也没什么好介绍的，如果你看完上面的用法，肯定可以看懂：</p>
<pre><code>package com.zhy.utils.http.okhttp;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.os.Handler;
import android.os.Looper;
import android.widget.ImageView;
import com.google.gson.Gson;
import com.google.gson.internal.$Gson$Types;
import com.squareup.okhttp.Call;
import com.squareup.okhttp.Callback;
import com.squareup.okhttp.FormEncodingBuilder;
import com.squareup.okhttp.Headers;
import com.squareup.okhttp.MediaType;
import com.squareup.okhttp.MultipartBuilder;
import com.squareup.okhttp.OkHttpClient;
import com.squareup.okhttp.Request;
import com.squareup.okhttp.RequestBody;
import com.squareup.okhttp.Response;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.net.CookieManager;
import java.net.CookiePolicy;
import java.net.FileNameMap;
import java.net.URLConnection;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
/**
 * Created by zhy on 15/8/17.
 */
public class OkHttpClientManager
{
    private static OkHttpClientManager mInstance;
    private OkHttpClient mOkHttpClient;
    private Handler mDelivery;
    private Gson mGson;
private static final String TAG = &quot;OkHttpClientManager&quot;;
private OkHttpClientManager()
    {
        mOkHttpClient = new OkHttpClient();
        //cookie enabled
        mOkHttpClient.setCookieHandler(new CookieManager(null, CookiePolicy.ACCEPT_ORIGINAL_SERVER));
        mDelivery = new Handler(Looper.getMainLooper());
        mGson = new Gson();
    }
public static OkHttpClientManager getInstance()
    {
        if (mInstance == null)
        {
            synchronized (OkHttpClientManager.class)
            {
                if (mInstance == null)
                {
                    mInstance = new OkHttpClientManager();
                }
            }
        }
        return mInstance;
    }
/**
     * 同步的Get请求
     *
     * @param url
     * @return Response
     */
    private Response _getAsyn(String url) throws IOException
    {
        final Request request = new Request.Builder()
                .url(url)
                .build();
        Call call = mOkHttpClient.newCall(request);
        Response execute = call.execute();
        return execute;
    }
/**
     * 同步的Get请求
     *
     * @param url
     * @return 字符串
     */
    private String _getAsString(String url) throws IOException
    {
        Response execute = _getAsyn(url);
        return execute.body().string();
    }
/**
     * 异步的get请求
     *
     * @param url
     * @param callback
     */
    private void _getAsyn(String url, final ResultCallback callback)
    {
        final Request request = new Request.Builder()
                .url(url)
                .build();
        deliveryResult(callback, request);
    }
/**
     * 同步的Post请求
     *
     * @param url
     * @param params post的参数
     * @return
     */
    private Response _post(String url, Param... params) throws IOException
    {
        Request request = buildPostRequest(url, params);
        Response response = mOkHttpClient.newCall(request).execute();
        return response;
    }
/**
     * 同步的Post请求
     *
     * @param url
     * @param params post的参数
     * @return 字符串
     */
    private String _postAsString(String url, Param... params) throws IOException
    {
        Response response = _post(url, params);
        return response.body().string();
    }
/**
     * 异步的post请求
     *
     * @param url
     * @param callback
     * @param params
     */
    private void _postAsyn(String url, final ResultCallback callback, Param... params)
    {
        Request request = buildPostRequest(url, params);
        deliveryResult(callback, request);
    }
/**
     * 异步的post请求
     *
     * @param url
     * @param callback
     * @param params
     */
    private void _postAsyn(String url, final ResultCallback callback, Map&lt;String, String&gt; params)
    {
        Param[] paramsArr = map2Params(params);
        Request request = buildPostRequest(url, paramsArr);
        deliveryResult(callback, request);
    }
/**
     * 同步基于post的文件上传
     *
     * @param params
     * @return
     */
    private Response _post(String url, File[] files, String[] fileKeys, Param... params) throws IOException
    {
        Request request = buildMultipartFormRequest(url, files, fileKeys, params);
        return mOkHttpClient.newCall(request).execute();
    }
private Response _post(String url, File file, String fileKey) throws IOException
    {
        Request request = buildMultipartFormRequest(url, new File[]{file}, new String[]{fileKey}, null);
        return mOkHttpClient.newCall(request).execute();
    }
private Response _post(String url, File file, String fileKey, Param... params) throws IOException
    {
        Request request = buildMultipartFormRequest(url, new File[]{file}, new String[]{fileKey}, params);
        return mOkHttpClient.newCall(request).execute();
    }
/**
     * 异步基于post的文件上传
     *
     * @param url
     * @param callback
     * @param files
     * @param fileKeys
     * @throws IOException
     */
    private void _postAsyn(String url, ResultCallback callback, File[] files, String[] fileKeys, Param... params) throws IOException
    {
        Request request = buildMultipartFormRequest(url, files, fileKeys, params);
        deliveryResult(callback, request);
    }
/**
     * 异步基于post的文件上传，单文件不带参数上传
     *
     * @param url
     * @param callback
     * @param file
     * @param fileKey
     * @throws IOException
     */
    private void _postAsyn(String url, ResultCallback callback, File file, String fileKey) throws IOException
    {
        Request request = buildMultipartFormRequest(url, new File[]{file}, new String[]{fileKey}, null);
        deliveryResult(callback, request);
    }
/**
     * 异步基于post的文件上传，单文件且携带其他form参数上传
     *
     * @param url
     * @param callback
     * @param file
     * @param fileKey
     * @param params
     * @throws IOException
     */
    private void _postAsyn(String url, ResultCallback callback, File file, String fileKey, Param... params) throws IOException
    {
        Request request = buildMultipartFormRequest(url, new File[]{file}, new String[]{fileKey}, params);
        deliveryResult(callback, request);
    }
/**
     * 异步下载文件
     *
     * @param url
     * @param destFileDir 本地文件存储的文件夹
     * @param callback
     */
    private void _downloadAsyn(final String url, final String destFileDir, final ResultCallback callback)
    {
        final Request request = new Request.Builder()
                .url(url)
                .build();
        final Call call = mOkHttpClient.newCall(request);
        call.enqueue(new Callback()
        {
            @Override
            public void onFailure(final Request request, final IOException e)
            {
                sendFailedStringCallback(request, e, callback);
            }
@Override
            public void onResponse(Response response)
            {
                InputStream is = null;
                byte[] buf = new byte[2048];
                int len = 0;
                FileOutputStream fos = null;
                try
                {
                    is = response.body().byteStream();
                    File file = new File(destFileDir, getFileName(url));
                    fos = new FileOutputStream(file);
                    while ((len = is.read(buf)) != -1)
                    {
                        fos.write(buf, 0, len);
                    }
                    fos.flush();
                    //如果下载文件成功，第一个参数为文件的绝对路径
                    sendSuccessResultCallback(file.getAbsolutePath(), callback);
                } catch (IOException e)
                {
                    sendFailedStringCallback(response.request(), e, callback);
                } finally
                {
                    try
                    {
                        if (is != null) is.close();
                    } catch (IOException e)
                    {
                    }
                    try
                    {
                        if (fos != null) fos.close();
                    } catch (IOException e)
                    {
                    }
                }
}
        });
    }
private String getFileName(String path)
    {
        int separatorIndex = path.lastIndexOf(&quot;/&quot;);
        return (separatorIndex &lt; 0) ? path : path.substring(separatorIndex + 1, path.length());
    }
/**
     * 加载图片
     *
     * @param view
     * @param url
     * @throws IOException
     */
    private void _displayImage(final ImageView view, final String url, final int errorResId)
    {
        final Request request = new Request.Builder()
                .url(url)
                .build();
        Call call = mOkHttpClient.newCall(request);
        call.enqueue(new Callback()
        {
            @Override
            public void onFailure(Request request, IOException e)
            {
                setErrorResId(view, errorResId);
            }
@Override
            public void onResponse(Response response)
            {
                InputStream is = null;
                try
                {
                    is = response.body().byteStream();
                    ImageUtils.ImageSize actualImageSize = ImageUtils.getImageSize(is);
                    ImageUtils.ImageSize imageViewSize = ImageUtils.getImageViewSize(view);
                    int inSampleSize = ImageUtils.calculateInSampleSize(actualImageSize, imageViewSize);
                    try
                    {
                        is.reset();
                    } catch (IOException e)
                    {
                        response = _getAsyn(url);
                        is = response.body().byteStream();
                    }
BitmapFactory.Options ops = new BitmapFactory.Options();
                    ops.inJustDecodeBounds = false;
                    ops.inSampleSize = inSampleSize;
                    final Bitmap bm = BitmapFactory.decodeStream(is, null, ops);
                    mDelivery.post(new Runnable()
                    {
                        @Override
                        public void run()
                        {
                            view.setImageBitmap(bm);
                        }
                    });
                } catch (Exception e)
                {
                    setErrorResId(view, errorResId);
} finally
                {
                    if (is != null) try
                    {
                        is.close();
                    } catch (IOException e)
                    {
                        e.printStackTrace();
                    }
                }
            }
        });
}
private void setErrorResId(final ImageView view, final int errorResId)
    {
        mDelivery.post(new Runnable()
        {
            @Override
            public void run()
            {
                view.setImageResource(errorResId);
            }
        });
    }
//*************对外公布的方法************
public static Response getAsyn(String url) throws IOException
    {
        return getInstance()._getAsyn(url);
    }
public static String getAsString(String url) throws IOException
    {
        return getInstance()._getAsString(url);
    }
public static void getAsyn(String url, ResultCallback callback)
    {
        getInstance()._getAsyn(url, callback);
    }
public static Response post(String url, Param... params) throws IOException
    {
        return getInstance()._post(url, params);
    }
public static String postAsString(String url, Param... params) throws IOException
    {
        return getInstance()._postAsString(url, params);
    }
public static void postAsyn(String url, final ResultCallback callback, Param... params)
    {
        getInstance()._postAsyn(url, callback, params);
    }
public static void postAsyn(String url, final ResultCallback callback, Map&lt;String, String&gt; params)
    {
        getInstance()._postAsyn(url, callback, params);
    }
public static Response post(String url, File[] files, String[] fileKeys, Param... params) throws IOException
    {
        return getInstance()._post(url, files, fileKeys, params);
    }
public static Response post(String url, File file, String fileKey) throws IOException
    {
        return getInstance()._post(url, file, fileKey);
    }
public static Response post(String url, File file, String fileKey, Param... params) throws IOException
    {
        return getInstance()._post(url, file, fileKey, params);
    }
public static void postAsyn(String url, ResultCallback callback, File[] files, String[] fileKeys, Param... params) throws IOException
    {
        getInstance()._postAsyn(url, callback, files, fileKeys, params);
    }
public static void postAsyn(String url, ResultCallback callback, File file, String fileKey) throws IOException
    {
        getInstance()._postAsyn(url, callback, file, fileKey);
    }
public static void postAsyn(String url, ResultCallback callback, File file, String fileKey, Param... params) throws IOException
    {
        getInstance()._postAsyn(url, callback, file, fileKey, params);
    }
public static void displayImage(final ImageView view, String url, int errorResId) throws IOException
    {
        getInstance()._displayImage(view, url, errorResId);
    }
public static void displayImage(final ImageView view, String url)
    {
        getInstance()._displayImage(view, url, -1);
    }
public static void downloadAsyn(String url, String destDir, ResultCallback callback)
    {
        getInstance()._downloadAsyn(url, destDir, callback);
    }
//****************************
private Request buildMultipartFormRequest(String url, File[] files,
                                              String[] fileKeys, Param[] params)
    {
        params = validateParam(params);
MultipartBuilder builder = new MultipartBuilder()
                .type(MultipartBuilder.FORM);
for (Param param : params)
        {
            builder.addPart(Headers.of(&quot;Content-Disposition&quot;, &quot;form-data; name=\&quot;&quot; + param.key + &quot;\&quot;&quot;),
                    RequestBody.create(null, param.value));
        }
        if (files != null)
        {
            RequestBody fileBody = null;
            for (int i = 0; i &lt; files.length; i++)
            {
                File file = files[i];
                String fileName = file.getName();
                fileBody = RequestBody.create(MediaType.parse(guessMimeType(fileName)), file);
                //TODO 根据文件名设置contentType
                builder.addPart(Headers.of(&quot;Content-Disposition&quot;,
                                &quot;form-data; name=\&quot;&quot; + fileKeys[i] + &quot;\&quot;; filename=\&quot;&quot; + fileName + &quot;\&quot;&quot;),
                        fileBody);
            }
        }
RequestBody requestBody = builder.build();
        return new Request.Builder()
                .url(url)
                .post(requestBody)
                .build();
    }
private String guessMimeType(String path)
    {
        FileNameMap fileNameMap = URLConnection.getFileNameMap();
        String contentTypeFor = fileNameMap.getContentTypeFor(path);
        if (contentTypeFor == null)
        {
            contentTypeFor = &quot;application/octet-stream&quot;;
        }
        return contentTypeFor;
    }
private Param[] validateParam(Param[] params)
    {
        if (params == null)
            return new Param[0];
        else return params;
    }
private Param[] map2Params(Map&lt;String, String&gt; params)
    {
        if (params == null) return new Param[0];
        int size = params.size();
        Param[] res = new Param[size];
        Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = params.entrySet();
        int i = 0;
        for (Map.Entry&lt;String, String&gt; entry : entries)
        {
            res[i++] = new Param(entry.getKey(), entry.getValue());
        }
        return res;
    }
private static final String SESSION_KEY = &quot;Set-Cookie&quot;;
    private static final String mSessionKey = &quot;JSESSIONID&quot;;
private Map&lt;String, String&gt; mSessions = new HashMap&lt;String, String&gt;();
private void deliveryResult(final ResultCallback callback, Request request)
    {
        mOkHttpClient.newCall(request).enqueue(new Callback()
        {
            @Override
            public void onFailure(final Request request, final IOException e)
            {
                sendFailedStringCallback(request, e, callback);
            }
@Override
            public void onResponse(final Response response)
            {
                try
                {
                    final String string = response.body().string();
                    if (callback.mType == String.class)
                    {
                        sendSuccessResultCallback(string, callback);
                    } else
                    {
                        Object o = mGson.fromJson(string, callback.mType);
                        sendSuccessResultCallback(o, callback);
                    }
} catch (IOException e)
                {
                    sendFailedStringCallback(response.request(), e, callback);
                } catch (com.google.gson.JsonParseException e)//Json解析的错误
                {
                    sendFailedStringCallback(response.request(), e, callback);
                }
}
        });
    }
private void sendFailedStringCallback(final Request request, final Exception e, final ResultCallback callback)
    {
        mDelivery.post(new Runnable()
        {
            @Override
            public void run()
            {
                if (callback != null)
                    callback.onError(request, e);
            }
        });
    }
private void sendSuccessResultCallback(final Object object, final ResultCallback callback)
    {
        mDelivery.post(new Runnable()
        {
            @Override
            public void run()
            {
                if (callback != null)
                {
                    callback.onResponse(object);
                }
            }
        });
    }
private Request buildPostRequest(String url, Param[] params)
    {
        if (params == null)
        {
            params = new Param[0];
        }
        FormEncodingBuilder builder = new FormEncodingBuilder();
        for (Param param : params)
        {
            builder.add(param.key, param.value);
        }
        RequestBody requestBody = builder.build();
        return new Request.Builder()
                .url(url)
                .post(requestBody)
                .build();
    }
public static abstract class ResultCallback&lt;T&gt;
    {
        Type mType;
public ResultCallback()
        {
            mType = getSuperclassTypeParameter(getClass());
        }
static Type getSuperclassTypeParameter(Class&lt;?&gt; subclass)
        {
            Type superclass = subclass.getGenericSuperclass();
            if (superclass instanceof Class)
            {
                throw new RuntimeException(&quot;Missing type parameter.&quot;);
            }
            ParameterizedType parameterized = (ParameterizedType) superclass;
            return $Gson$Types.canonicalize(parameterized.getActualTypeArguments()[0]);
        }
public abstract void onError(Request request, Exception e);
public abstract void onResponse(T response);
    }
public static class Param
    {
        public Param()
        {
        }
public Param(String key, String value)
        {
            this.key = key;
            this.value = value;
        }
String key;
        String value;
    }
}
</code></pre><p>源码地址okhttp-utils，大家可以自己下载查看。</p>
<p>来自 <a href="http://blog.csdn.net/lmj623565791/article/details/47911083" target="_blank" rel="external">http://blog.csdn.net/lmj623565791/article/details/47911083</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u4E00_u3001_u6982_u8FF0"><a href="#u4E00_u3001_u6982_u8FF0" class="headerlink" title="一、概述"></a>一、概述</h2><blockquote>
<p>最近在群里听到各种讨论okhttp的话题，可见okhttp的口碑相当好了。再加上Google貌似在6.0版本里面删除了HttpClient相关API，对于这个行为不做评价。为了更好的在应对网络访问，学习下okhttp还是蛮必要的，本篇博客首先介绍okhttp的简单使用，主要包含：</p>
</blockquote>]]>
    
    </summary>
    
      <category term="OkHttp" scheme="http://yoursite.com/tags/OkHttp/"/>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android OkHttp使用教程]]></title>
    <link href="http://yoursite.com/2015/07/19/Android%20OkHttp%E5%88%9D%E7%BA%A7%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2015/07/19/Android OkHttp初级入门/</id>
    <published>2015-07-19T05:33:17.000Z</published>
    <updated>2016-02-19T09:07:45.000Z</updated>
    <content type="html"><![CDATA[<p>Android系统提供了两种HTTP通信类，HttpURLConnection和HttpClient。</p>
<p>尽管Google在大部分安卓版本中推荐使用HttpURLConnection，但是这个类相比HttpClient实在是太难用，太弱爆了。</p>
<p>OkHttp是一个相对成熟的解决方案，据说Android4.4的源码中可以看到HttpURLConnection已经替换成OkHttp实现了。所以我们更有理由相信OkHttp的强大。<br><a id="more"></a><br>OkHttp 处理了很多网络疑难杂症：会从很多常用的连接问题中自动恢复。如果您的服务器配置了多个IP地址，当第一个IP连接失败的时候，OkHttp会自动尝试下一个IP。OkHttp还处理了代理服务器问题和SSL握手失败问题。</p>
<p>使用 OkHttp 无需重写您程序中的网络代码。OkHttp实现了几乎和java.net.HttpURLConnection一样的API。如果你用了 Apache HttpClient，则OkHttp也提供了一个对应的okhttp-apache 模块。</p>
<pre><code>注：在国内使用OkHttp会因为这个问题导致部分酷派手机用户无法联网，所以对于大众app来说，需要等待这个bug修复后再使用。或者尝试使用OkHttp的老版本。
截止到目前，OkHttp一直没有修复，并把修复计划延迟到了OkHttp2.3中。不是所有设备都能重现，仅少量设备会出现这个问题。（如果问题这么明显，OkHttp早就修复了）
</code></pre><h3 id="u5165_u95E8"><a href="#u5165_u95E8" class="headerlink" title="入门"></a>入门</h3><pre><code>官方资料
官方介绍
github源码
使用范围
OkHttp支持Android 2.3及其以上版本。
对于Java, JDK1.7以上。
jar包准备
官方介绍页面有链接位置。这里把下载链接也写在下面。
OkHttp
Okio
</code></pre><h3 id="u57FA_u672C_u4F7F_u7528"><a href="#u57FA_u672C_u4F7F_u7528" class="headerlink" title="基本使用"></a>基本使用</h3><h4 id="HTTP_GET"><a href="#HTTP_GET" class="headerlink" title="HTTP GET"></a>HTTP GET</h4><pre><code>1    OkHttpClient client = new OkHttpClient();
2     
3    String run(String url) throws IOException {
4        Request request = new Request.Builder().url(url).build();
5        Response response = client.newCall(request).execute();    if (response.isSuccessful()) {        return response.body().string();
6        } else {        throw new IOException(&quot;Unexpected code &quot; + response);
7        }
8    }
Request是OkHttp中访问的请求，Builder是辅助类。Response即OkHttp中的响应。
Response类：
1    public boolean isSuccessful()
2    Returns true if the code is in [200..300),
3     which means the request was successfully received, understood, and accepted.
response.body()返回ResponseBody类
</code></pre><p>可以方便的获取string</p>
<pre><code>1    public final String string() throws IOException
2    Returns the response as a string decoded with the charset of the Content-Type header. If that header is either absent or lacks a charset,
3     this will attempt to decode the response body as UTF-8.Throws:
4    IOException
</code></pre><p>当然也能获取到流的形式：</p>
<pre><code>1    public final InputStream byteStream()
</code></pre><h4 id="HTTP_POST"><a href="#HTTP_POST" class="headerlink" title="HTTP POST"></a>HTTP POST</h4><p>POST提交Json数据</p>
<pre><code>1    public static final MediaType JSON = MediaType.parse(&quot;application/json; charset=utf-8&quot;);
2    OkHttpClient client = new OkHttpClient();
3    String post(String url, String json) throws IOException {
4         RequestBody body = RequestBody.create(JSON, json);
5          Request request = new Request.Builder()
6          .url(url)
7          .post(body)
8          .build();
9          Response response = client.newCall(request).execute();
10        f (response.isSuccessful()) {
11            return response.body().string();
12        } else {
13            throw new IOException(&quot;Unexpected code &quot; + response);
14        }
15    }
</code></pre><p>使用Request的post方法来提交请求体RequestBody<br>POST提交键值对<br>很多时候我们会需要通过POST方式把键值对数据传送到服务器。 OkHttp提供了很方便的方式来做这件事情。</p>
<pre><code>1    OkHttpClient client = new OkHttpClient();
2    String post(String url, String json) throws IOException {
3     
4         RequestBody formBody = new FormEncodingBuilder()
5        .add(&quot;platform&quot;, &quot;android&quot;)
6        .add(&quot;name&quot;, &quot;bug&quot;)
7        .add(&quot;subject&quot;, &quot;XXXXXXXXXXXXXXX&quot;)
8        .build();
9     
10          Request request = new Request.Builder()
11          .url(url)
12          .post(body)
13          .build();
14     
15          Response response = client.newCall(request).execute();
16        if (response.isSuccessful()) {
17            return response.body().string();
18        } else {
19            throw new IOException(&quot;Unexpected code &quot; + response);
20        }
21    }
</code></pre><h4 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h4><p>通过上面的例子我们可以发现，OkHttp在很多时候使用都是很方便的，而且很多代码也有重复，因此特地整理了下面的工具类。<br>注意：</p>
<pre><code>• OkHttp官方文档并不建议我们创建多个OkHttpClient，因此全局使用一个。 如果有需要，可以使用clone方法，再进行自定义。这点在后面的高级教程里会提到。
• enqueue为OkHttp提供的异步方法，入门教程中并没有提到，后面的高级教程里会有解释。
1    import java.io.IOException;
2    import java.util.List;
3    import java.util.concurrent.TimeUnit;
4    import org.apache.http.client.utils.URLEncodedUtils;
5    import org.apache.http.message.BasicNameValuePair;
6    import cn.wiz.sdk.constant.WizConstant;
7    import com.squareup.okhttp.Callback;
8    import com.squareup.okhttp.OkHttpClient;
9    import com.squareup.okhttp.Request;
10    import com.squareup.okhttp.Response; 
11      
12    public class OkHttpUtil {
13        private static final OkHttpClient mOkHttpClient = new OkHttpClient();
14        static{
15            mOkHttpClient.setConnectTimeout(30, TimeUnit.SECONDS);
16        }
17        /**
18         * 该不会开启异步线程。
19         * @param request
20         * @return
21         * @throws IOException
22         */
23        public static Response execute(Request request) throws IOException{
24            return mOkHttpClient.newCall(request).execute();
25        }
26        /**
27         * 开启异步线程访问网络
28         * @param request
29         * @param responseCallback
30         */
31        public static void enqueue(Request request, Callback responseCallback){
32            mOkHttpClient.newCall(request).enqueue(responseCallback);
33        }
34        /**
35         * 开启异步线程访问网络, 且不在意返回结果（实现空callback）
36         * @param request
37         */
38        public static void enqueue(Request request){
39            mOkHttpClient.newCall(request).enqueue(new Callback() {
40                 
41                @Override
42                public void onResponse(Response arg0) throws IOException {
43                     
44                }
45                 
46                @Override
47                public void onFailure(Request arg0, IOException arg1) {
48                     
49                }
50            });
51        }
52        public static String getStringFromServer(String url) throws IOException{
53            Request request = new Request.Builder().url(url).build();
54            Response response = execute(request);
55            if (response.isSuccessful()) {
56                String responseUrl = response.body().string();
57                return responseUrl;
58            } else {
59                throw new IOException(&quot;Unexpected code &quot; + response);
60            }
61        }
62        private static final String CHARSET_NAME = &quot;UTF-8&quot;;
63        /**
64         * 这里使用了HttpClinet的API。只是为了方便
65         * @param params
66         * @return
67         */
68        public static String formatParams(List&lt;BasicNameValuePair&gt; params){
69            return URLEncodedUtils.format(params, CHARSET_NAME);
70        }
71        /**
72         * 为HttpGet 的 url 方便的添加多个name value 参数。
73         * @param url
74         * @param params
75         * @return
76         */
77        public static String attachHttpGetParams(String url, List&lt;BasicNameValuePair&gt; params){
78            return url + &quot;?&quot; + formatParams(params);
79        }
80        /**
81         * 为HttpGet 的 url 方便的添加1个name value 参数。
82         * @param url
83         * @param name
84         * @param value
85         * @return
86         */
87        public static String attachHttpGetParam(String url, String name, String value){
88            return url + &quot;?&quot; + name + &quot;=&quot; + value;
89        }
90    }
</code></pre><h3 id="u9AD8_u7EA7"><a href="#u9AD8_u7EA7" class="headerlink" title="高级"></a>高级</h3><p>高级属性其实用的不多，这里主要是对OkHttp github官方教程进行了翻译。</p>
<h4 id="u540C_u6B65get"><a href="#u540C_u6B65get" class="headerlink" title="同步get"></a>同步get</h4><p>下载一个文件，打印他的响应头，以string形式打印响应体。<br>响应体的 string() 方法对于小文档来说十分方便、高效。但是如果响应体太大（超过1MB），应避免适应 string()方法 ，因为他会将把整个文档加载到内存中。<br>对于超过1MB的响应body，应使用流的方式来处理body。</p>
<pre><code>1    private final OkHttpClient client = new OkHttpClient();
2     
3    public void run() throws Exception {
4        Request request = new Request.Builder()
5            .url(&quot;http://publicobject.com/helloworld.txt&quot;)
6            .build();
7     
8        Response response = client.newCall(request).execute();
9        if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);
10     
11        Headers responseHeaders = response.headers();
12        for (int i = 0; i &lt; responseHeaders.size(); i++) {
13          System.out.println(responseHeaders.name(i) + &quot;: &quot; + responseHeaders.value(i));
14        }
15     
16        System.out.println(response.body().string());
17    }
</code></pre><h4 id="u5F02_u6B65get"><a href="#u5F02_u6B65get" class="headerlink" title="异步get"></a>异步get</h4><p>在一个工作线程中下载文件，当响应可读时回调Callback接口。读取响应时会阻塞当前线程。OkHttp现阶段不提供异步api来接收响应体。</p>
<pre><code>1    private final OkHttpClient client = new OkHttpClient();
2     
3    public void run() throws Exception {
4        Request request = new Request.Builder()
5            .url(&quot;http://publicobject.com/helloworld.txt&quot;)
6            .build();
7     
8        client.newCall(request).enqueue(new Callback() {
9          @Override public void onFailure(Request request, Throwable throwable) {
10            throwable.printStackTrace();
11          }
12     
13          @Override public void onResponse(Response response) throws IOException {
14            if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);
15     
16            Headers responseHeaders = response.headers();
17            for (int i = 0; i &lt; responseHeaders.size(); i++) {
18              System.out.println(responseHeaders.name(i) + &quot;: &quot; + responseHeaders.value(i));
19            }
20     
21            System.out.println(response.body().string());
22          }
23        });
24    }
</code></pre><h4 id="u63D0_u53D6_u54CD_u5E94_u5934"><a href="#u63D0_u53D6_u54CD_u5E94_u5934" class="headerlink" title="提取响应头"></a>提取响应头</h4><p>典型的HTTP头 像是一个 Map<string, string=""> :每个字段都有一个或没有值。但是一些头允许多个值，像Guava的Multimap。例如：HTTP响应里面提供的Vary响应头，就是多值的。OkHttp的api试图让这些情况都适用。<br>当写请求头的时候，使用header(name, value)可以设置唯一的name、value。如果已经有值，旧的将被移除，然后添加新的。使用addHeader(name, value)可以添加多值（添加，不移除已有的）。<br>当读取响应头时，使用header(name)返回最后出现的name、value。通常情况这也是唯一的name、value。如果没有值，那么header(name)将返回null。如果想读取字段对应的所有值，使用headers(name)会返回一个list。<br>为了获取所有的Header，Headers类支持按index访问。</string,></p>
<pre><code>1    private final OkHttpClient client = new OkHttpClient();
2     
3    public void run() throws Exception {
4        Request request = new Request.Builder()
5            .url(&quot;https://api.github.com/repos/square/okhttp/issues&quot;)
6            .header(&quot;User-Agent&quot;, &quot;OkHttp Headers.java&quot;)
7            .addHeader(&quot;Accept&quot;, &quot;application/json; q=0.5&quot;)
8            .addHeader(&quot;Accept&quot;, &quot;application/vnd.github.v3+json&quot;)
9            .build();
10     
11        Response response = client.newCall(request).execute();
12        if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);
13     
14        System.out.println(&quot;Server: &quot; + response.header(&quot;Server&quot;));
15        System.out.println(&quot;Date: &quot; + response.header(&quot;Date&quot;));
16        System.out.println(&quot;Vary: &quot; + response.headers(&quot;Vary&quot;));
17    }
</code></pre><h4 id="Post_u65B9_u5F0F_u63D0_u4EA4String"><a href="#Post_u65B9_u5F0F_u63D0_u4EA4String" class="headerlink" title="Post方式提交String"></a>Post方式提交String</h4><p>使用HTTP POST提交请求到服务。这个例子提交了一个markdown文档到web服务，以HTML方式渲染markdown。因为整个请求体都在内存中，因此避免使用此api提交大文档（大于1MB）。</p>
<pre><code>1    public static final MediaType MEDIA_TYPE_MARKDOWN
2      = MediaType.parse(&quot;text/x-markdown; charset=utf-8&quot;);
3     
4    private final OkHttpClient client = new OkHttpClient();
5     
6    public void run() throws Exception {
7        String postBody = &quot;&quot;
8            + &quot;Releases\n&quot;
9            + &quot;--------\n&quot;
10            + &quot;\n&quot;
11            + &quot; * _1.0_ May 6, 2013\n&quot;
12            + &quot; * _1.1_ June 15, 2013\n&quot;
13            + &quot; * _1.2_ August 11, 2013\n&quot;;
14     
15        Request request = new Request.Builder()
16            .url(&quot;https://api.github.com/markdown/raw&quot;)
17            .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, postBody))
18            .build();
19     
20        Response response = client.newCall(request).execute();
21        if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);
22     
23        System.out.println(response.body().string());
24    }
</code></pre><h4 id="Post_u65B9_u5F0F_u63D0_u4EA4_u6D41"><a href="#Post_u65B9_u5F0F_u63D0_u4EA4_u6D41" class="headerlink" title="Post方式提交流"></a>Post方式提交流</h4><p>以流的方式POST提交请求体。请求体的内容由流写入产生。这个例子是流直接写入Okio的BufferedSink。你的程序可能会使用OutputStream，你可以使用BufferedSink.outputStream()来获取。</p>
<pre><code>1    public static final MediaType MEDIA_TYPE_MARKDOWN
2          = MediaType.parse(&quot;text/x-markdown; charset=utf-8&quot;);
3     
4    private final OkHttpClient client = new OkHttpClient();
5     
6    public void run() throws Exception {
7        RequestBody requestBody = new RequestBody() {
8          @Override public MediaType contentType() {
9            return MEDIA_TYPE_MARKDOWN;
10          }
11     
12          @Override public void writeTo(BufferedSink sink) throws IOException {
13            sink.writeUtf8(&quot;Numbers\n&quot;);
14            sink.writeUtf8(&quot;-------\n&quot;);
15            for (int i = 2; i &lt;= 997; i++) {
16              sink.writeUtf8(String.format(&quot; * %s = %s\n&quot;, i, factor(i)));
17            }
18          }
19     
20          private String factor(int n) {
21            for (int i = 2; i &lt; n; i++) {
22              int x = n / i;
23              if (x * i == n) return factor(x) + &quot; × &quot; + i;
24            }
25            return Integer.toString(n);
26          }
27        };
28     
29        Request request = new Request.Builder()
30            .url(&quot;https://api.github.com/markdown/raw&quot;)
31            .post(requestBody)
32            .build();
33     
34        Response response = client.newCall(request).execute();
35        if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);
36     
37        System.out.println(response.body().string());
38    }
</code></pre><h4 id="Post_u65B9_u5F0F_u63D0_u4EA4_u6587_u4EF6"><a href="#Post_u65B9_u5F0F_u63D0_u4EA4_u6587_u4EF6" class="headerlink" title="Post方式提交文件"></a>Post方式提交文件</h4><p>以文件作为请求体是十分简单的。</p>
<pre><code>1    public static final MediaType MEDIA_TYPE_MARKDOWN
2      = MediaType.parse(&quot;text/x-markdown; charset=utf-8&quot;);
3     
4    private final OkHttpClient client = new OkHttpClient();
5     
6    public void run() throws Exception {
7        File file = new File(&quot;README.md&quot;);
8     
9        Request request = new Request.Builder()
10            .url(&quot;https://api.github.com/markdown/raw&quot;)
11            .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, file))
12            .build();
13     
14        Response response = client.newCall(request).execute();
15        if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);
16     
17        System.out.println(response.body().string());
18    }
</code></pre><h4 id="Post_u65B9_u5F0F_u63D0_u4EA4_u8868_u5355"><a href="#Post_u65B9_u5F0F_u63D0_u4EA4_u8868_u5355" class="headerlink" title="Post方式提交表单"></a>Post方式提交表单</h4><p>使用FormEncodingBuilder来构建和HTML<form>标签相同效果的请求体。键值对将使用一种HTML兼容形式的URL编码来进行编码。</form></p>
<pre><code>1    private final OkHttpClient client = new OkHttpClient();
2     
3    public void run() throws Exception {
4        RequestBody formBody = new FormEncodingBuilder()
5            .add(&quot;search&quot;, &quot;Jurassic Park&quot;)
6            .build();
7        Request request = new Request.Builder()
8            .url(&quot;https://en.wikipedia.org/w/index.php&quot;)
9            .post(formBody)
10            .build();
11     
12        Response response = client.newCall(request).execute();
13        if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);
14     
15        System.out.println(response.body().string());
16    }
</code></pre><h4 id="Post_u65B9_u5F0F_u63D0_u4EA4_u5206_u5757_u8BF7_u6C42"><a href="#Post_u65B9_u5F0F_u63D0_u4EA4_u5206_u5757_u8BF7_u6C42" class="headerlink" title="Post方式提交分块请求"></a>Post方式提交分块请求</h4><p>MultipartBuilder可以构建复杂的请求体，与HTML文件上传形式兼容。多块请求体中每块请求都是一个请求体，可以定义自己的请求头。这些请求头可以用来描述这块请求，例如他的Content-Disposition。如果Content-Length和Content-Type可用的话，他们会被自动添加到请求头中。</p>
<pre><code>1    private static final String IMGUR_CLIENT_ID = &quot;...&quot;;
2    private static final MediaType MEDIA_TYPE_PNG = MediaType.parse(&quot;image/png&quot;);
3     
4    private final OkHttpClient client = new OkHttpClient();
5     
6    public void run() throws Exception {
7        // Use the imgur image upload API as documented at https://api.imgur.com/endpoints/image
8        RequestBody requestBody = new MultipartBuilder()
9            .type(MultipartBuilder.FORM)
10            .addPart(
11                Headers.of(&quot;Content-Disposition&quot;, &quot;form-data; name=\&quot;title\&quot;&quot;),
12                RequestBody.create(null, &quot;Square Logo&quot;))
13            .addPart(
14                Headers.of(&quot;Content-Disposition&quot;, &quot;form-data; name=\&quot;image\&quot;&quot;),
15                RequestBody.create(MEDIA_TYPE_PNG, new File(&quot;website/static/logo-square.png&quot;)))
16            .build();
17     
18        Request request = new Request.Builder()
19            .header(&quot;Authorization&quot;, &quot;Client-ID &quot; + IMGUR_CLIENT_ID)
20            .url(&quot;https://api.imgur.com/3/image&quot;)
21            .post(requestBody)
22            .build();
23     
24        Response response = client.newCall(request).execute();
25        if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);
26     
27        System.out.println(response.body().string());
28    }
</code></pre><h4 id="u4F7F_u7528Gson_u6765_u89E3_u6790JSON_u54CD_u5E94"><a href="#u4F7F_u7528Gson_u6765_u89E3_u6790JSON_u54CD_u5E94" class="headerlink" title="使用Gson来解析JSON响应"></a>使用Gson来解析JSON响应</h4><p>Gson是一个在JSON和Java对象之间转换非常方便的api。这里我们用Gson来解析Github API的JSON响应。<br>注意：ResponseBody.charStream()使用响应头Content-Type指定的字符集来解析响应体。默认是UTF-8。</p>
<pre><code>1    private final OkHttpClient client = new OkHttpClient();
2    private final Gson gson = new Gson();
3     
4    public void run() throws Exception {
5        Request request = new Request.Builder()
6            .url(&quot;https://api.github.com/gists/c2a7c39532239ff261be&quot;)
7            .build();
8        Response response = client.newCall(request).execute();
9        if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);
10     
11        Gist gist = gson.fromJson(response.body().charStream(), Gist.class);
12        for (Map.Entry&lt;String, GistFile&gt; entry : gist.files.entrySet()) {
13          System.out.println(entry.getKey());
14          System.out.println(entry.getValue().content);
15        }
16    }
17     
18    static class Gist {
19        Map&lt;String, GistFile&gt; files;
20    }
21     
22    static class GistFile {
23        String content;
24    }
</code></pre><h4 id="u54CD_u5E94_u7F13_u5B58"><a href="#u54CD_u5E94_u7F13_u5B58" class="headerlink" title="响应缓存"></a>响应缓存</h4><p>为了缓存响应，你需要一个你可以读写的缓存目录，和缓存大小的限制。这个缓存目录应该是私有的，不信任的程序应不能读取缓存内容。<br>一个缓存目录同时拥有多个缓存访问是错误的。大多数程序只需要调用一次new OkHttp()，在第一次调用时配置好缓存，然后其他地方只需要调用这个实例就可以了。否则两个缓存示例互相干扰，破坏响应缓存，而且有可能会导致程序崩溃。<br>响应缓存使用HTTP头作为配置。你可以在请求头中添加Cache-Control: max-stale=3600 ,OkHttp缓存会支持。你的服务通过响应头确定响应缓存多长时间，例如使用Cache-Control: max-age=9600。</p>
<pre><code>1    private final OkHttpClient client;
2     
3    public CacheResponse(File cacheDirectory) throws Exception {
4        int cacheSize = 10 * 1024 * 1024; // 10 MiB
5        Cache cache = new Cache(cacheDirectory, cacheSize);
6     
7        client = new OkHttpClient();
8        client.setCache(cache);
9    }
10     
11    public void run() throws Exception {
12        Request request = new Request.Builder()
13            .url(&quot;http://publicobject.com/helloworld.txt&quot;)
14            .build();
15     
16        Response response1 = client.newCall(request).execute();
17        if (!response1.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response1);
18     
19        String response1Body = response1.body().string();
20        System.out.println(&quot;Response 1 response:          &quot; + response1);
21        System.out.println(&quot;Response 1 cache response:    &quot; + response1.cacheResponse());
22        System.out.println(&quot;Response 1 network response:  &quot; + response1.networkResponse());
23     
24        Response response2 = client.newCall(request).execute();
25        if (!response2.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response2);
26     
27        String response2Body = response2.body().string();
28        System.out.println(&quot;Response 2 response:          &quot; + response2);
29        System.out.println(&quot;Response 2 cache response:    &quot; + response2.cacheResponse());
30        System.out.println(&quot;Response 2 network response:  &quot; + response2.networkResponse());
31     
32        System.out.println(&quot;Response 2 equals Response 1? &quot; + response1Body.equals(response2Body));
33    }
</code></pre><h3 id="u6269_u5C55"><a href="#u6269_u5C55" class="headerlink" title="扩展"></a>扩展</h3><p>在这一节还提到了下面一句：<br>There are cache headers to force a cached response, force a network response, or force the network response to be validated with a conditional GET.<br>我不是很懂cache，平时用到的也不多，所以把Google在Android Developers一段相关的解析放到这里吧。<br>Force a Network Response<br>In some situations, such as after a user clicks a ‘refresh’ button, it may be necessary to skip the cache, and fetch data directly from the server. To force a full refresh, add the no-cache directive:<br>connection.addRequestProperty(“Cache-Control”, “no-cache”);<br>If it is only necessary to force a cached response to be validated by the server, use the more efficient max-age=0 instead:<br>connection.addRequestProperty(“Cache-Control”, “max-age=0”);<br>Force a Cache Response<br>Sometimes you’ll want to show resources if they are available immediately, but not otherwise. This can be used so your application can show something while waiting for the latest data to be downloaded. To restrict a request to locally-cached resources, add the only-if-cached directive:</p>
<pre><code>1    try {
2         connection.addRequestProperty(&quot;Cache-Control&quot;, &quot;only-if-cached&quot;);
3         InputStream cached = connection.getInputStream();
4         // the resource was cached! show it
5      catch (FileNotFoundException e) {
6         // the resource was not cached
7     }
8    }
</code></pre><p>This technique works even better in situations where a stale response is better than no response. To permit stale cached responses, use the max-stale directive with the maximum staleness in seconds:</p>
<pre><code>1    int maxStale = 60 * 60 * 24 * 28; // tolerate 4-weeks staleconnection.addRequestProperty(&quot;Cache-Control&quot;, &quot;max-stale=&quot; + maxStale);
</code></pre><p>以上信息来自：<code>HttpResponseCache - Android SDK | Android Developers</code><br>取消一个Call<br>使用Call.cancel()可以立即停止掉一个正在执行的call。如果一个线程正在写请求或者读响应，将会引发IOException。当call没有必要的时候，使用这个api可以节约网络资源。例如当用户离开一个应用时。不管同步还是异步的call都可以取消。<br>你可以通过tags来同时取消多个请求。当你构建一请求时，使用RequestBuilder.tag(tag)来分配一个标签。之后你就可以用OkHttpClient.cancel(tag)来取消所有带有这个tag的call。</p>
<pre><code>1    private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);
2    private final OkHttpClient client = new OkHttpClient();
3     
4    public void run() throws Exception {
5        Request request = new Request.Builder()
6            .url(&quot;http://httpbin.org/delay/2&quot;) // This URL is served with a 2 second delay.
7            .build();
8     
9        final long startNanos = System.nanoTime();
10        final Call call = client.newCall(request);
11     
12        // Schedule a job to cancel the call in 1 second.
13        executor.schedule(new Runnable() {
14          @Override public void run() {
15            System.out.printf(&quot;%.2f Canceling call.%n&quot;, (System.nanoTime() - startNanos) / 1e9f);
16            call.cancel();
17            System.out.printf(&quot;%.2f Canceled call.%n&quot;, (System.nanoTime() - startNanos) / 1e9f);
18          }
19        }, 1, TimeUnit.SECONDS);
20     
21        try {
22          System.out.printf(&quot;%.2f Executing call.%n&quot;, (System.nanoTime() - startNanos) / 1e9f);
23          Response response = call.execute();
24          System.out.printf(&quot;%.2f Call was expected to fail, but completed: %s%n&quot;,
25              (System.nanoTime() - startNanos) / 1e9f, response);
26        } catch (IOException e) {
27          System.out.printf(&quot;%.2f Call failed as expected: %s%n&quot;,
28              (System.nanoTime() - startNanos) / 1e9f, e);
29        }
30    }
</code></pre><h4 id="u8D85_u65F6"><a href="#u8D85_u65F6" class="headerlink" title="超时"></a>超时</h4><p>没有响应时使用超时结束call。没有响应的原因可能是客户点链接问题、服务器可用性问题或者这之间的其他东西。OkHttp支持连接，读取和写入超时。</p>
<pre><code>1    private final OkHttpClient client;
2     
3    public ConfigureTimeouts() throws Exception {
4        client = new OkHttpClient();
5        client.setConnectTimeout(10, TimeUnit.SECONDS);
6        client.setWriteTimeout(10, TimeUnit.SECONDS);
7        client.setReadTimeout(30, TimeUnit.SECONDS);
8    }
9     
10    public void run() throws Exception {
11        Request request = new Request.Builder()
12            .url(&quot;http://httpbin.org/delay/2&quot;) // This URL is served with a 2 second delay.
13            .build();
14     
15        Response response = client.newCall(request).execute();
16        System.out.println(&quot;Response completed: &quot; + response);
17    }
</code></pre><h4 id="u6BCF_u4E2Acall_u7684_u914D_u7F6E"><a href="#u6BCF_u4E2Acall_u7684_u914D_u7F6E" class="headerlink" title="每个call的配置"></a>每个call的配置</h4><p>使用OkHttpClient，所有的HTTP Client配置包括代理设置、超时设置、缓存设置。当你需要为单个call改变配置的时候，clone 一个 OkHttpClient。这个api将会返回一个浅拷贝（shallow copy），你可以用来单独自定义。下面的例子中，我们让一个请求是500ms的超时、另一个是3000ms的超时。</p>
<pre><code>1    private final OkHttpClient client = new OkHttpClient();
2     
3    public void run() throws Exception {
4        Request request = new Request.Builder()
5            .url(&quot;http://httpbin.org/delay/1&quot;) // This URL is served with a 1 second delay.
6            .build();
7     
8        try {
9          Response response = client.clone() // Clone to make a customized OkHttp for this request.
10              .setReadTimeout(500, TimeUnit.MILLISECONDS)
11              .newCall(request)
12              .execute();
13          System.out.println(&quot;Response 1 succeeded: &quot; + response);
14        } catch (IOException e) {
15          System.out.println(&quot;Response 1 failed: &quot; + e);
16        }
17     
18        try {
19          Response response = client.clone() // Clone to make a customized OkHttp for this request.
20              .setReadTimeout(3000, TimeUnit.MILLISECONDS)
21              .newCall(request)
22              .execute();
23          System.out.println(&quot;Response 2 succeeded: &quot; + response);
24        } catch (IOException e) {
25          System.out.println(&quot;Response 2 failed: &quot; + e);
26        }
27    }
</code></pre><h4 id="u5904_u7406_u9A8C_u8BC1"><a href="#u5904_u7406_u9A8C_u8BC1" class="headerlink" title="处理验证"></a>处理验证</h4><p>这部分和HTTP AUTH有关。<br>相关资料：HTTP AUTH 那些事 - 王绍全的博客 - 博客频道 - CSDN.NET<br>OkHttp会自动重试未验证的请求。当响应是401 Not Authorized时，Authenticator会被要求提供证书。Authenticator的实现中需要建立一个新的包含证书的请求。如果没有证书可用，返回null来跳过尝试。</p>
<pre><code>1    public List&lt;Challenge&gt; challenges()
2    Returns the authorization challenges appropriate for this response&apos;s code. 
3    If the response code is 401 unauthorized, 
4    this returns the &quot;WWW-Authenticate&quot; challenges.
5    If the response code is 407 proxy unauthorized, this returns the &quot;Proxy-Authenticate&quot; challenges.
6    Otherwise this returns an empty list of challenges.
</code></pre><p>当需要实现一个Basic challenge， 使用Credentials.basic(username, password)来编码请求头。</p>
<pre><code>1    private final OkHttpClient client = new OkHttpClient();
2     
3    public void run() throws Exception {
4        client.setAuthenticator(new Authenticator() {
5          @Override public Request authenticate(Proxy proxy, Response response) {
6            System.out.println(&quot;Authenticating for response: &quot; + response);
7            System.out.println(&quot;Challenges: &quot; + response.challenges());
8            String credential = Credentials.basic(&quot;jesse&quot;, &quot;password1&quot;);
9            return response.request().newBuilder()
10                .header(&quot;Authorization&quot;, credential)
11                .build();
12          }
13     
14          @Override public Request authenticateProxy(Proxy proxy, Response response) {
15            return null; // Null indicates no attempt to authenticate.
16          }
17        });
18     
19        Request request = new Request.Builder()
20            .url(&quot;http://publicobject.com/secrets/hellosecret.txt&quot;)
21            .build();
22     
23        Response response = client.newCall(request).execute();
24        if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);
25     
26        System.out.println(response.body().string());
27    }
</code></pre><p>转自  <a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0106/2275.html" target="_blank" rel="external">http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0106/2275.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Android系统提供了两种HTTP通信类，HttpURLConnection和HttpClient。</p>
<p>尽管Google在大部分安卓版本中推荐使用HttpURLConnection，但是这个类相比HttpClient实在是太难用，太弱爆了。</p>
<p>OkHttp是一个相对成熟的解决方案，据说Android4.4的源码中可以看到HttpURLConnection已经替换成OkHttp实现了。所以我们更有理由相信OkHttp的强大。<br>]]>
    
    </summary>
    
      <category term="OkHttp" scheme="http://yoursite.com/tags/OkHttp/"/>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[EventBus 3.0的用法详解（二）]]></title>
    <link href="http://yoursite.com/2015/06/27/EventBus%203.0%E7%9A%84%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3(%E4%BA%8C)/"/>
    <id>http://yoursite.com/2015/06/27/EventBus 3.0的用法详解(二)/</id>
    <published>2015-06-27T15:59:14.000Z</published>
    <updated>2016-02-19T09:11:37.000Z</updated>
    <content type="html"><![CDATA[<p>前一篇文章简单介绍了<code>EventBus 3.0</code>的用法，现在是时候详解其用法了。首先声明，<code>EventBus 3.0</code>的改动针对2.4的改动并不是特别大，但是对于其性能的提升是另外一个说法了，所以建议学习EventBus 3.0。<a id="more"></a></p>
<h4 id="u6CE8_u89E3"><a href="#u6CE8_u89E3" class="headerlink" title="注解"></a>注解</h4><h5 id="u65B0_u589E_u7684_60@Subscribe"><a href="#u65B0_u589E_u7684_60@Subscribe" class="headerlink" title="新增的`@Subscribe"></a>新增的<code>`@Subscribe</code></h5><pre><code>threadMode = ThreadMode.MainThread
</code></pre><p>用注解的方式代替约定的方法名规范，是其最大的改变。在2.4中，你可能需要这么定义：</p>
<pre><code>public void onEventMainThread(MessageEvent event) {
        log(event.message);
    }
</code></pre><p>该方法为接收消息后在主线程中处理事件，而在3.0中：</p>
<pre><code>@Subscribe(threadMode = ThreadMode.MainThread) //在ui线程执行
public void onUserEvent(UserEvent event) {
        log(event.message);
    }
</code></pre><p>其中ThreadMode提供了四个常量：</p>
<ul>
<li>MainThread 主线程</li>
<li>BackgroundThread 后台线程</li>
<li>Async 后台线程</li>
<li>PostThread 发送线程（默认）</li>
</ul>
<p><code>BackgroundThread</code>:当事件是在UI线程发出，那么事件处理实际上是需要新建单独线程，如果是在后台线程发出，那么事件处理就在该线程。该事件处理方法应该是快速的，避免阻塞后台线程。</p>
<p>Async：发送事件方不需要等待事件处理完毕。这种方式适用于该事件处理方法需要较长时间，例如网络请求。</p>
<pre><code>sticky = true
</code></pre><h5 id="u9ED8_u8BA4_u60C5_u51B5_u4E0B_uFF0C_u5176_u4E3Afalse_u3002_u4EC0_u4E48_u60C5_u51B5_u4E0B_u4F7F_u7528sticky_u5462_uFF1F"><a href="#u9ED8_u8BA4_u60C5_u51B5_u4E0B_uFF0C_u5176_u4E3Afalse_u3002_u4EC0_u4E48_u60C5_u51B5_u4E0B_u4F7F_u7528sticky_u5462_uFF1F" class="headerlink" title="默认情况下，其为false。什么情况下使用sticky呢？"></a>默认情况下，其为false。什么情况下使用sticky呢？</h5><p>相信大多数使用过<code>EventBus 2.4</code>的同学或多或少的使用过：</p>
<pre><code>EventBus.getDefault().postSticky(new VoteEvent(obj));
EventBus.getDefault().registerSticky(this);
</code></pre><p>你会发现非常的麻烦，那么在3.0中：</p>
<pre><code>EventBus.getDefault().postSticky(new VoteEvent(obj));
EventBus.getDefault().register(this);
@Subscribe(sticky = true)
</code></pre><p>什么时候使用<code>sticy</code>,当你希望你的事件不被马上处理的时候，举个栗子，比如说，在一个详情页点赞之后，产生一个<code>VoteEvent</code>，<code>VoteEvent</code>并不立即被消费，而是等用户退出详情页回到商品列表之后，接收到该事件，然后刷新<code>Adapter</code>等。其实这就是之前我们用<code>startActivityForResult</code>和<code>onActivityResult</code>做的事情。</p>
<p>  priority = 1</p>
<p>相信大部分人知道该用法，值越小优先级越低，默认为0。</p>
<h5 id="u5EFA_u8BAE"><a href="#u5EFA_u8BAE" class="headerlink" title="建议"></a>建议</h5><p>推荐大家在使用EventBus的时候，创建一个事件类，把你的每一个参数（或者可能发生冲突的参数），封装成一个类：</p>
<pre><code>public class Event  {  
    public static class UserListEvent {  
        public List&lt;User&gt; users ;  
    }
    public static class ItemListEvent {  
        public List&lt;Item&gt; items;  
    }    
}  
</code></pre><h5 id="u6DFB_u52A0processor"><a href="#u6DFB_u52A0processor" class="headerlink" title="添加processor"></a>添加processor</h5><p>按照Markus Junginger的说法（EventBus创作者），在3.0中，如果你想进一步提升你的app的性能，你需要添加：</p>
<pre><code>provided &apos;de.greenrobot:eventbus-annotation-processor:3.0.0-beta1&apos;
</code></pre><p>其在编译的时候为注册类构建了一个索引，而不是在运行时，这样的结果是其让EventBus 3.0的性能提升了一倍，相比2.4来说，其会是它的3到6倍。大家可以感受下：<br><img src="https://segmentfault.com/img/bVsgvf" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前一篇文章简单介绍了<code>EventBus 3.0</code>的用法，现在是时候详解其用法了。首先声明，<code>EventBus 3.0</code>的改动针对2.4的改动并不是特别大，但是对于其性能的提升是另外一个说法了，所以建议学习EventBus 3.0。]]>
    
    </summary>
    
      <category term="EventBus" scheme="http://yoursite.com/tags/EventBus/"/>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[EventBus 3.0的用法详解（一）]]></title>
    <link href="http://yoursite.com/2015/06/25/EventBus%203.0%E7%9A%84%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2015/06/25/EventBus 3.0的用法详解（一）/</id>
    <published>2015-06-25T14:01:14.000Z</published>
    <updated>2016-02-19T09:11:57.000Z</updated>
    <content type="html"><![CDATA[<p>看到大家提出的关于Android的问题，有一部分可以用EventBus解决，而也有相当多的人推荐使用<code>EventsBus</code>,因为其和GreenDAO出自一家公司，并且使用它非常的简单，所以现在很多的互联网app都会使用<code>EventsBus</code>来进行消息传递。</p>
<p>基于此，有很多<code>EventBus</code>的文章，写的非常的好，但是由于<code>EventBus</code>已经出了3.0版本，而国内的大多数翻译只是停留在了2.4版本左右，对于那些刚刚接触<code>EventBus</code>的人，从最新版接触学习，是最理想的学习路线。</p>
<p>所以，在这儿，我总结下<code>EventBus3.0</code>的用法。<a id="more"></a></p>
<h3 id="u4EC0_u4E48_u662FEventBus"><a href="#u4EC0_u4E48_u662FEventBus" class="headerlink" title="什么是EventBus"></a>什么是<code>EventBus</code></h3><p><code>EventBus</code>是一个Android端优化的<code>publish/subscribe</code>消息总线，简化了应用程序内各组件间、组件与后台线程间的通信。比如请求网络，等网络返回时通过<code>Handler</code>或<code>Broadcast</code>通知UI，两个<code>Fragment</code>之间需要通过<code>Listener</code>通信，这些需求都可以通过<code>EventBus</code>实现。</p>
<h3 id="EventBus_u6846_u67B6"><a href="#EventBus_u6846_u67B6" class="headerlink" title="EventBus框架"></a>EventBus框架</h3><p>大家谈到EventBus，总会想到<code>greenrobot</code>的<code>EventBus</code>，但是实际上<code>EventBus</code>是一个通用的叫法，例如Google出品的Guava，Guava是一个庞大的库，<code>EventBus</code>只是它附带的一个小功能，因此实际项目中使用并不多。用的最多的是<code>greenrobot/EventBus</code>，这个库的优点是接口简洁，集成方便，但是限定了方法名，不支持注解。另一个库<code>square/otto</code>修改自 <code>Guava</code>，用的人也不少。</p>
<h3 id="u8FD9_u7BC7_u535A_u6587_u6682_u65F6_u53EA_u8BA8_u8BBAgreenrobot_u7684EventBus_u5E93_u3002"><a href="#u8FD9_u7BC7_u535A_u6587_u6682_u65F6_u53EA_u8BA8_u8BBAgreenrobot_u7684EventBus_u5E93_u3002" class="headerlink" title="这篇博文暂时只讨论greenrobot的EventBus库。"></a>这篇博文暂时只讨论greenrobot的EventBus库。</h3><h3 id="u57FA_u672C_u7528_u6CD5"><a href="#u57FA_u672C_u7528_u6CD5" class="headerlink" title="基本用法"></a>基本用法</h3><p>很多文章会讲到<code>Subscriber</code>，以及<code>Publisher</code>和<code>ThreadMode</code>等概念，我觉得暂时没有必要，简单粗暴，直接上代码：</p>
<h4 id="1_u3001_u6DFB_u52A0_u4F9D_u8D56_u5E93_uFF1A"><a href="#1_u3001_u6DFB_u52A0_u4F9D_u8D56_u5E93_uFF1A" class="headerlink" title="1、添加依赖库："></a>1、添加依赖库：</h4><p>首先你要为你的app添加依赖库：</p>
<pre><code>compile &apos;de.greenrobot:eventbus:3.0.0-beta1&apos;
</code></pre><p>有些人会问为什么是beta版本，因为eventbus现阶段3.0版本只处于beta测试阶段。有些人会问如何找到·eventbus 3.0.0·版本，具体添加:</p>
<p><img src="https://segmentfault.com/img/bVr7mp" alt=""></p>
<h4 id="2_u3001_u6CE8_u518C"><a href="#2_u3001_u6CE8_u518C" class="headerlink" title="2、注册"></a>2、注册</h4><p>举个例子，你需要在一个activity中注册eventbus事件，然后定义接收方法，这和Android的广播机制很像，你需要首先注册广播，然后需要编写内部类，实现接收广播，然后操作UI,在EventBus中，你同样需要这么做。</p>
<pre><code>@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    EventBus.getDefault().register(this);

}
@Override
protected void onDestroy() {
    super.onDestroy();
    EventBus.getDefault().unregister(this);
}
</code></pre><h4 id="3_u3001_u8BA2_u9605_u8005"><a href="#3_u3001_u8BA2_u9605_u8005" class="headerlink" title="3、订阅者"></a>3、订阅者</h4><p>类似广播，但是有别于2.4版本，你不必再去约定OnEvent方法开头了（看不懂没关系）：</p>
<pre><code>@Subscribe(threadMode = ThreadMode.MainThread)
public void helloEventBus(String message){
    mText.setText(message);
}
</code></pre><p>该操作很简单，定义了一个hello方法，需要传入String参数，在其中操作UI操作，注意：<br>我们添加了注解@Subscribe，其含义为订阅者，在其内传入了threadMode，我们定义为ThreadMode.MainThread，其含义为该方法在UI线程完成，这样你就不要担心抛出异常啦。是不是很简单？</p>
<h4 id="4_u3001_u53D1_u5E03_u8005"><a href="#4_u3001_u53D1_u5E03_u8005" class="headerlink" title="4、发布者"></a>4、发布者</h4><p>既然你在某个地方订阅了内容，当然就会在某个地方发布消息。举个例子，你的这个activity需要http请求，而http请求你肯定是在异步线程中操作，其返回结果后，你可以这么写：</p>
<pre><code>String json=&quot;&quot;;
EventBus.getDefault().post(json);
</code></pre><p>这样就OK了，你可以试下能否正常运行了！</p>
<h4 id="5_u3001_u539F_u7406_u521D_u63A2"><a href="#5_u3001_u539F_u7406_u521D_u63A2" class="headerlink" title="5、原理初探"></a>5、原理初探</h4><p>你订阅了内容，所以你需要在该类注册EventBus，而你订阅的方法需要传入String,即你的接收信息为String类型，那么在post的时候，你post出去的也应该是String类型，其才会接收到消息。</p>
<h4 id="6_u3001_u5982_u679C_u4F60post_u7684_u662F_u5BF9_u8C61"><a href="#6_u3001_u5982_u679C_u4F60post_u7684_u662F_u5BF9_u8C61" class="headerlink" title="6、如果你post的是对象"></a>6、如果你post的是对象</h4><p>首先你需要定义一个类似pojo类：</p>
<pre><code>public class MessageEvent {
  public final String name;
  public final String password;
  public MessageEvent(String name,String password) {
    this.name = name;
    this.password=password;
  }
}
</code></pre><p>然后你post的时候：</p>
<pre><code>EventBus.getDefault().post(new MessageEvent(&quot;hello&quot;,&quot;world&quot;));
</code></pre><p>当然，你接收的方法也需要改为：</p>
<pre><code>@Subscribe(threadMode = ThreadMode.MainThread)
public void helloEventBus(MessageEvent message){
    mText.setText(message.name);
}
</code></pre><p>疑问，当你post了消息之后，你的订阅者有多个，每一个都接收吗？能否做到指定接收者。</p>
<p>下一章，带来源码解析以及EventBus的高级用法；<br>如果大家有兴趣，也可带领大家编写属于自己的EventBus框架，敬请期待。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>看到大家提出的关于Android的问题，有一部分可以用EventBus解决，而也有相当多的人推荐使用<code>EventsBus</code>,因为其和GreenDAO出自一家公司，并且使用它非常的简单，所以现在很多的互联网app都会使用<code>EventsBus</code>来进行消息传递。</p>
<p>基于此，有很多<code>EventBus</code>的文章，写的非常的好，但是由于<code>EventBus</code>已经出了3.0版本，而国内的大多数翻译只是停留在了2.4版本左右，对于那些刚刚接触<code>EventBus</code>的人，从最新版接触学习，是最理想的学习路线。</p>
<p>所以，在这儿，我总结下<code>EventBus3.0</code>的用法。]]>
    
    </summary>
    
      <category term="EventBus" scheme="http://yoursite.com/tags/EventBus/"/>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android自定义对话框(Dialog)位置,大小]]></title>
    <link href="http://yoursite.com/2015/06/21/%E8%87%AA%E5%AE%9A%E4%B9%89Dialog%E7%9A%84%E5%A4%A7%E5%B0%8F%E3%80%81%E4%BD%8D%E7%BD%AE%E3%80%81%E9%A2%9C%E8%89%B2/"/>
    <id>http://yoursite.com/2015/06/21/自定义Dialog的大小、位置、颜色/</id>
    <published>2015-06-21T14:32:17.000Z</published>
    <updated>2016-02-19T09:06:22.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>代码:</p>
</blockquote>
<pre><code>package angel.devil;
import android.app.Activity;
import android.app.Dialog;
import android.os.Bundle;
import android.view.Gravity;
import android.view.Window;
import android.view.WindowManager;

public class DialogDemoActivity extends Activity {
/** Called when the activity is first created. */
@Override
public void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.main);
Dialog dialog = new Dialog(this);

// setContentView可以设置为一个View也可以简单地指定资源ID
// LayoutInflater
// li=(LayoutInflater)getSystemService(LAYOUT_INFLATER_SERVICE);
// View v=li.inflate(R.layout.dialog_layout, null);
// dialog.setContentView(v);
dialog.setContentView(R.layout.dialog_layout);

dialog.setTitle(&quot;Custom Dialog&quot;);
</code></pre><hr>
<a id="more"></a>
<pre><code>/*
* 获取圣诞框的窗口对象及参数对象以修改对话框的布局设置,
* 可以直接调用getWindow(),表示获得这个Activity的Window
* 对象,这样这可以以同样的方式改变这个Activity的属性.
*/
Window dialogWindow = dialog.getWindow();
WindowManager.LayoutParams lp = dialogWindow.getAttributes();
dialogWindow.setGravity(Gravity.LEFT | Gravity.TOP);

/*
* lp.x与lp.y表示相对于原始位置的偏移.
* 当参数值包含Gravity.LEFT时,对话框出现在左边,所以lp.x就表示相对左边的偏移,负值忽略.
* 当参数值包含Gravity.RIGHT时,对话框出现在右边,所以lp.x就表示相对右边的偏移,负值忽略.
* 当参数值包含Gravity.TOP时,对话框出现在上边,所以lp.y就表示相对上边的偏移,负值忽略.
* 当参数值包含Gravity.BOTTOM时,对话框出现在下边,所以lp.y就表示相对下边的偏移,负值忽略.
* 当参数值包含Gravity.CENTER_HORIZONTAL时
* ,对话框水平居中,所以lp.x就表示在水平居中的位置移动lp.x像素,正值向右移动,负值向左移动.
* 当参数值包含Gravity.CENTER_VERTICAL时
* ,对话框垂直居中,所以lp.y就表示在垂直居中的位置移动lp.y像素,正值向右移动,负值向左移动.
* gravity的默认值为Gravity.CENTER,即Gravity.CENTER_HORIZONTAL |
* Gravity.CENTER_VERTICAL.
*
* 本来setGravity的参数值为Gravity.LEFT | Gravity.TOP时对话框应出现在程序的左上角,但在
* 我手机上测试时发现距左边与上边都有一小段距离,而且垂直坐标把程序标题栏也计算在内了,
* Gravity.LEFT, Gravity.TOP, Gravity.BOTTOM与Gravity.RIGHT都是如此,据边界有一小段距离
*/
lp.x = 100; // 新位置X坐标
lp.y = 100; // 新位置Y坐标
lp.width = 300; // 宽度
lp.height = 300; // 高度
lp.alpha = 0.7f; // 透明度

// 当Window的Attributes改变时系统会调用此函数,可以直接调用以应用上面对窗口参数的更改,也可以用setAttributes
// dialog.onWindowAttributesChanged(lp);
dialogWindow.setAttributes(lp);

/*
* 将对话框的大小按屏幕大小的百分比设置
*/
//        WindowManager m = getWindowManager();
//        Display d = m.getDefaultDisplay(); // 获取屏幕宽、高用
//        WindowManager.LayoutParams p = dialogWindow.getAttributes(); // 获取对话框当前的参数值
//        p.height = (int) (d.getHeight() * ); // 高度设置为屏幕的0.6
//        p.width = (int) (d.getWidth() * 0.65); // 宽度设置为屏幕的0.65
//        dialogWindow.setAttributes(p);

dialog.show();

}
}
</code></pre><blockquote>
<p>布局文件:<br>main.xml</p>
</blockquote>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
android:layout_width=&quot;fill_parent&quot;
android:layout_height=&quot;fill_parent&quot;
android:background=&quot;#00FF00&quot;
android:orientation=&quot;vertical&quot; &gt;

&lt;TextView
android:layout_width=&quot;fill_parent&quot;
android:layout_height=&quot;wrap_content&quot;
android:text=&quot;@string/hello&quot; /&gt;

&lt;/LinearLayout&gt;

dialog_layout.xml

&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
android:id=&quot;@+id/layout_root&quot;
android:layout_width=&quot;fill_parent&quot;
android:layout_height=&quot;fill_parent&quot;
android:orientation=&quot;horizontal&quot;
android:padding=&quot;10dp&quot; &gt;

&lt;ImageView
android:id=&quot;@+id/image&quot;
android:layout_width=&quot;wrap_content&quot;
android:layout_height=&quot;wrap_content&quot;
android:layout_marginRight=&quot;10dp&quot;
android:src=&quot;@drawable/ic_launcher&quot; /&gt;

&lt;TextView
android:id=&quot;@+id/text&quot;
android:layout_width=&quot;wrap_content&quot;
android:layout_height=&quot;wrap_content&quot;
android:text=&quot;A Dialog&quot;
android:textColor=&quot;#FFF&quot; /&gt;

&lt;/LinearLayout&gt;
</code></pre><blockquote>
<p>取消自定义dialog的标题栏</p>
</blockquote>
<p>Android中取消自定义dialog的标题栏, 只需在</p>
<pre><code>dialog.setContentView(R.layout.popwin_chooseversion);
</code></pre><p>前面加一句:</p>
<pre><code>dialog.requestWindowFeature(Window.FEATURE_NO_TITLE);
</code></pre><p>加在这句之后会产生异常.</p>
<p>还要导入</p>
<pre><code>import android.view.Window;
</code></pre><p>包.</p>
<h3 id="android__u5982_u4F55_u8BA9_u81EA_u5B9A_u4E49dialog_u7684_u5BBD_u5EA6_u5145_u6EE1_u6574_u4E2A_u5C4F_u5E55"><a href="#android__u5982_u4F55_u8BA9_u81EA_u5B9A_u4E49dialog_u7684_u5BBD_u5EA6_u5145_u6EE1_u6574_u4E2A_u5C4F_u5E55" class="headerlink" title="android 如何让自定义dialog的宽度充满整个屏幕"></a>android 如何让自定义dialog的宽度充满整个屏幕</h3><h4 id="u65B9_u6848_uFF1A"><a href="#u65B9_u6848_uFF1A" class="headerlink" title="方案："></a>方案：</h4><p>  通过设置Dialog的样式实现</p>
<h5 id="u6B65_u9AA4_uFF1A"><a href="#u6B65_u9AA4_uFF1A" class="headerlink" title="步骤："></a>步骤：</h5><blockquote>
<p>1、添加style</p>
</blockquote>
<pre><code>&lt;style name=&quot;Dialog_FS&quot;&gt;
&lt;item name=&quot;android:windowFullscreen&quot;&gt;true&lt;/item&gt; //设置填充父窗体
&lt;item name=&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt; //设置隐藏标题栏
&lt;/style&gt;
</code></pre><blockquote>
<p>2、代码里面设置dialog的样式</p>
</blockquote>
<pre><code>Dialog dialog = new Dialog(this,R.style.Dialog_FS); //设置全屏样式
dialog.setContentView(R.layout.main); //设置dialog的布局
dialog.show();//显示dialog界面
</code></pre><blockquote>
<p>3.style文件具体</p>
</blockquote>
<pre><code>  &lt;style name=&quot;iphone_progress_dialog&quot; parent=&quot;@android:style/Theme.Dialog&quot;&gt;
     &lt;item name=&quot;android:windowFrame&quot;&gt;@null&lt;/item&gt; &lt;!--Dialog的windowFrame框为无--&gt; 
     &lt;item name=&quot;android:windowIsFloating&quot;&gt;true&lt;/item&gt;&lt;!-- 是否漂现在activity上--&gt;
     &lt;item name=&quot;android:windowIsTranslucent&quot;&gt;true&lt;/item&gt;&lt;!-- 是否半透明 --&gt;
     &lt;item name=&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt;
     &lt;item name=&quot;android:backgroundDimEnabled&quot;&gt;false&lt;/item&gt;&lt;!-- dim:模糊的 阴影效果 --&gt;
     &lt;item name=&quot;android:windowBackground&quot;&gt;@drawable/load_bg&lt;/item&gt;&lt;!-- 背景图片的大小也影响窗口的大小 --&gt;
&lt;/style&gt;
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>代码:</p>
</blockquote>
<pre><code>package angel.devil;
import android.app.Activity;
import android.app.Dialog;
import android.os.Bundle;
import android.view.Gravity;
import android.view.Window;
import android.view.WindowManager;

public class DialogDemoActivity extends Activity {
/** Called when the activity is first created. */
@Override
public void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.main);
Dialog dialog = new Dialog(this);

// setContentView可以设置为一个View也可以简单地指定资源ID
// LayoutInflater
// li=(LayoutInflater)getSystemService(LAYOUT_INFLATER_SERVICE);
// View v=li.inflate(R.layout.dialog_layout, null);
// dialog.setContentView(v);
dialog.setContentView(R.layout.dialog_layout);

dialog.setTitle(&quot;Custom Dialog&quot;);
</code></pre><hr>]]>
    
    </summary>
    
      <category term="Dialog" scheme="http://yoursite.com/tags/Dialog/"/>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[端口号设置]]></title>
    <link href="http://yoursite.com/2015/01/21/%E7%AB%AF%E5%8F%A3%E5%8F%B7/"/>
    <id>http://yoursite.com/2015/01/21/端口号/</id>
    <published>2015-01-21T15:33:02.000Z</published>
    <updated>2016-04-05T06:10:37.000Z</updated>
    <content type="html"><![CDATA[<p>##端口号被占用</p>
<p>假如我们需要确定谁占用了我们的9050端口 </p>
<p>Windows平台 </p>
<p>在windows命令行窗口下执行：<br>1.查看所有的端口占用情况</p>
<pre><code>C:\&gt;netstat -ano
协议    本地地址                     外部地址               状态                   PID
TCP    127.0.0.1:1434         0.0.0.0:0              LISTENING       3236
TCP    127.0.0.1:5679         0.0.0.0:0              LISTENING       4168
TCP    127.0.0.1:7438         0.0.0.0:0              LISTENING       4168
TCP    127.0.0.1:8015         0.0.0.0:0              LISTENING       1456
TCP    192.168.3.230:139      0.0.0.0:0              LISTENING       4
TCP    192.168.3.230:1957     220.181.31.225:443     ESTABLISHED     3068
TCP    192.168.3.230:2020     183.62.96.189:1522     ESTABLISHED     1456
TCP    192.168.3.230:2927     117.79.91.18:80        ESTABLISHED     4732
TCP    192.168.3.230:2929     117.79.91.18:80        ESTABLISHED     4732
TCP    192.168.3.230:2930     117.79.91.18:80        ESTABLISHED     4732
TCP    192.168.3.230:2931     117.79.91.18:80        ESTABLISHED     4732
</code></pre><p>2.查看指定端口的占用情况</p>
<pre><code>C:\&gt;netstat -aon|findstr &quot;9050&quot;
协议    本地地址                     外部地址               状态                   PID
TCP    127.0.0.1:9050         0.0.0.0:0              LISTENING       2016
P: 看到了吗，端口被进程号为2016的进程占用，继续执行下面命令： （也可以去任务管理器中查看pid对应的进程）
</code></pre><p>3.查看PID对应的进程</p>
<pre><code>C:\&gt;tasklist|findstr &quot;2016&quot;
映像名称                       PID 会话名              会话#       内存使用
========================= ======== ================
tor.exe                     2016 Console                 0     16,064 K 

P:很清楚吧，tor占用了你的端口。
</code></pre><p>4.结束该进程</p>
<pre><code>C:\&gt;taskkill /f /t /im tor.exe
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>##端口号被占用</p>
<p>假如我们需要确定谁占用了我们的9050端口 </p>
<p>Windows平台 </p>
<p>在windows命令行窗口下执行：<br>1.查看所有的端口占用情况</p>
<pre><code>C:\&gt;netstat -ano
协议 ]]>
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android AsyncTask 技巧]]></title>
    <link href="http://yoursite.com/2014/11/07/Android%20AsyncTask%20%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2014/11/07/Android AsyncTask 技巧/</id>
    <published>2014-11-07T15:23:14.000Z</published>
    <updated>2016-02-22T05:44:14.000Z</updated>
    <content type="html"><![CDATA[<h4 id="AsyncTask_u7684_u539F_u7406"><a href="#AsyncTask_u7684_u539F_u7406" class="headerlink" title="AsyncTask的原理"></a>AsyncTask的原理</h4><p>其实AsyncTask的原理简单来说，就是：</p>
<ul>
<li>一个任务队：用于存放自定义的（WorkerRunnable）。</li>
<li>一个线程池：初始化好任务队列，放入该线程池中。</li>
<li>一个内部Handler：用于提供线程池执行线程时与主线程之间的交互（刷新控件各种）。</li>
</ul>
<a id="more"></a>
<p>AsyncTask.execute(…)时，会启动AsyncTask的线程池，开始执行池中的任务队。只有doInBackground()在线程池中的线程执行，所以不能更新主UI线程的控件，剩下的onProgressUpdate()、onPostExecute()、onCancelled()、onPreExecute()在主UI线程中。onPreExecute()比较特殊的地方就是，它是主线程自己调用的。</p>
<p>这是execute()就直接走到的executeOnExecutor()源码：</p>
<pre><code>public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec,
        Params... params) {
    if (mStatus != Status.PENDING) {
        switch (mStatus) {
            case RUNNING:
                throw new IllegalStateException(&quot;Cannot execute task:&quot;
                        + &quot; the task is already running.&quot;);
            case FINISHED:
                throw new IllegalStateException(&quot;Cannot execute task:&quot;
                        + &quot; the task has already been executed &quot;
                        + &quot;(a task can be executed only once)&quot;);
        }
    }

    mStatus = Status.RUNNING;

    onPreExecute();

    mWorker.mParams = params;
    exec.execute(mFuture);

    return this;
}
</code></pre><p>其他的onProgressUpdate()、onPostExecute()、onCancelled()都经由InternalHandler调用。</p>
<pre><code>private static class InternalHandler extends Handler {
    public InternalHandler() {
        super(Looper.getMainLooper());
    }

    @SuppressWarnings({&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;})
    @Override
    public void handleMessage(Message msg) {
        AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;
        switch (msg.what) {
            case MESSAGE_POST_RESULT:
                // There is only one result
                result.mTask.finish(result.mData[0]);
                break;
            case MESSAGE_POST_PROGRESS:
                result.mTask.onProgressUpdate(result.mData);
                break;
        }
    }
}
</code></pre><p>这里就是各种sendMessage(…)后的转发，最明显是是看到了onProgressUpdate()；</p>
<p>然后onPostExecute()、onCancelled()就在finish()中再次转发</p>
<pre><code>private void finish(Result result) {
    if (isCancelled()) {
        onCancelled(result);
    } else {
        onPostExecute(result);
    }
    mStatus = Status.FINISHED;
}
</code></pre><p>综上，就是内置一个线程池既花式又完美的sendMessage(…)给内部Handler处理的二次封装类<br>AsyncTask 模板</p>
<h4 id="ProgressBarAsyncTask_uFF1A"><a href="#ProgressBarAsyncTask_uFF1A" class="headerlink" title="ProgressBarAsyncTask："></a>ProgressBarAsyncTask：</h4><pre><code>/**
 * Description：
 * Created by：CaMnter
 * Time：2015-09-17 14:19
 */
public class ProgressBarAsyncTask extends AsyncTask&lt;String, Integer, String&gt; {

    private TextView textview;
    private ProgressBar progressBar;

    public ProgressBarAsyncTask(ProgressBar progressBar, TextView textview) {
        super();
        this.textview = textview;
        this.progressBar = progressBar;

    }

    /**
     * 对应AsyncTask第一个参数
     * 异步操作，不在主UI线程中，不能对控件进行修改
     * 可以调用publishProgress方法中转到onProgressUpdate(这里完成了一个handler.sendMessage(...)的过程)
     *
     * @param params The parameters of the task.
     * @return A result, defined by the subclass of this task.
     * @see #onPreExecute()
     * @see #onPostExecute
     * @see #publishProgress
     */
    @Override
    protected String doInBackground(String... params) {
        int i = 0;
        for (; i &lt; 100; i++) {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            this.publishProgress(i);
        }
        return i + params[0];
    }

    /**
     * 对应AsyncTask第二个参数
     * 在doInBackground方法当中，每次调用publishProgress方法都会中转(handler.sendMessage(...))到onProgressUpdate
     * 在主UI线程中，可以对控件进行修改
     *
     * @param values The values indicating progress.
     * @see #publishProgress
     * @see #doInBackground
     */
    @Override
    protected void onProgressUpdate(Integer... values) {
        int value = values[0];
        this.progressBar.setProgress(value);
        this.textview.setText(value+&quot;%&quot;);
    }

    /**
     * 对应AsyncTask第三个参数 (接受doInBackground的返回值)
     * 在doInBackground方法执行结束之后在运行，此时已经回来主UI线程当中 能对UI控件进行修改
     *
     * @param s The result of the operation computed by {@link #doInBackground}.
     * @see #onPreExecute
     * @see #doInBackground
     * @see #onCancelled(Object)
     */
    @Override
    protected void onPostExecute(String s) {
        this.textview.setText(&quot;执行结束：&quot; + s);
    }

    /**
     * 运行在主UI线程中，此时是预执行状态，下一步是doInBackground
     *
     * @see #onPostExecute
     * @see #doInBackground
     */
    @Override
    protected void onPreExecute() {
        super.onPreExecute();
    }

    /**
     * &lt;p&gt;Applications should preferably override {@link #onCancelled(Object)}.
     * This method is invoked by the default implementation of
     * {@link #onCancelled(Object)}.&lt;/p&gt;
     * &lt;p/&gt;
     * &lt;p&gt;Runs on the UI thread after {@link #cancel(boolean)} is invoked and
     * {@link #doInBackground(Object[])} has finished.&lt;/p&gt;
     *
     * @see #onCancelled(Object)
     * @see #cancel(boolean)
     * @see #isCancelled()
     */
    @Override
    protected void onCancelled() {
        super.onCancelled();
    }

}
</code></pre><h4 id="Activity_uFF1A"><a href="#Activity_uFF1A" class="headerlink" title="Activity："></a>Activity：</h4><pre><code>ProgressBarAsyncTask asyncTask = new ProgressBarAsyncTask(this.progressBar, this.textview);
asyncTask.execute(&quot;%&quot;);
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h4 id="AsyncTask_u7684_u539F_u7406"><a href="#AsyncTask_u7684_u539F_u7406" class="headerlink" title="AsyncTask的原理"></a>AsyncTask的原理</h4><p>其实AsyncTask的原理简单来说，就是：</p>
<ul>
<li>一个任务队：用于存放自定义的（WorkerRunnable）。</li>
<li>一个线程池：初始化好任务队列，放入该线程池中。</li>
<li>一个内部Handler：用于提供线程池执行线程时与主线程之间的交互（刷新控件各种）。</li>
</ul>]]>
    
    </summary>
    
      <category term="AsyncTask" scheme="http://yoursite.com/tags/AsyncTask/"/>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
</feed>
