<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[熊凯的个人博客]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://apanda.club/"/>
  <updated>2016-04-10T08:45:45.000Z</updated>
  <id>http://apanda.club/</id>
  
  <author>
    <name><![CDATA[熊凯]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[使用AndroidStudio进行NDK开发（一）]]></title>
    <link href="http://apanda.club/2016/04/09/Android%20Skills/%E4%BD%BF%E7%94%A8Android%20Studio%E8%BF%9B%E8%A1%8CNDK%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://apanda.club/2016/04/09/Android Skills/使用Android Studio进行NDK开发（一）/</id>
    <published>2016-04-09T05:12:17.000Z</published>
    <updated>2016-04-10T08:45:45.000Z</updated>
    <content type="html"><![CDATA[<p>在AndroidStudio中进行开发比起以往的Eclipse要方便的多，下面来介绍下如何使用AndroidStudio这个IDE工具实现相关开发工作。</p>
<ol>
<li>准备工作</li>
</ol>
<p>在实际写代码之前，首先我们还是需要做一些准备工作：</p>
<p>下载开发包：Android官方下载页面<br>配置系统环境变量<br>下载好开发包之后，直接解压到任意目录，然后需要配置一下系统环境变量，之所以要配置环境变量，是为了方便使用命令ndk-build脚本进行编译。配置参考如下：</p>
<pre><code># 在.bash_profile中配置如下代码
</code></pre><p>export ANDROID_NDK/Users/liangqi/android-ndk<br>export PATH$ANDROID_NDK$PATH</p>
<pre><code># 然后执行如下代码，更新配置文件
</code></pre><p>source .bash_profile<br>其实编译C/C++代码不一定在AndroidStudio中，如果配置好环境变量，直接使用进入项目中的目录执行ndk-build命令即可在当前目录下生成一个的目录，里面存放了不同 平台的包，当然运行这个命令的前提是，这个目录下至少得有一个Android.mk文件，如果需要指定具体的编译平台，那么还需要添加一个Application.mk文件，当然，如果命令行让你头疼，那么你可以采用gradle的方式来解决这些问题，接下来我们将分别介绍这些使用方式。<br><a id="more"></a></p>
<ol>
<li>项目配置</li>
</ol>
<p>使用AndroidStudio开发前我们也要做点额外工作，我们需要在项目根目录下local.properties中添加编译的路径：</p>
<p>ndkdirUsersliangqiandroidndk<br>如果这个文件不存在，你可以手动生成一个，然后再添加上述内容即可。完成这个步骤之后，我们就可以正式开始着手相关的开发工作了。之所以要配置这个目录，目的是让我们开发的项目在使用gradle编译时能够找到<code>NDK</code>相关编译路径</p>
<p>那么，接下来的工作也分为两种情况：</p>
<p>没有（C/C++）源码，别人已经提供好相应的文件，不需要编译代码<br>拥有（C/C++）源码，需要自己编译文件<br>2.1 已有.SO文件，不需要编译源码</p>
<p>这类情况是最简单的，文件以及被其他人员编译好，或者是第三方库来提供的，那么我们只需要把相应文件放到AndroidStudio目录src/main/jniLibs/下即可，当然，肯定需要按CPU架构分不同的子目录，例如，如下：</p>
<p><img src="https://p1.jscssimg.com/a61e938a106e7abf.png" alt=""><br>jniLibs是AndroidStudio默认提供的目录，用来存放已经编译好的文件，当然你也可以放在任意自定义目录下，例如src/main/libs，然后在build.gradle中指定相应的资源目录位置即可：</p>
<p>android<br>    sourceSetsmain<br>        // 你的.so库的实际路径<br>        jniLibssrcDir ‘src/main/libs’ </p>
<p>在导入文件完成之后，那么你可以在相应的类文件中，加载这个静态库，一般来说，文件如果由第三方提供，他在提供文件的同时也会提供相应的调用类文件，或者按之前双方定好的规则自己创建相应类文件，并生成相应的方法，之所以要约定好只因为，下的C/C++函数和桥接的函数命名是有约束的，规则如下：</p>
<p>Java_PackageName_ClassName_MethodName<br>双方必须按这个规则来实现或者调用此函数，否则不会成功，例如，我们现在有一个函数：String stringFromJNI()的函数，它在com.example.hellojni.HelloJni这个文件下，这个函数用来返回一个字符串，功能由底层来实现，那么相应的语言开发文件中就必须按上述规则命名一个Java_com_example_hellojni_HelloJni_stringFromJNI( JNIEnv* env, jobject thiz )的函数，并返回一个字符串结果：</p>
<p>#include </p>
<p>#include<br>// 函数名格式必须按规矩来<br>jstring Java_com_example_hellojni_HelloJni_stringFromJNI JNIEnv env jobject thiz </p>
<pre><code>return env-&gt;NewStringUTFenv &quot;Hello from JNI !  Compiled with ABI &quot; ABI 
</code></pre><p>同样对应的文件也必须：</p>
<p>文件必须在com.example.hellojni包名下<br>类文件名必须是HelloJni<br>方法名必须是stringFromJNI<br>package comexamplehellojni</p>
<p>class HelloJni<br>     public static native String stringFromJNI</p>
<pre><code>static 
    // 加载 hellojni.so静态块
    SystemloadLibrary&quot;hellojni&quot;
</code></pre><p>2.2 有源码，需要编译.so文件</p>
<p>如果有C/C++源码，没有文件，那么我们就得手动把源码文件编译成文件，编译的方式也分为两种：</p>
<p>手工执行命令经行编译<br>使用gradle脚本自动实现编译<br>AndroidStudio默认的源码存放目录是:</p>
<p>src/main/jni<br>如果你没发现此目录，那么你可以手动创建一个，把所有的C/C++源码放在此文件下，当然并非必须要放在此目录下，你可以自定义目录，然后在build.gradle中做一个资源路径指定即可：</p>
<p>// build.gradle<br>android<br>    sourceSetsmain<br>        // 你的源码目录<br>        jnisrcDir ‘src/main/otherDir’ </p>
<p>2.2.1 手工执行命令经行编译</p>
<p>在使用手工编译（C/C++）文件之前，我们要回到文章开头部分，我们需要配置好系统环境变量，这样我们才能在系统环境下执行ndk相关编译命令，如果您的环境变量还没有配置，那么可以参考下文章开头部分，如果已经做好这部分工作，那么咱们继续。</p>
<p>接下来，我们还要创建如下两个文件：</p>
<p>Android.mk<br>Applicatoin.mk (非必要)<br>2.2.1.1 创建Android.mk</p>
<p>Android.mk文件用来指定源码编译的配置信息，例如工作目录，编译模块的名称，参与编译的文件等，大致内容如下：</p>
<p>LOCAL_PATH         $call mydir<br>include              $CLEAR_VARS<br>LOCAL_MODULE       hello_jni<br>LOCAL_SRC_FILES    hello_jnic<br>include              $BUILD_SHARED_LIBRARY<br>LOCAL_PATH：设置工作目录，而my-dir则会返回Android.mk文件所在的目录。<br>CLEAR——VARS：清除几乎所有以LOCAL——PATH开头的变量（不包括LOCAL_PATH）。<br>LOCAL_MODULE：用来设置模块的名称。<br>LOCAL_SRC_FILES：用来指定参与模块编译的C/C++源文件名。<br>BUILD_SHARED_LIBRARY：作用是指定生成的静态库或者共享库在运行时依赖的共享库模块列表。<br>2.2.1.2 创建Application.mk</p>
<p>这个文件用来配置编译平台相关内容，我们最常用的估计只是APP_ABI字段，它用来指定我们需要基于哪些CPU架构的文件，当然你可以配置多个平台：</p>
<p>APP_ABI  armeabi armeabiv7a x86 mips<br>如果不创建Application.mk文件，那么手动编译的文件只有armeabi平台一个版本，其他平台的不会被编译。</p>
<p>假设我们配置好了Android.mk文件，那么接下来我们就可以执行如下命令来生成文件了，我们假设开发NDK的目录为默认目录：</p>
<p> src/main/jni/<br>ndk-build<br>如果顺利，那么你将会看到，在src/main/目录下会多了一个目录，这是使用命令编译文件的生成的默认目录，而AndroidSutdio默认加载的目录是jniLibs，那么你有两种解决方式：</p>
<p>配置build.gradle资源目录，参见文章2.1小节<br>使用 ndk-build NDK_LIBS_OUT=../jniLibs 指定具体的输出目录<br>当你得到了文件，那么接下来就是在文件中调用执行即可，如果想了解更多ndk-build命令内容，可参见：Android ndk-build 使用文档</p>
<p>2.2.2 使用gradle脚本</p>
<p>当然该机器做的事我们还是尽量让机器来做，因此，接下来我打算使用build.gradle来添加一些配置，让Gradle自动帮我完成编译工作，这简直就是爽歪歪啦！</p>
<p>使用gradle,你再也不用手动添加Android.mk和Application.mk文件，一切在build.gradle文件中就都能搞定，在这里我们直接贴出build.gradle中相关的配置：</p>
<pre><code>androidndk 
    // 模块名称
    moduleName  &quot;hello-jni&quot;

    // 指定编译平台，更多平台信息 参见https://developer.android.com/ndk/guides/abis.html#sa
    abiFilters &quot;armeabi&quot; &quot;armeabi-v7a&quot;
    /*
     * Other ndk flags configurable here are
     * cppFlags.add(&quot;-fno-rtti&quot;)
     * cppFlags.add(&quot;-fno-exceptions&quot;)
     * ldLibs.addAll([&quot;android&quot;, &quot;log&quot;])
     * stl       = &quot;system&quot;
     */
</code></pre><p>使用gradle的好处是，自动编译生成文件，并且把相关的文件打包到安装包中，一劳永逸。<br>MeasureMeasure</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在AndroidStudio中进行开发比起以往的Eclipse要方便的多，下面来介绍下如何使用AndroidStudio这个IDE工具实现相关开发工作。</p>
<ol>
<li>准备工作</li>
</ol>
<p>在实际写代码之前，首先我们还是需要做一些准备工作：</p>
<p>下载开发包：Android官方下载页面<br>配置系统环境变量<br>下载好开发包之后，直接解压到任意目录，然后需要配置一下系统环境变量，之所以要配置环境变量，是为了方便使用命令ndk-build脚本进行编译。配置参考如下：</p>
<pre><code># 在.bash_profile中配置如下代码
</code></pre><p>export ANDROID_NDK/Users/liangqi/android-ndk<br>export PATH$ANDROID_NDK$PATH</p>
<pre><code># 然后执行如下代码，更新配置文件
</code></pre><p>source .bash_profile<br>其实编译C/C++代码不一定在AndroidStudio中，如果配置好环境变量，直接使用进入项目中的目录执行ndk-build命令即可在当前目录下生成一个的目录，里面存放了不同 平台的包，当然运行这个命令的前提是，这个目录下至少得有一个Android.mk文件，如果需要指定具体的编译平台，那么还需要添加一个Application.mk文件，当然，如果命令行让你头疼，那么你可以采用gradle的方式来解决这些问题，接下来我们将分别介绍这些使用方式。<br>]]>
    
    </summary>
    
      <category term="RxJava" scheme="http://apanda.club/tags/RxJava/"/>
    
      <category term="技术" scheme="http://apanda.club/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[RxJava & RxAndroid备忘]]></title>
    <link href="http://apanda.club/2016/04/06/RxJava/RxJava%20&%20RxAndroid%E5%A4%87%E5%BF%98/"/>
    <id>http://apanda.club/2016/04/06/RxJava/RxJava & RxAndroid备忘/</id>
    <published>2016-04-05T17:14:17.000Z</published>
    <updated>2016-04-10T10:08:43.000Z</updated>
    <content type="html"><![CDATA[<pre><code>来源 &lt;http://chenqichao.me/2015/07/01/119-Mastering-RxAndroid/&gt; 
</code></pre><p>今天在刷G+的时候看到Dave Smith推荐了一个视频<a href="https://www.youtube.com/watch?v=k3D0cWyNno4" target="_blank" rel="external">《Learning RxJava (for Android) by example》</a>点进去看了一下，原来是位熟悉的”阿三哥”，视频封面如下：（没有歧视的意思，不要喷我啊~，为什么感到熟悉？接着往下看）</p>
<p><a href="http://7mnllc.com1.z0.glb.clouddn.com/kp.png" target="_blank" rel="external"></a></p>
<p><a href="http://7mnllc.com1.z0.glb.clouddn.com/kp.png" target="_blank" rel="external"><img src="http://7mnllc.com1.z0.glb.clouddn.com/kp.png" alt=""></a></p>
<p>几乎同时也看到了JetBrains在G+也推荐了篇在Medium上的博文<a href="https://medium.com/@ahmedrizwan/rxandroid-and-kotlin-part-1-f0382dc26ed8" target="_blank" rel="external">《RxAndroid And Kotlin (Part 1)》</a>，然后想到前几天转了InfoQ上的<a href="http://www.infoq.com/cn/news/2015/06/Android-JVM-JetBrains-Kotlin" target="_blank" rel="external">《Kotlin：Android世界的Swift》</a>，再加上隐约记得之前在AndroidCN看到过<a href="http://weibo.com/brucefromsdu" target="_blank" rel="external">@hi大头鬼hi</a>写的《深入浅出RxJava》，最后还想到了这篇<a href="http://www.jianshu.com/p/a7fadc79e0fb" target="_blank" rel="external">《Kotlin在Android工程中的应用》</a>，Holy shit…大脑能瞬间闪过这么多关联的文章和博文，于是把这些资料找了出来，觉得有必要把这些内容记下来，<br>方便日后查阅，因此有了今天这篇文章，取名叫《RxJava &amp; RxAndroid备忘》是希望列出的参考资料能让大家尽快熟悉和掌握了RxJava和RxAndroid。</p>
<p>等等..还没解释为什么对这位阿三哥的声音感到熟悉呢? 其实是因为之前听过也推荐过Kaushik Gopal和他的小伙伴Donn Felker录制的关于Android开发的Podcast《FragmentedPodcast》，每一集都很精彩（目前更新到第十期），感兴趣的可以关注他们。唯一的需要克服的就是三哥的英语口音…另外，真心觉得这种类型的Podcast很不错，类似还有官方团队Chet和Tor录制的《Android Backstage》，虽然国内也有类似《内核恐慌》的技术播客，但只是针对Android或者iOS的目前并没有发现（如果你有推荐可以直接评论或者联系我），再者就是希望以后开始工作了可以找到同样感兴趣的人，可以一起来做这样有趣的事情。<br><a id="more"></a><br><a href="http://7mnllc.com1.z0.glb.clouddn.com/fragmented-logo.png" target="_blank" rel="external"></a></p>
<p><a href="http://7mnllc.com1.z0.glb.clouddn.com/fragmented-logo.png" target="_blank" rel="external"><img src="http://7mnllc.com1.z0.glb.clouddn.com/fragmented-logo.png" alt=""></a></p>
<p>首先需要明确一个观点：Rx并不是一种新的语言，而是一种普通的Java模式，类似于观察者模式（Observer Pattern），可以将它看作一个普通的Java类库，因此你可以立即使用RxJava。而RxAndroid是RxJava的一个针对Android平台的扩展，主要用于 Android 开发。《深入浅出RxJava》系列的四篇文章已经非常详细的介绍了Rx的相关内容，所以建议大家直接可以先点进去仔细阅读一下~，</p>
<p><a href="http://7mnllc.com1.z0.glb.clouddn.com/RxJava-Android.jpg" target="_blank" rel="external"></a></p>
<p><a href="http://7mnllc.com1.z0.glb.clouddn.com/RxJava-Android.jpg" target="_blank" rel="external"><img src="http://7mnllc.com1.z0.glb.clouddn.com/RxJava-Android.jpg" alt=""></a></p>
<p>下面列出参考链接（如你有需要补充的可以直接评论~）</p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>来源 &lt;http://chenqichao.me/2015/07/01/119-Mastering-RxAndroid/&gt; 
</code></pre><p>今天在刷G+的时候看到Dave Smith推荐了一个视频<a href="https://www.youtube.com/watch?v=k3D0cWyNno4">《Learning RxJava (for Android) by example》</a>点进去看了一下，原来是位熟悉的”阿三哥”，视频封面如下：（没有歧视的意思，不要喷我啊~，为什么感到熟悉？接着往下看）</p>
<p><a href="http://7mnllc.com1.z0.glb.clouddn.com/kp.png"></a></p>
<p><a href="http://7mnllc.com1.z0.glb.clouddn.com/kp.png"><img src="http://7mnllc.com1.z0.glb.clouddn.com/kp.png" alt=""></a></p>
<p>几乎同时也看到了JetBrains在G+也推荐了篇在Medium上的博文<a href="https://medium.com/@ahmedrizwan/rxandroid-and-kotlin-part-1-f0382dc26ed8">《RxAndroid And Kotlin (Part 1)》</a>，然后想到前几天转了InfoQ上的<a href="http://www.infoq.com/cn/news/2015/06/Android-JVM-JetBrains-Kotlin">《Kotlin：Android世界的Swift》</a>，再加上隐约记得之前在AndroidCN看到过<a href="http://weibo.com/brucefromsdu">@hi大头鬼hi</a>写的《深入浅出RxJava》，最后还想到了这篇<a href="http://www.jianshu.com/p/a7fadc79e0fb">《Kotlin在Android工程中的应用》</a>，Holy shit…大脑能瞬间闪过这么多关联的文章和博文，于是把这些资料找了出来，觉得有必要把这些内容记下来，<br>方便日后查阅，因此有了今天这篇文章，取名叫《RxJava &amp; RxAndroid备忘》是希望列出的参考资料能让大家尽快熟悉和掌握了RxJava和RxAndroid。</p>
<p>等等..还没解释为什么对这位阿三哥的声音感到熟悉呢? 其实是因为之前听过也推荐过Kaushik Gopal和他的小伙伴Donn Felker录制的关于Android开发的Podcast《FragmentedPodcast》，每一集都很精彩（目前更新到第十期），感兴趣的可以关注他们。唯一的需要克服的就是三哥的英语口音…另外，真心觉得这种类型的Podcast很不错，类似还有官方团队Chet和Tor录制的《Android Backstage》，虽然国内也有类似《内核恐慌》的技术播客，但只是针对Android或者iOS的目前并没有发现（如果你有推荐可以直接评论或者联系我），再者就是希望以后开始工作了可以找到同样感兴趣的人，可以一起来做这样有趣的事情。<br>]]>
    
    </summary>
    
      <category term="RxJava" scheme="http://apanda.club/tags/RxJava/"/>
    
      <category term="技术" scheme="http://apanda.club/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在安卓上使用RxJava]]></title>
    <link href="http://apanda.club/2016/04/05/RxJava/%E5%9C%A8%E5%AE%89%E5%8D%93%E4%B8%8A%E4%BD%BF%E7%94%A8RxJava/"/>
    <id>http://apanda.club/2016/04/05/RxJava/在安卓上使用RxJava/</id>
    <published>2016-04-05T15:45:17.000Z</published>
    <updated>2016-04-10T09:47:07.000Z</updated>
    <content type="html"><![CDATA[<p>如果你做过Android（和Java）的开发，很有可能已经听说过RxJava了。RxJava是由Netflix开发的响应式扩展（Reactive Extensions）的Java实现。引用<a href="http://msdn.microsoft.com/en-us/data/gg577609.aspx" target="_blank" rel="external">MSDN上对它的定义</a>，Reactive Extensions是这样一个第三方库：<strong>它结合了可观察集合和LINQ式查询以达到异步和基于事件的编程效果</strong>。Netflix将这个库托管到了Github上，支持Java6以上的版本并且使它可以用于Android App开发。</p>
<p>本篇是介绍RxJava和Android的系列文章的第一篇，将会介绍如何在Android中使用RxJava observables（基于Square的Retrofit组件）创建REST API客户端。</p>
<p>我们从添加所需的库文件开始。如果你用Maven的话，只需将下面的dependencies（依赖库）加到pom.xml中即可：</p>
<pre><code>`&lt;dependency&gt;`
`&lt;groupId&gt;com.squareup.retrofit&lt;/groupId&gt;`
`&lt;artifactId&gt;retrofit&lt;/artifactId&gt;`
`&lt;version&gt;1.2.2&lt;/version&gt;`
`&lt;/dependency&gt;`
`&lt;dependency&gt;`
`&lt;groupId&gt;com.netflix.rxjava&lt;/groupId&gt;`
`&lt;artifactId&gt;rxjava-android&lt;/artifactId&gt;`
`&lt;version&gt;0.14.6&lt;/version&gt;`s
`&lt;/dependency&gt;`
</code></pre><a id="more"></a>
<p>在本文中，我们将用气象地图开放平台（OpenWeatherMap） API作为演示示例。 <a href="http://api.openweathermap.org/" target="_blank" rel="external">OpenWeatherMap</a>是一个免费的天气数据API，非常易于配置和使用，调用时只需传入位置信息（城市名或者是地理坐标）作为参数即可，具体效果请参见这个<a href="http://api.openweathermap.org/data/2.5/weather?q=Budapest,hu" target="_blank" rel="external">示例</a>。它默认传输的是JSON格式的数据（但也可以配置为XML或HTML格式）。精度和温度单位也是可以配置的，更多详情请看<a href="http://api.openweathermap.org/API" target="_blank" rel="external">这里</a>。</p>
<p>通常要实现调用一个API需要如下这几个步骤（每个步骤都有一堆公式化代码）：</p>
<ol>
<li>创建所需的模型类（必要时，添加上注解）。</li>
<li>实现请求—回应管理的网络层代码，并带错误处理。</li>
<li>用后台线程实现请求调用（一般是用异步任务的形式实现），用一个回调函数（Callback Function）来实现在UI线程上呈现回应信息。</li>
</ol>
<p><strong>创建模型类</strong></p>
<p>第一步我们可以依靠一些类似<a href="http://www.jsonschema2pojo.org/" target="_blank" rel="external">jsonschema2pojo</a>的JSON-POJO生成工具（半）自动化完成。OpenWeather API的模型类如下：</p>
<p><code>public class WeatherData {</code></p>
<p><code>public Coordinates coord;</code></p>
<p><code>public Local sys;</code></p>
<p><code>public List&lt;Weather&gt; weathers;</code></p>
<p><code>public String base;</code></p>
<p><code>public Main main;</code></p>
<p><code>public Wind wind;</code></p>
<p><code>public Rain rain;</code></p>
<p><code>public Cloud clouds;</code></p>
<p><code>public long id;</code></p>
<p><code>public long dt;</code></p>
<p><code>public String name;</code></p>
<p><code>public int cod;</code></p>
<p><code>public static class Coordinates {</code></p>
<p><code>public double lat;</code></p>
<p><code>public double lon;</code></p>
<p><code>}</code></p>
<p><code>public static class Local {</code></p>
<p><code>public String country;</code></p>
<p><code>public long sunrise;</code></p>
<p><code>public long sunset;</code></p>
<p><code>}</code></p>
<p><code>public static class Weather {</code></p>
<p><code>public int id;</code></p>
<p><code>public String main;</code></p>
<p><code>public String description;</code></p>
<p><code>public String icon;</code></p>
<p><code>}</code></p>
<p><code>public static class Main {</code></p>
<p><code>public double temp;</code></p>
<p><code>public double pressure;</code></p>
<p><code>public double humidity;</code></p>
<p><code>public double temp_min;</code></p>
<p><code>public double temp_max;</code></p>
<p><code>public double sea_level;</code></p>
<p><code>public double grnd_level;</code></p>
<p><code>}</code></p>
<p><code>public static class Wind {</code></p>
<p><code>public double speed;</code></p>
<p><code>public double deg;</code></p>
<p><code>}</code></p>
<p><code>public static class Rain {</code></p>
<p><code>public int threehourforecast;</code></p>
<p><code>}</code></p>
<p><code>public static class Cloud {</code></p>
<p><code>public int all;</code></p>
<p><code>}</code></p>
<p><code>}</code></p>
<p><strong>用Retrofit实现网络调用</strong></p>
<p>第二步中网络调用的实现通常我们需要写一大堆公式化的代码，但如果用Square公司的<a href="http://square.github.io/retrofit/" target="_blank" rel="external">Retrofit组件</a>来实现的话将大大减少代码量。只需要创建一个接口类（用注释来描述整个请求），然后用RestAdapter.Builder来创建客户端就行了。Retrofit也可以用来完成JSON的序列化与反序列化。</p>
<p><code>private interface ApiManagerService {</code></p>
<p><code>@GET(``&quot;/weather&quot;``)</code></p>
<p><code>WeatherData getWeather(@Query(``&quot;q&quot;``) String place, @Query(``&quot;units&quot;``) String units);</code></p>
<p><code>}</code></p>
<p>上面的示例中我们可以看到，方法前的注释是由一个HTTP方法（我们这里用的是GET，当然你也可以按需要用Retrofit实现POST、 PUT、DELETE和HEAD方法）和一个相对路径（基本路径是由RestAdapter.Builder提供的）。@Query注释用于组装请求参 数，我们这有两个参数，一个是place（代表位置），另一个是units计量单位。</p>
<p>我们来看一个具体的调用示例（实际代码中应该把这个调用放到一个非UI线程里）。这段代码还是比较容易理解的：</p>
<p><code>//...</code></p>
<p><code>final RestAdapter restAdapter = ``new</code> <code>RestAdapter.Builder()</code></p>
<p><code>.setServer(``&quot;&lt;http://api.openweathermap.org/data/2.5&gt;&quot;``)</code></p>
<p><code>.build();</code></p>
<p><code>final ApiManagerService apiManager = restAdapter.create(ApiManagerService.class);</code></p>
<p><code>final WeatherData weatherData = apiManager.getWeather(``&quot;Budapest,hu&quot;``, ``&quot;metric&quot;``);</code></p>
<p><code>//...</code></p>
<p>怎么样，很简单吧，你只需要很少的代码就实现了整个调用过程，这就是Retrofit的威力，要了解更多，请点击<a href="http://square.github.io/retrofit/" target="_blank" rel="external">这里</a>。</p>
<p><strong>用RxJava实现响应式编程</strong></p>
<p>现在我们就进入第三步了：RxJava部分！我们这里示例将用它来实现异步的请求调用。但这并不是RxJava所有的功能，以下对RxJava的介绍引用自Netflix的Github 知识库：</p>
<blockquote>
<p>RxJava 是一个在Java虚拟机上实现的响应式扩展库：提供了基于observable序列实现的异步调用及基于事件编程。</p>
<p>它扩展了观察者模式，支持数据、事件序列并允许你合并序列，无需关心底层的线程处理、同步、线程安全、并发数据结构和非阻塞I/O处理。</p>
<p>它支持Java5及更高版本，并支持其他一些基于JVM的语言，如Groovy、Clojure和Scala。</p>
</blockquote>
<p>我们假设你已经对RxJava有一些了解。如果没有的话，强烈建议先看看<a href="http://www.reactivemanifesto.org/" target="_blank" rel="external">这两篇 文章</a>和Netflix在<a href="https://github.com/Netflix/RxJava/wiki" target="_blank" rel="external">Github Wiki上</a>的前几页。</p>
<p>在最后的这个示例中，我们将实现一个API 管理器负责生成observable对象，并完成多并发调用（每个调用都请求同一个地址，但参数不同）。</p>
<p>首先我们需要将前面创建的接口类，换为这个类：</p>
<p><code>public class ApiManager {</code></p>
<p><code>private interface ApiManagerService {</code></p>
<p><code>@GET(``&quot;/weather&quot;``)</code></p>
<p><code>WeatherData getWeather(@Query(``&quot;q&quot;``) String place, @Query(``&quot;units&quot;``) String units);</code></p>
<p><code>}</code></p>
<p><code>private static final RestAdapter restAdapter = ``new</code> <code>RestAdapter.Builder()</code></p>
<p><code>.setServer(``&quot;&lt;http://api.openweathermap.org/data/2.5&gt;&quot;``)</code></p>
<p><code>.build();</code></p>
<p><code>private static final ApiManagerService apiManager = restAdapter.create(ApiManagerService.class);</code></p>
<p><code>public static Observable&lt;WeatherData&gt; getWeatherData(final String city) {</code></p>
<p><code>return</code> <code>Observable.create(``new</code> <code>Observable.OnSubscribeFunc&lt;WeatherData&gt;() {</code></p>
<p><code>@Override</code></p>
<p><code>public Subscription onSubscribe(Observer&lt;? ``super</code> <code>WeatherData&gt; observer) {</code></p>
<p><code>try</code> <code>{</code></p>
<p><code>observer.onNext(apiManager.getWeather(city, ``&quot;metric&quot;``));</code></p>
<p><code>observer.onCompleted();</code></p>
<p><code>} ``catch</code> <code>(Exception e) {</code></p>
<p><code>observer.onError(e);</code></p>
<p><code>}</code></p>
<p><code>return</code> <code>Subscriptions.empty();</code></p>
<p><code>}</code></p>
<p><code>}).subscribeOn(Schedulers.threadPoolForIO());</code></p>
<p><code>}</code></p>
<p><code>}</code></p>
<p>我们先来看下getWeatherData()这个方法，它调用了Observable.create()方法并向方法传入一个 Observable.OnSubscribeFunc的实现，以此得到一个Observable对象并返回。并且一旦Observable对象被订阅 （subscribed）后就会开始工作。Observable每次处理的结果都会当作参数传给onNext()方法。因为我们这里只是想实现网络请求的 并发调用，所以只需要让每个Observable对象中调用一次请求即可。代码最后调用onComplete()方法。这里的subscribeOn() 方法很重要，它决定了程序将选用哪种线程。这里调用的是Schedulers.threadPoolForIO()，此线程用于优化IO和网络性能相关的 工作。</p>
<p>最后一步是要实现这个API调用。下面的代码实现了并发网络请求，每个请求都使用不同的调用参数异步调用同一个url：</p>
<p><code>Observable.from(cities)</code></p>
<p><code>.mapMany(``new</code> <code>Func1&lt;String, Observable&lt;WeatherData&gt;&gt;() {</code></p>
<p><code>@Override</code></p>
<p><code>public Observable&lt;WeatherData&gt; call(String s) {</code></p>
<p><code>return</code> <code>ApiManager.getWeatherData(s);</code></p>
<p><code>}</code></p>
<p><code>})</code></p>
<p><code>.subscribeOn(Schedulers.threadPoolForIO())</code></p>
<p><code>.observeOn(AndroidSchedulers.mainThread())</code></p>
<p><code>.subscribe(``new</code> <code>Action1&lt;WeatherData&gt;() {</code></p>
<p><code>@Override</code></p>
<p><code>public void call(WeatherData weatherData) {</code></p>
<p><code>// do your work</code></p>
<p><code>}</code></p>
<p><code>});</code></p>
<p>Observable.from()方法将城市名称数组转化为一个observable对象，将数组里的字符串提供给不同的线程。然后mapMany()方法将会把前者提供的每一个字符串都转化为observable对象（<em>译注：新对象包含的是weatherData对象数据</em>）。这里的转化通过调用ApiManager.getWeatherData()完成。</p>
<p>这里还是注册在I/O线程池上。在Android系统上，如果需要把结果展示在UI上，就必须把数据发布给UI线程处理。因为我们知道，在 Android上只有最原始的那个创建界面的线程才可以操作界面。这里只需要用observeOn()方法调用 AndroidSchedulers.mainThread()即可。subscribe()方法的调用将触发observable对象，我们可以在这里 处理observable对象发出的结果。</p>
<p>这个示例展示了RxJava强大的功能。如果没有Rx，我们需要创建N个线程去调用请求，然后通过异步方式把处理结果交给UI线程。使用Rx只需编写很少的代码就完成工作，使用它强大的功能创建、合并、过滤和转化observable对象。</p>
<p>RxJava可以在开发安卓App时，作为一个强大的处理并发的工具使用。虽然要熟悉它还是需要一些时间，但是磨刀不误砍柴工，一旦掌握了它，将给 你带来很大帮助。响应式扩展库是个很好的想法，我们把它用于安卓程序的开发，已经用了好几个礼拜了（在不久的将来，我们产品的异步任务处理将完全基于它完 成）。越是了解它，你就越会爱上它。</p>
<p>还想看点其他资料不？看看<a href="http://howrobotswork.wordpress.com/2013/11/18/rxjava-and-android-error-handling/" target="_blank" rel="external">这篇文章</a>吧，它讲的是RxJava如何进行错误处理。</p>
<p>英文原文： <a href="http://andraskindler.com/blog/2013/using-rxjava-in-android/" target="_blank" rel="external">Using RxJava with Android</a><br>译文原文： <a href="http://www.importnew.com/8321.html" target="_blank" rel="external">http://www.importnew.com/8321.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>如果你做过Android（和Java）的开发，很有可能已经听说过RxJava了。RxJava是由Netflix开发的响应式扩展（Reactive Extensions）的Java实现。引用<a href="http://msdn.microsoft.com/en-us/data/gg577609.aspx">MSDN上对它的定义</a>，Reactive Extensions是这样一个第三方库：<strong>它结合了可观察集合和LINQ式查询以达到异步和基于事件的编程效果</strong>。Netflix将这个库托管到了Github上，支持Java6以上的版本并且使它可以用于Android App开发。</p>
<p>本篇是介绍RxJava和Android的系列文章的第一篇，将会介绍如何在Android中使用RxJava observables（基于Square的Retrofit组件）创建REST API客户端。</p>
<p>我们从添加所需的库文件开始。如果你用Maven的话，只需将下面的dependencies（依赖库）加到pom.xml中即可：</p>
<pre><code>`&lt;dependency&gt;`
`&lt;groupId&gt;com.squareup.retrofit&lt;/groupId&gt;`
`&lt;artifactId&gt;retrofit&lt;/artifactId&gt;`
`&lt;version&gt;1.2.2&lt;/version&gt;`
`&lt;/dependency&gt;`
`&lt;dependency&gt;`
`&lt;groupId&gt;com.netflix.rxjava&lt;/groupId&gt;`
`&lt;artifactId&gt;rxjava-android&lt;/artifactId&gt;`
`&lt;version&gt;0.14.6&lt;/version&gt;`s
`&lt;/dependency&gt;`
</code></pre>]]>
    
    </summary>
    
      <category term="RxJava" scheme="http://apanda.club/tags/RxJava/"/>
    
      <category term="技术" scheme="http://apanda.club/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入浅出RxJava(四：在Android中使用响应式编程)]]></title>
    <link href="http://apanda.club/2016/04/05/RxJava/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BARxJava%E5%9B%9B-%E5%9C%A8Android%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>http://apanda.club/2016/04/05/RxJava/深入浅出RxJava四-在Android中使用响应式编程/</id>
    <published>2016-04-05T15:12:17.000Z</published>
    <updated>2016-04-10T10:10:02.000Z</updated>
    <content type="html"><![CDATA[<p>在第<a href="http://blog.csdn.net/lzyzsd/article/details/41833541" target="_blank" rel="external">1</a>，<a href="http://blog.csdn.net/lzyzsd/article/details/44094895" target="_blank" rel="external">2</a>，<a href="http://blog.csdn.net/lzyzsd/article/details/44891933" target="_blank" rel="external">3</a>篇中，我大概介绍了RxJava是怎么使用的。下面我会介绍如何在Android中使用RxJava.</p>
<h2 id="RxAndroid"><a href="#RxAndroid" class="headerlink" title="RxAndroid"></a>RxAndroid</h2><p>RxAndroid是RxJava的一个针对Android平台的扩展。它包含了一些能够简化Android开发的工具。</p>
<p>首先，AndroidSchedulers提供了针对Android的线程系统的调度器。需要在UI线程中运行某些代码？很简单，只需要使用AndroidSchedulers.mainThread():</p>
<pre><code>retrofitService.getImage(url)
.subscribeOn(Schedulers.io())
.observeOn(AndroidSchedulers.mainThread())
.subscribe(bitmap -&gt; myImageView.setImageBitmap(bitmap));
</code></pre><a id="more"></a>
<p>如果你已经创建了自己的Handler，你可以使用HandlerThreadScheduler1将一个调度器链接到你的handler上。</p>
<p>接着要介绍的就是AndroidObservable，它提供了跟多的功能来配合Android的生命周期。bindActivity()和 bindFragment()方法默认使用AndroidSchedulers.mainThread()来执行观察者代码，这两个方法会在 Activity或者Fragment结束的时候通知被观察者停止发出新的消息。</p>
<p><code>AndroidObservable.bindActivity(``this``, retrofitService.getImage(url))</code></p>
<p><code>.subscribeOn(Schedulers.io())</code></p>
<p><code>.subscribe(bitmap -&gt; myImageView.setImageBitmap(bitmap);</code></p>
<p>我自己也很喜欢AndroidObservable.fromBroadcast()方法，它允许你创建一个类似BroadcastReceiver的Observable对象。下面的例子展示了如何在网络变化的时候被通知到：</p>
<p><code>IntentFilter filter = ``new</code> <code>IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION);</code></p>
<p><code>AndroidObservable.fromBroadcast(context, filter)</code></p>
<p><code>.subscribe(intent -&gt; handleConnectivityChange(intent));</code></p>
<p>最后要介绍的是ViewObservable,使用它可以给View添加了一些绑定。如果你想在每次点击view的时候都收到一个事件，可以使用 ViewObservable.clicks()，或者你想监听TextView的内容变化，可以使用ViewObservable.text()。</p>
<p><code>ViewObservable.clicks(mCardNameEditText, ``false``)</code></p>
<p><code>.subscribe(view -&gt; handleClick(view));</code></p>
<h2 id="Retrofit"><a href="#Retrofit" class="headerlink" title="Retrofit"></a>Retrofit</h2><p>大名鼎鼎的Retrofit库内置了对RxJava的支持。通常调用发可以通过使用一个Callback对象来获取异步的结果：</p>
<p><code>@GET(``&quot;/user/{id}/photo&quot;``)</code></p>
<p><code>void getUserPhoto(@Path(``&quot;id&quot;``) int id, Callback&lt;Photo&gt; cb);</code></p>
<p>使用RxJava，你可以直接返回一个Observable对象。</p>
<p><code>@GET(``&quot;/user/{id}/photo&quot;``)</code></p>
<p><code>Observable&lt;Photo&gt; getUserPhoto(@Path(``&quot;id&quot;``) int id);</code></p>
<p>现在你可以随意使用Observable对象了。你不仅可以获取数据，还可以进行变换。<br>Retrofit对Observable的支持使得它可以很简单的将多个REST请求结合起来。比如我们有一个请求是获取照片的，还有一个请求是获取元数据的，我们就可以将这两个请求并发的发出，并且等待两个结果都返回之后再做处理：</p>
<p><code>Observable.zip(</code></p>
<p><code>service.getUserPhoto(id),</code></p>
<p><code>service.getPhotoMetadata(id),</code></p>
<p><code>(photo, metadata) -&gt; createPhotoWithData(photo, metadata))</code></p>
<p><code>.subscribe(photoWithData -&gt; showPhoto(photoWithData));</code></p>
<p>在第二篇里我展示过一个类似的例子（使用flatMap()）。这里我只是想展示以下使用RxJava+Retrofit可以多么简单地组合多个REST请求。</p>
<h2 id="u9057_u7559_u4EE3_u7801_uFF0C_u8FD0_u884C_u6781_u6162_u7684_u4EE3_u7801"><a href="#u9057_u7559_u4EE3_u7801_uFF0C_u8FD0_u884C_u6781_u6162_u7684_u4EE3_u7801" class="headerlink" title="遗留代码，运行极慢的代码"></a>遗留代码，运行极慢的代码</h2><p>Retrofit可以返回Observable对象，但是如果你使用的别的库并不支持这样怎么办？或者说一个内部的内码，你想把他们转换成Observable的？有什么简单的办法没？</p>
<p>绝大多数时候Observable.just() 和 Observable.from() 能够帮助你从遗留代码中创建 Observable 对象:</p>
<p><code>private Object oldMethod() { ... }</code></p>
<p><code>public Observable&lt;Object&gt; newMethod() {</code></p>
<p><code>return</code> <code>Observable.just(oldMethod());</code></p>
<p><code>}</code></p>
<p>上面的例子中如果oldMethod()足够快是没有什么问题的，但是如果很慢呢？调用oldMethod()将会阻塞住他所在的线程。<br>为了解决这个问题，可以参考我一直使用的方法–使用defer()来包装缓慢的代码：</p>
<p><code>private Object slowBlockingMethod() { ... }</code></p>
<p><code>public Observable&lt;Object&gt; newMethod() {</code></p>
<p><code>return</code> <code>Observable.defer(() -&gt; Observable.just(slowBlockingMethod()));</code></p>
<p><code>}</code></p>
<p>现在，newMethod()的调用不会阻塞了，除非你订阅返回的observable对象。</p>
<p>我把最难的不分留在了最后。如何处理Activity的生命周期？主要就是两个问题：<br>1.在configuration改变（比如转屏）之后继续之前的Subscription。</p>
<p>比如你使用Retrofit发出了一个REST请求，接着想在listview中展示结果。如果在网络请求的时候用户旋转了屏幕怎么办？你当然想继续刚才的请求，但是怎么搞？</p>
<p>2.Observable持有Context导致的内存泄露</p>
<p>这个问题是因为创建subscription的时候，以某种方式持有了context的引用，尤其是当你和view交互的时候，这太容易发生！如果Observable没有及时结束，内存占用就会越来越大。<br>不幸的是，没有银弹来解决这两个问题，但是这里有一些指导方案你可以参考。</p>
<p>第一个问题的解决方案就是使用RxJava内置的缓存机制，这样你就可以对同一个Observable对象执行 unsubscribe/resubscribe，却不用重复运行得到Observable的代码。cache() (或者 replay())会继续执行网络请求（甚至你调用了unsubscribe也不会停止）。这就是说你可以在Activity重新创建的时候从 cache()的返回值中创建一个新的Observable对象。</p>
<p><code>Observable&lt;Photo&gt; request = service.getUserPhoto(id).cache();</code></p>
<p><code>Subscription sub = request.subscribe(photo -&gt; handleUserPhoto(photo));</code></p>
<p><code>// ...When the Activity is being recreated...</code></p>
<p><code>sub.unsubscribe();</code></p>
<p><code>// ...Once the Activity is recreated...</code></p>
<p><code>request.subscribe(photo -&gt; handleUserPhoto(photo));</code></p>
<p>注意，两次sub是使用的同一个缓存的请求。当然在哪里去存储请求的结果还是要你自己来做，和所有其他的生命周期相关的解决方案一延虎，必须在生命周期外的某个地方存储。（retained fragment或者单例等等）。</p>
<p>第二个问题的解决方案就是在生命周期的某个时刻取消订阅。一个很常见的模式就是使用CompositeSubscription来持有所有的Subscriptions，然后在onDestroy()或者onDestroyView()里取消所有的订阅。</p>
<p><code>private CompositeSubscription mCompositeSubscription</code></p>
<p><code>= ``new</code> <code>CompositeSubscription();</code></p>
<p><code>private void doSomething() {</code></p>
<p><code>mCompositeSubscription.add(</code></p>
<p><code>AndroidObservable.bindActivity(``this``, Observable.just(``&quot;Hello, World!&quot;``))</code></p>
<p><code>.subscribe(s -&gt; System.out.println(s)));</code></p>
<p><code>}</code></p>
<p><code>@Override</code></p>
<p><code>protected void onDestroy() {</code></p>
<p><code>super``.onDestroy();</code></p>
<p><code>mCompositeSubscription.unsubscribe();</code></p>
<p><code>}</code></p>
<p>你可以在Activity/Fragment的基类里创建一个CompositeSubscription对象，在子类中使用它。</p>
<p>注意! 一旦你调用了 CompositeSubscription.unsubscribe()，这个CompositeSubscription对象就不可用了, 如果你还想使用CompositeSubscription，就必须在创建一个新的对象了。</p>
<p>两个问题的解决方案都需要添加额外的代码，如果谁有更好的方案，欢迎告诉我。</p>
<p>RxJava还是一个很新的项目，RxAndroid更是。RxAndroid目前还在活跃开发中，也没有多少好的例子。我打赌一年之后我的一些建议就会被看做过时了。</p>
<pre><code>原文链接 &lt;http://blog.danlew.net/2014/10/08/grokking-rxjava-part-4/&gt; 
译文链接 &lt;http://blog.csdn.net/lzyzsd/article/details/45033611&gt; 
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>在第<a href="http://blog.csdn.net/lzyzsd/article/details/41833541">1</a>，<a href="http://blog.csdn.net/lzyzsd/article/details/44094895">2</a>，<a href="http://blog.csdn.net/lzyzsd/article/details/44891933">3</a>篇中，我大概介绍了RxJava是怎么使用的。下面我会介绍如何在Android中使用RxJava.</p>
<h2 id="RxAndroid"><a href="#RxAndroid" class="headerlink" title="RxAndroid"></a>RxAndroid</h2><p>RxAndroid是RxJava的一个针对Android平台的扩展。它包含了一些能够简化Android开发的工具。</p>
<p>首先，AndroidSchedulers提供了针对Android的线程系统的调度器。需要在UI线程中运行某些代码？很简单，只需要使用AndroidSchedulers.mainThread():</p>
<pre><code>retrofitService.getImage(url)
.subscribeOn(Schedulers.io())
.observeOn(AndroidSchedulers.mainThread())
.subscribe(bitmap -&gt; myImageView.setImageBitmap(bitmap));
</code></pre>]]>
    
    </summary>
    
      <category term="RxJava" scheme="http://apanda.club/tags/RxJava/"/>
    
      <category term="技术" scheme="http://apanda.club/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入浅出RxJava(三：响应式的好处)]]></title>
    <link href="http://apanda.club/2016/04/04/RxJava/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BARxJava%E4%B8%89--%E5%93%8D%E5%BA%94%E5%BC%8F%E7%9A%84%E5%A5%BD%E5%A4%84/"/>
    <id>http://apanda.club/2016/04/04/RxJava/深入浅出RxJava三--响应式的好处/</id>
    <published>2016-04-04T05:12:17.000Z</published>
    <updated>2016-04-10T10:11:20.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p><a href="http://blog.danlew.net/2014/09/30/grokking-rxjava-part-3/" target="_blank" rel="external">英文原文</a> </p>
<p><a href="http://blog.csdn.net/lzyzsd/article/details/44891933" target="_blank" rel="external">译文原文</a></p>
</blockquote>
<p>在第一篇中，我介绍了RxJava的基础知识。第二篇中，我向你展示了操作符的强大。但是你可能仍然没被说服。这篇里面，我讲向你展示RxJava的其他的一些好处，相信这篇足够让你去使用Rxjava.</p>
<p>到目前为止，我们都没怎么介绍onComplete()和onError()函数。这两个函数用来通知订阅者，被观察的对象将停止发送数据以及为什么停止（成功的完成或者出错了）。</p>
<p>下面的代码展示了怎么使用这两个函数：</p>
<pre><code>Observable.just(``&quot;Hello, world!&quot;``)
.map(s -&gt; potentialException(s))
.map(s -&gt; anotherPotentialException(s))
.subscribe(``new` `Subscriber&lt;String&gt;() {        
    @Override
    public void onNext(String s) { System.out.println(s); }        
    @Override
    public void onCompleted() { System.out.println(``&quot;Completed!&quot;``); }        
    @Override
    public void onError(Throwable e) { System.out.println(``&quot;Ouch!&quot;``); }
});
</code></pre><a id="more"></a>
<p>代码中的potentialException() 和 anotherPotentialException()有可能会抛出异常。每一个Observerable对象在终结的时候都会调用 onCompleted()或者onError()方法，所以Demo中会打印”Completed!”或者”Ouch!”。</p>
<p>这种模式有以下几个优点：</p>
<p>1.只要有异常发生onError()一定会被调用</p>
<p>这极大的简化了错误处理。只需要在一个地方处理错误即可以。</p>
<p>2.操作符不需要处理异常</p>
<p>将异常处理交给订阅者来做，Observerable的操作符调用链中一旦有一个抛出了异常，就会直接执行onError()方法。</p>
<p>3.你能够知道什么时候订阅者已经接收了全部的数据。</p>
<p>知道什么时候任务结束能够帮助简化代码的流程。（虽然有可能Observable对象永远不会结束）</p>
<p>我觉得这种错误处理方式比传统的错误处理更简单。传统的错误处理中，通常是在每个回调中处理错误。这不仅导致了重复的代码，并且意味着每个回调都必须知道如何处理错误，你的回调代码将和调用者紧耦合在一起。</p>
<p>使用RxJava，Observable对象根本不需要知道如何处理错误！操作符也不需要处理错误状态-一旦发生错误，就会跳过当前和后续的操作符。所有的错误处理都交给订阅者来做。</p>
<p>假设你编写的Android app需要从网络请求数据（感觉这是必备的了，还有单机么？）。网络请求需要话费较长的时间，因此你打算在另外一个线程中加载数据。为问题来了！</p>
<p>编写多线程的Android应用程序是很难的，因为你必须确保代码在正确的线程中运行，否则的话可能会导致app崩溃。最常见的就是在非主线程更新UI。</p>
<p>使用RxJava，你可以使用subscribeOn()指定观察者代码运行的线程，使用observerOn()指定订阅者运行的线程：</p>
<p><code>myObservableServices.retrieveImage(url)</code></p>
<p><code>.subscribeOn(Schedulers.io())</code></p>
<p><code>.observeOn(AndroidSchedulers.mainThread())</code></p>
<p><code>.subscribe(bitmap -&gt; myImageView.setImageBitmap(bitmap));</code></p>
<p>是不是很简单？任何在我的Subscriber前面执行的代码都是在I/O线程中运行。最后，操作view的代码在主线程中运行.</p>
<p>最棒的是我可以把subscribeOn()和observerOn()添加到任何Observable对象上。这两个也是操作符！。我不需要关心Observable对象以及它上面有哪些操作符。仅仅运用这两个操作符就可以实现在不同的线程中调度。</p>
<p>如果使用AsyncTask或者其他类似的，我将不得不仔细设计我的代码，找出需要并发执行的部分。使用RxJava，我可以保持代码不变，仅仅在需要并发的时候调用这两个操作符就可以。</p>
<h2 id="u8BA2_u9605_uFF08Subscriptions_uFF09"><a href="#u8BA2_u9605_uFF08Subscriptions_uFF09" class="headerlink" title="订阅（Subscriptions）"></a>订阅（Subscriptions）</h2><p>当调用Observable.subscribe()，会返回一个Subscription对象。这个对象代表了被观察者和订阅者之间的联系。</p>
<p><code>ubscription subscription = Observable.just(``&quot;Hello, World!&quot;``)</code></p>
<p><code>.subscribe(s -&gt; System.out.println(s));</code></p>
<p>你可以在后面使用这个Subscription对象来操作被观察者和订阅者之间的联系.</p>
<p><code>subscription.unsubscribe();</code></p>
<p><code>System.out.println(``&quot;Unsubscribed=&quot;</code> <code>+ subscription.isUnsubscribed());</code></p>
<p><code>// Outputs &quot;Unsubscribed=true&quot;</code></p>
<p>RxJava的另外一个好处就是它处理unsubscribing的时候，会停止整个调用链。如果你使用了一串很复杂的操作符，调用unsubscribe将会在他当前执行的地方终止。不需要做任何额外的工作！</p>
<p>记住这个系列仅仅是对RxJava的一个入门介绍。RxJava中有更多的我没介绍的功能等你探索（比如backpressure）。当然我也不是所有的代码都使用响应式的方式–仅仅当代码复杂到我想将它分解成简单的逻辑的时候，我才使用响应式代码。</p>
<p>最初，我的计划是这篇文章作为这个系列的总结，但是我收到许多请求我介绍在Android中使用RxJava，所以你可以继续阅读第四篇了。我希望这个介绍能让你开始使用RxJava。如果你想学到更多，我建议你阅读RxJava的官方wiki。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p><a href="http://blog.danlew.net/2014/09/30/grokking-rxjava-part-3/">英文原文</a> </p>
<p><a href="http://blog.csdn.net/lzyzsd/article/details/44891933">译文原文</a></p>
</blockquote>
<p>在第一篇中，我介绍了RxJava的基础知识。第二篇中，我向你展示了操作符的强大。但是你可能仍然没被说服。这篇里面，我讲向你展示RxJava的其他的一些好处，相信这篇足够让你去使用Rxjava.</p>
<p>到目前为止，我们都没怎么介绍onComplete()和onError()函数。这两个函数用来通知订阅者，被观察的对象将停止发送数据以及为什么停止（成功的完成或者出错了）。</p>
<p>下面的代码展示了怎么使用这两个函数：</p>
<pre><code>Observable.just(``&quot;Hello, world!&quot;``)
.map(s -&gt; potentialException(s))
.map(s -&gt; anotherPotentialException(s))
.subscribe(``new` `Subscriber&lt;String&gt;() {        
    @Override
    public void onNext(String s) { System.out.println(s); }        
    @Override
    public void onCompleted() { System.out.println(``&quot;Completed!&quot;``); }        
    @Override
    public void onError(Throwable e) { System.out.println(``&quot;Ouch!&quot;``); }
});
</code></pre>]]>
    
    </summary>
    
      <category term="RxJava" scheme="http://apanda.club/tags/RxJava/"/>
    
      <category term="技术" scheme="http://apanda.club/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入浅出RxJava(二：操作符)]]></title>
    <link href="http://apanda.club/2016/04/02/RxJava/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BARxJava(%E4%BA%8C%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%AC%A6)/"/>
    <id>http://apanda.club/2016/04/02/RxJava/深入浅出RxJava(二：操作符)/</id>
    <published>2016-04-02T15:12:17.000Z</published>
    <updated>2016-04-10T08:45:02.000Z</updated>
    <content type="html"><![CDATA[<p>译文原文 <a href="http://blog.csdn.net/lzyzsd/article/details/44094895" target="_blank" rel="external">http://blog.csdn.net/lzyzsd/article/details/44094895</a> </p>
<p>英文原文 <a href="http://blog.danlew.net/2014/09/22/grokking-rxjava-part-2/" target="_blank" rel="external">Grokking RxJava, Part 2: Operator, Operator</a></p>
<p>在<a href="http://blog.csdn.net/lzyzsd/article/details/41833541" target="_blank" rel="external">第一篇blog</a>中， 我介绍了RxJava的一些基础知识，同时也介绍了map()操作符。当然如果你并没有意愿去使用RxJava我一点都不诧异，毕竟才接触了这么点。看完 这篇blog，我相信你肯定想立即在你的项目中使用RxJava了，这篇blog将介绍许多RxJava中的操作符，RxJava的强大性就来自于它所定 义的操作符。</p>
<p>首先先看一个例子：</p>
<p>假设我有这样一个方法：<br>这个方法根据输入的字符串返回一个网站的url列表（啊哈，搜索引擎）</p>
<p><code>Observable&lt;List&lt;String&gt;&gt; query(String text);</code></p>
<p>现在我希望构建一个健壮系统，它可以查询字符串并且显示结果。根据上一篇blog的内容，我们可能会写出下面的代码：</p>
<p><code>query(``&quot;Hello, world!&quot;``)</code><br><code>.subscribe(urls -&gt; {</code><br><code>for</code> <code>(String url : urls) {</code><br><code>System.out.println(url);</code><br><code>}</code><br><code>});</code><br><a id="more"></a><br>这种代码当然是不能容忍的，因为上面的代码使我们丧失了变化数据流的能力。一旦我们想要更改每一个URL，只能在Subscriber中来做。我们竟然没有使用如此酷的map()操作符！！！</p>
<p>当然，我可以使用map操作符，map的输入是urls列表，处理的时候还是要for each遍历，一样很蛋疼。</p>
<p>万幸，还有Observable.from()方法，它接收一个集合作为输入，然后每次输出一个元素给subscriber：</p>
<p><code>Observable.from(``&quot;url1&quot;``, ``&quot;url2&quot;``, ``&quot;url3&quot;``)</code></p>
<p><code>.subscribe(url -&gt; System.out.println(url));</code></p>
<p>我们来把这个方法使用到刚才的场景：</p>
<p><code>query(``&quot;Hello, world!&quot;``)</code></p>
<p><code>.subscribe(urls -&gt; {</code></p>
<p><code>Observable.from(urls)</code></p>
<p><code>.subscribe(url -&gt; System.out.println(url));</code></p>
<p><code>});</code></p>
<p>虽然去掉了for each循环，但是代码依然看起来很乱。多个嵌套的subscription不仅看起来很丑，难以修改，更严重的是它会破坏某些我们现在还没有讲到的RxJava的特性。</p>
<p>救星来了,他就是flatMap()。<br>Observable.flatMap()接收一个Observable的输出作为输入，同时输出另外一个Observable。直接看代码：</p>
<p><code>query(``&quot;Hello, world!&quot;``)</code></p>
<p><code>.flatMap(``new</code> <code>Func1&lt;List&lt;String&gt;, Observable&lt;String&gt;&gt;() {</code></p>
<p><code>@Override</code></p>
<p><code>public Observable&lt;String&gt; call(List&lt;String&gt; urls) {</code></p>
<p><code>return</code> <code>Observable.from(urls);</code></p>
<p><code>}</code></p>
<p><code>})</code></p>
<p><code>.subscribe(url -&gt; System.out.println(url));</code></p>
<p>这里我贴出了整个的函数代码，以方便你了解发生了什么，使用lambda可以大大简化代码长度：</p>
<p><code>query(``&quot;Hello, world!&quot;``)</code></p>
<p><code>.flatMap(urls -&gt; Observable.from(urls))</code></p>
<p><code>.subscribe(url -&gt; System.out.println(url));</code></p>
<p>flatMap()是不是看起来很奇怪？为什么它要返回另外一个Observable呢？理解flatMap的关键点在于，flatMap输出的新的 Observable正是我们在Subscriber想要接收的。现在Subscriber不再收到List\<string\>，而是收到一些 列单个的字符串，就像Observable.from()的输出一样。</string\></p>
<p>这部分也是我当初学RxJava的时候最难理解的部分，一旦我突然领悟了，RxJava的很多疑问也就一并解决了。</p>
<h2 id="u8FD8_u53EF_u4EE5_u66F4_u597D"><a href="#u8FD8_u53EF_u4EE5_u66F4_u597D" class="headerlink" title="还可以更好"></a>还可以更好</h2><p>flatMap()实在不能更赞了，它可以返回任何它想返回的Observable对象。<br>比如下面的方法：</p>
<p><code>// 返回网站的标题，如果404了就返回null</code></p>
<p><code>Observable&lt;String&gt; getTitle(String URL);</code></p>
<p>接着前面的例子，现在我不想打印URL了，而是要打印收到的每个网站的标题。问题来了，我的方法每次只能传入一个URL，并且返回值不是一个String，而是一个输出String的Observabl对象。使用flatMap()可以简单的解决这个问题。</p>
<p><code>query(``&quot;Hello, world!&quot;``)</code></p>
<p><code>.flatMap(urls -&gt; Observable.from(urls))</code></p>
<p><code>.flatMap(``new</code> <code>Func1&lt;String, Observable&lt;String&gt;&gt;() {</code></p>
<p><code>@Override</code></p>
<p><code>public Observable&lt;String&gt; call(String url) {</code></p>
<p><code>return</code> <code>getTitle(url);</code></p>
<p><code>}</code></p>
<p><code>})</code></p>
<p><code>.subscribe(title -&gt; System.out.println(title));</code></p>
<p>使用lambda:</p>
<p><code>query(``&quot;Hello, world!&quot;``)</code></p>
<p><code>.flatMap(urls -&gt; Observable.from(urls))</code></p>
<p><code>.flatMap(url -&gt; getTitle(url))</code></p>
<p><code>.subscribe(title -&gt; System.out.println(title));</code></p>
<p>是不是感觉很不可思议？我竟然能将多个独立的返回Observable对象的方法组合在一起！帅呆了！<br>不止这些，我还将两个API的调用组合到一个链式调用中了。我们可以将任意多个API调用链接起来。大家应该都应该知道同步所有的API调用，然后将所有 API调用的回调结果组合成需要展示的数据是一件多么蛋疼的事情。这里我们成功的避免了callback hell（多层嵌套的回调，导致代码难以阅读维护）。现在所有的逻辑都包装成了这种简单的响应式调用。</p>
<h2 id="u4E30_u5BCC_u7684_u64CD_u4F5C_u7B26"><a href="#u4E30_u5BCC_u7684_u64CD_u4F5C_u7B26" class="headerlink" title="丰富的操作符"></a>丰富的操作符</h2><p>目前为止，我们已经接触了两个操作符，RxJava中还有更多的操作符，那么我们如何使用其他的操作符来改进我们的代码呢？<br>getTitle()返回null如果url不存在。我们不想输出”null”，那么我们可以从返回的title列表中过滤掉null值！</p>
<p><code>query(``&quot;Hello, world!&quot;``)</code></p>
<p><code>.flatMap(urls -&gt; Observable.from(urls))</code></p>
<p><code>.flatMap(url -&gt; getTitle(url))</code></p>
<p><code>.filter(title -&gt; title != ``null``)</code></p>
<p><code>.subscribe(title -&gt; System.out.println(title));</code></p>
<p>filter()输出和输入相同的元素，并且会过滤掉那些不满足检查条件的。</p>
<p>如果我们只想要最多5个结果：</p>
<p><code>query(``&quot;Hello, world!&quot;``)</code></p>
<p><code>.flatMap(urls -&gt; Observable.from(urls))</code></p>
<p><code>.flatMap(url -&gt; getTitle(url))</code></p>
<p><code>.filter(title -&gt; title != ``null``)</code></p>
<p><code>.take(5)</code></p>
<p><code>.subscribe(title -&gt; System.out.println(title));</code></p>
<p>take()输出最多指定数量的结果。</p>
<p>如果我们想在打印之前，把每个标题保存到磁盘：</p>
<p><code>query(``&quot;Hello, world!&quot;``)</code></p>
<p><code>.flatMap(urls -&gt; Observable.from(urls))</code></p>
<p><code>.flatMap(url -&gt; getTitle(url))</code></p>
<p><code>.filter(title -&gt; title != ``null``)</code></p>
<p><code>.take(5)</code></p>
<p><code>.doOnNext(title -&gt; saveTitle(title))</code></p>
<p><code>.subscribe(title -&gt; System.out.println(title));</code></p>
<p>doOnNext()允许我们在每次输出一个元素之前做一些额外的事情，比如这里的保存标题。</p>
<p>看到这里操作数据流是多么简单了么。你可以添加任意多的操作，并且不会搞乱你的代码。</p>
<p>RxJava包含了大量的操作符。操作符的数量是有点吓人，但是很值得你去挨个看一下，这样你可以知道有哪些操作符可以使用。弄懂这些操作符可能会花一些时间，但是一旦弄懂了，你就完全掌握了RxJava的威力。</p>
<p>你甚至可以编写自定义的操作符！这篇blog不打算将自定义操作符，如果你想的话，清自行Google吧。</p>
<h2 id="u611F_u89C9_u5982_u4F55_uFF1F"><a href="#u611F_u89C9_u5982_u4F55_uFF1F" class="headerlink" title="感觉如何？"></a>感觉如何？</h2><p>好吧，你是一个怀疑主义者，并且还很难被说服，那为什么你要关心这些操作符呢？</p>
<p>因为操作符可以让你对数据流做任何操作。</p>
<p>将一系列的操作符链接起来就可以完成复杂的逻辑。代码被分解成一系列可以组合的片段。这就是响应式函数编程的魅力。用的越多，就会越多的改变你的编程思维。</p>
<p>另外，RxJava也使我们处理数据的方式变得更简单。在最后一个例子里，我们调用了两个API，对API返回的数据进行了处理，然后保存到磁盘。 但是我们的Subscriber并不知道这些，它只是认为自己在接收一个Observable\<string\>对象。良好的封装性也带来了编 码的便利！</string\></p>
<p>在第三部分中，我将介绍RxJava的另外一些很酷的特性，比如错误处理和并发，这些特性并不会直接用来处理数据。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>译文原文 <a href="http://blog.csdn.net/lzyzsd/article/details/44094895">http://blog.csdn.net/lzyzsd/article/details/44094895</a> </p>
<p>英文原文 <a href="http://blog.danlew.net/2014/09/22/grokking-rxjava-part-2/">Grokking RxJava, Part 2: Operator, Operator</a></p>
<p>在<a href="http://blog.csdn.net/lzyzsd/article/details/41833541">第一篇blog</a>中， 我介绍了RxJava的一些基础知识，同时也介绍了map()操作符。当然如果你并没有意愿去使用RxJava我一点都不诧异，毕竟才接触了这么点。看完 这篇blog，我相信你肯定想立即在你的项目中使用RxJava了，这篇blog将介绍许多RxJava中的操作符，RxJava的强大性就来自于它所定 义的操作符。</p>
<p>首先先看一个例子：</p>
<p>假设我有这样一个方法：<br>这个方法根据输入的字符串返回一个网站的url列表（啊哈，搜索引擎）</p>
<p><code>Observable&lt;List&lt;String&gt;&gt; query(String text);</code></p>
<p>现在我希望构建一个健壮系统，它可以查询字符串并且显示结果。根据上一篇blog的内容，我们可能会写出下面的代码：</p>
<p><code>query(``&quot;Hello, world!&quot;``)</code><br><code>.subscribe(urls -&gt; {</code><br><code>for</code> <code>(String url : urls) {</code><br><code>System.out.println(url);</code><br><code>}</code><br><code>});</code><br>]]>
    
    </summary>
    
      <category term="RxJava" scheme="http://apanda.club/tags/RxJava/"/>
    
      <category term="技术" scheme="http://apanda.club/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Q2季度目标]]></title>
    <link href="http://apanda.club/2016/04/01/%E9%9A%8F%E7%AC%94/Q2%E5%AD%A3%E5%BA%A6%E7%9B%AE%E6%A0%87/"/>
    <id>http://apanda.club/2016/04/01/随笔/Q2季度目标/</id>
    <published>2016-04-01T03:33:45.000Z</published>
    <updated>2016-04-06T10:49:36.000Z</updated>
    <content type="html"><![CDATA[<p>1、完成GankAPP，并上线</p>
<pre><code>未完成的部分
1、上啦下拉更新 
2、替换历史上今天的API
3、优化webview的显示
4、优化代码结构（网络请求**）
</code></pre>   <a id="more"></a>
<p>2、阅读《深入理解Android卷I》 并写下不少于10篇的技术读后感</p>
<p><a href="http://i4.piimg.com/e5dcc5c08841a359.jpg" title="点击显示原始图片" target="_blank" rel="external"><img src="http://i4.piimg.com/e5dcc5c08841a359t.jpg"></a></p>
<p>3、使用RxJava 完成知乎日报客户端，并使用sketch设计原型</p>
<p>4、攒钱攒钱攒钱 </p>
<p><img src="http://i.gtimg.cn/open/app_icon/04/72/41/14/1104724114_p1.png" width="300"></p>
<p>5、戒烟!戒烟!戒烟!</p>
<p><img src="https://d24.usercdn.com/i/04036/7yqf33h4fw6q.jpeg" width="300"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>1、完成GankAPP，并上线</p>
<pre><code>未完成的部分
1、上啦下拉更新 
2、替换历史上今天的API
3、优化webview的显示
4、优化代码结构（网络请求**）
</code></pre>]]>
    
    </summary>
    
      <category term="目标" scheme="http://apanda.club/tags/%E7%9B%AE%E6%A0%87/"/>
    
      <category term="随笔" scheme="http://apanda.club/categories/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入浅出RxJava(一：基础篇)]]></title>
    <link href="http://apanda.club/2016/03/29/RxJava/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BARxJava%EF%BC%88%E4%B8%80%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89/"/>
    <id>http://apanda.club/2016/03/29/RxJava/深入浅出RxJava（一：基础篇）/</id>
    <published>2016-03-29T13:12:17.000Z</published>
    <updated>2016-04-10T08:47:16.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://blog.danlew.net/2014/09/15/grokking-rxjava-part-1/" target="_blank" rel="external">英文原文</a> </p>
<p><a href="http://blog.csdn.net/lzyzsd/article/details/41833541" target="_blank" rel="external">译文原文</a> </p>
<p><a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="external">RxJava</a>正在Android开发者中变的越来越流行。唯一的问题就是上手不容易，尤其是大部分人之前都是使用命令式编程语言。但是一旦你弄明白了，你就会发现RxJava真是太棒了。<br>这里仅仅是帮助你了解RxJava，整个系列共有四篇文章，希望你看完这四篇文章之后能够了解RxJava背后的思想，并且喜欢上RxJava。</p>
<p>RxJava最核心的两个东西是Observables（被观察者，事件源）和 Subscribers（观察者）。Observables发出一系列事件，Subscribers处理这些事件。这里的事件可以是任何你感兴趣的东西 （触摸事件，web接口调用返回的数据。。。）</p>
<p>一个Observable可以发出零个或者多个事件，知道结束或者出错。每发出一个事件，就会调用它的Subscriber的onNext方法，最后调用Subscriber.onNext()或者Subscriber.onError()结束。</p>
<p>Rxjava的看起来很想设计模式中的观察者模式，但是有一点明显不同，那就是如果一个Observerble没有任何的的Subscriber，那么这个Observable是不会发出任何事件的。</p>
<h1 id="Hello_World"><a href="#Hello_World" class="headerlink" title="Hello World"></a>Hello World</h1><a id="more"></a>
<p>创建一个Observable对象很简单，直接调用Observable.create即可</p>
<p><code>Observable&lt;String&gt; myObservable = Observable.create(</code></p>
<p><code>new</code> <code>Observable.OnSubscribe&lt;String&gt;() {</code></p>
<p><code>@Override</code></p>
<p><code>public void call(Subscriber&lt;? ``super</code> <code>String&gt; sub) {</code></p>
<p><code>sub.onNext(``&quot;Hello, world!&quot;``);</code></p>
<p><code>sub.onCompleted();</code></p>
<p><code>}</code></p>
<p><code>}</code></p>
<p><code>);</code></p>
<p>这里定义的Observable对象仅仅发出一个Hello World字符串，然后就结束了。接着我们创建一个Subscriber来处理Observable对象发出的字符串。</p>
<p><code>Subscriber&lt;String&gt; mySubscriber = ``new</code> <code>Subscriber&lt;String&gt;() {</code></p>
<p><code>@Override</code></p>
<p><code>public void onNext(String s) { System.out.println(s); }</code></p>
<p><code>@Override</code></p>
<p><code>public void onCompleted() { }</code></p>
<p><code>@Override</code></p>
<p><code>public void onError(Throwable e) { }</code></p>
<p><code>};</code></p>
<p>这里subscriber仅仅就是打印observable发出的字符串。通过subscribe函数就可以将我们定义的myObservable对象和mySubscriber对象关联起来，这样就完成了subscriber对observable的订阅。</p>
<p><code>myObservable.subscribe(mySubscriber);</code></p>
<p>一旦mySubscriber订阅了myObservable，myObservable就是调用mySubscriber对象的onNext和onComplete方法，mySubscriber就会打印出Hello World！</p>
<h2 id="u66F4_u7B80_u6D01_u7684_u4EE3_u7801"><a href="#u66F4_u7B80_u6D01_u7684_u4EE3_u7801" class="headerlink" title="更简洁的代码"></a>更简洁的代码</h2><p>是不是觉得仅仅为了打印一个hello world要写这么多代码太啰嗦？我这里主要是为了展示RxJava背后的原理而采用了这种比较啰嗦的写法，RxJava其实提供了很多便捷的函数来帮助我们减少代码。</p>
<p>首先来看看如何简化Observable对象的创建过程。RxJava内置了很多简化创建Observable对象的函数，比如 Observable.just就是用来创建只发出一个事件就结束的Observable对象，上面创建Observable对象的代码可以简化为一行</p>
<p><code>Observable&lt;String&gt; myObservable = Observable.just(``&quot;Hello, world!&quot;``);</code></p>
<p>接下来看看如何简化Subscriber，上面的例子中，我们其实并不关心OnComplete和OnError，我们只需要在onNext的时候做一些处理，这时候就可以使用Action1类。</p>
<p><code>Action1&lt;String&gt; onNextAction = ``new</code> <code>Action1&lt;String&gt;() {</code></p>
<p><code>@Override</code></p>
<p><code>public void call(String s) {</code></p>
<p><code>System.out.println(s);</code></p>
<p><code>}</code></p>
<p><code>};</code></p>
<p>subscribe方法有一个重载版本，接受三个Action1类型的参数，分别对应OnNext，OnComplete， OnError函数。</p>
<p><code>myObservable.subscribe(onNextAction, onErrorAction, onCompleteAction);</code></p>
<p>这里我们并不关心onError和onComplete，所以只需要第一个参数就可以</p>
<p><code>myObservable.subscribe(onNextAction);</code></p>
<p><code>// Outputs &quot;Hello, world!&quot;</code></p>
<p>上面的代码最终可以写成这样</p>
<p><code>Observable.just(``&quot;Hello, world!&quot;``)</code></p>
<p><code>.subscribe(``new</code> <code>Action1&lt;String&gt;() {</code></p>
<p><code>@Override</code></p>
<p><code>public void call(String s) {</code></p>
<p><code>System.out.println(s);</code></p>
<p><code>}</code></p>
<p><code>});</code></p>
<p>使用java8的lambda可以使代码更简洁</p>
<p><code>Observable.just(``&quot;Hello, world!&quot;``)</code></p>
<p><code>.subscribe(s -&gt; System.out.println(s));</code></p>
<p>Android开发中，强烈推荐使用<a href="https://github.com/evant/gradle-retrolambda" target="_blank" rel="external">retrolambda</a>这个gradle插件，这样你就可以在你的代码中使用lambda了。</p>
<p>让我们做一些更有趣的事情吧！<br>比如我想在hello world中加上我的签名，你可能会想到去修改Observable对象：</p>
<p><code>Observable.just(``&quot;Hello, world! -Dan&quot;``)</code></p>
<p><code>.subscribe(s -&gt; System.out.println(s));</code></p>
<p>如果你能够改变Observable对象，这当然是可以的，但是如果你不能修改Observable对象呢？比如Observable对象是第三方库提供的？比如我的Observable对象被多个Subscriber订阅，但是我只想在对某个订阅者做修改呢？<br>那么在Subscriber中对事件进行修改怎么样呢？比如下面的代码：</p>
<p><code>Observable.just(``&quot;Hello, world!&quot;``)</code></p>
<p><code>.subscribe(s -&gt; System.out.println(s + ``&quot; -Dan&quot;``));</code></p>
<p>这种方式仍然不能让人满意，因为我希望我的Subscribers越轻量越好，因为我有可能会在mainThread中运行subscriber。另外， 根据响应式函数编程的概念，Subscribers更应该做的事情是“响应”，响应Observable发出的事件，而不是去修改。如果我能在某些中间步 骤中对“Hello World！”进行变换是不是很酷？</p>
<h2 id="u64CD_u4F5C_u7B26_uFF08Operators_uFF09"><a href="#u64CD_u4F5C_u7B26_uFF08Operators_uFF09" class="headerlink" title="操作符（Operators）"></a>操作符（Operators）</h2><p>操作符就是为了解决对Observable对象的变换的问题，操作符用于在Observable和最终的Subscriber之间修改Observable发出的事件。RxJava提供了很多很有用的操作符。<br>比如map操作符，就是用来把把一个事件转换为另一个事件的。</p>
<p><code>Observable.just(``&quot;Hello, world!&quot;``)</code></p>
<p><code>.map(``new</code> <code>Func1&lt;String, String&gt;() {</code></p>
<p><code>@Override</code></p>
<p><code>public String call(String s) {</code></p>
<p><code>return</code> <code>s + ``&quot; -Dan&quot;``;</code></p>
<p><code>}</code></p>
<p><code>})</code></p>
<p><code>.subscribe(s -&gt; System.out.println(s));</code></p>
<p>使用lambda可以简化为</p>
<p><code>Observable.just(``&quot;Hello, world!&quot;``)</code></p>
<p><code>.map(s -&gt; s + ``&quot; -Dan&quot;``)</code></p>
<p><code>.subscribe(s -&gt; System.out.println(s));</code></p>
<p>是不是很酷？map()操作符就是用于变换Observable对象的，map操作符返回一个Observable对象，这样就可以实现链式调用，在一个Observable对象上多次使用map操作符，最终将最简洁的数据传递给Subscriber对象。</p>
<h2 id="map_u64CD_u4F5C_u7B26_u8FDB_u9636"><a href="#map_u64CD_u4F5C_u7B26_u8FDB_u9636" class="headerlink" title="map操作符进阶"></a>map操作符进阶</h2><p>map操作符更有趣的一点是它不必返回Observable对象返回的类型，你可以使用map操作符返回一个发出新的数据类型的observable对象。<br>比如上面的例子中，subscriber并不关心返回的字符串，而是想要字符串的hash值</p>
<p><code>Observable.just(``&quot;Hello, world!&quot;``)</code></p>
<p><code>.map(``new</code> <code>Func1&lt;String, Integer&gt;() {</code></p>
<p><code>@Override</code></p>
<p><code>public Integer call(String s) {</code></p>
<p><code>return</code> <code>s.hashCode();</code></p>
<p><code>}</code></p>
<p><code>})</code></p>
<p><code>.subscribe(i -&gt; System.out.println(Integer.toString(i)));</code></p>
<p>很有趣吧？我们初始的Observable返回的是字符串，最终的Subscriber收到的却是Integer，当然使用lambda可以进一步简化代码：</p>
<p><code>Observable.just(``&quot;Hello, world!&quot;``)</code></p>
<p><code>.map(s -&gt; s.hashCode())</code></p>
<p><code>.subscribe(i -&gt; System.out.println(Integer.toString(i)));</code></p>
<p>前面说过，Subscriber做的事情越少越好，我们再增加一个map操作符</p>
<p><code>Observable.just(``&quot;Hello, world!&quot;``)</code></p>
<p><code>.map(s -&gt; s.hashCode())</code></p>
<p><code>.map(i -&gt; Integer.toString(i))</code></p>
<p><code>.subscribe(s -&gt; System.out.println(s));</code></p>
<p>是不是觉得我们的例子太简单，不足以说服你？你需要明白下面的两点:</p>
<p>1.Observable和Subscriber可以做任何事情<br>Observable可以是一个数据库查询，Subscriber用来显示查询结果；Observable可以是屏幕上的点击事件，Subscriber用来响应点击事件；Observable可以是一个网络请求，Subscriber用来显示请求结果。</p>
<p>2.Observable和Subscriber是独立于中间的变换过程的。<br>在Observable和Subscriber中间可以增减任何数量的map。整个系统是高度可组合的，操作数据是一个很简单的过程。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://blog.danlew.net/2014/09/15/grokking-rxjava-part-1/">英文原文</a> </p>
<p><a href="http://blog.csdn.net/lzyzsd/article/details/41833541">译文原文</a> </p>
<p><a href="https://github.com/ReactiveX/RxJava">RxJava</a>正在Android开发者中变的越来越流行。唯一的问题就是上手不容易，尤其是大部分人之前都是使用命令式编程语言。但是一旦你弄明白了，你就会发现RxJava真是太棒了。<br>这里仅仅是帮助你了解RxJava，整个系列共有四篇文章，希望你看完这四篇文章之后能够了解RxJava背后的思想，并且喜欢上RxJava。</p>
<p>RxJava最核心的两个东西是Observables（被观察者，事件源）和 Subscribers（观察者）。Observables发出一系列事件，Subscribers处理这些事件。这里的事件可以是任何你感兴趣的东西 （触摸事件，web接口调用返回的数据。。。）</p>
<p>一个Observable可以发出零个或者多个事件，知道结束或者出错。每发出一个事件，就会调用它的Subscriber的onNext方法，最后调用Subscriber.onNext()或者Subscriber.onError()结束。</p>
<p>Rxjava的看起来很想设计模式中的观察者模式，但是有一点明显不同，那就是如果一个Observerble没有任何的的Subscriber，那么这个Observable是不会发出任何事件的。</p>
<h1 id="Hello_World"><a href="#Hello_World" class="headerlink" title="Hello World"></a>Hello World</h1>]]>
    
    </summary>
    
      <category term="RxJava" scheme="http://apanda.club/tags/RxJava/"/>
    
      <category term="技术" scheme="http://apanda.club/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[谷歌官方出的一套关于 Android 架构的实例参考]]></title>
    <link href="http://apanda.club/2016/03/29/%E8%B0%B7%E6%AD%8C%E5%AE%98%E6%96%B9%E5%87%BA%E7%9A%84%E4%B8%80%E5%A5%97%E5%85%B3%E4%BA%8E%20Android%20%E6%9E%B6%E6%9E%84%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8F%82%E8%80%83/"/>
    <id>http://apanda.club/2016/03/29/谷歌官方出的一套关于 Android 架构的实例参考/</id>
    <published>2016-03-29T05:12:17.000Z</published>
    <updated>2016-04-10T08:44:24.000Z</updated>
    <content type="html"><![CDATA[<p>原文 <a href="https://github.com/googlesamples/android-architecture" target="_blank" rel="external">github.com</a></p>
<p>The Android framework offers a lot of flexibility when it comes to defining how to organize and <em>architect</em> an Android app. This freedom, whilst very valuable, can also result in apps with large classes, inconsistent naming and architectures (or lack of) that can make testing, maintaining and extending difficult.</p>
<p>Android Architecture Blueprints is meant to demonstrate possible ways to help with these common problems. In this project we offer the same application implemented using different architectural concepts and tools.</p>
<p>You can use these samples as a reference or as a starting point for creating your own apps. The focus here is on code structure, architecture, testing and maintainability. However, bear in mind that there are many ways to build apps with these architectures and tools, depending on your priorities, so these shouldn’t be considered canonical examples. The UI is deliberately kept simple.</p>
<p><strong>What does <em>*</em></strong>beta<strong>*</strong> mean?**</p>
<p>We’re still making decisions that could affect all samples so we’re keeping the initial number of variants low before the stable release.</p>
<p><strong>Samples</strong></p>
<p>All projects are released in their own branch. Check each project’s README for more information.<br><a id="more"></a><br>In progress:</p>
<ul>
<li>todo-mvp-contentproviders - Based on todo-mvp-loaders, uses Content Providers</li>
<li>todo-mvp-clean - Based on todo-mvp, uses concepts from Clean Architecture.</li>
<li>todo-mvp-dagger - Based on todo-mvp, uses Dagger2 for Dependency Injection</li>
</ul>
<p>Also, see <a href="https://github.com/googlesamples/android-architecture/issues?q=is%3Aissue+is%3Aopen+label%3A%22New+sample%22" target="_blank" rel="external">“New sample” issues</a> for planned samples.</p>
<p><strong>Why a to-do application?</strong></p>
<p>The aim of the app is to be simple enough that it’s understood quickly, but complex enough to showcase difficult design decisions and testing scenarios. Check out the <a href="https://github.com/googlesamples/android-architecture/wiki/To-do-app-specification" target="_blank" rel="external">app’s specification</a>.</p>
<p><a href="https://github.com/googlesamples/android-architecture/wiki/images/tasks2.png" target="_blank" rel="external"><img src="https://raw.githubusercontent.com/wiki/googlesamples/android-architecture/images/tasks2.png" alt="Screenshot"></a></p>
<p>Also, a similar project exists to compare JavaScript frameworks, called <a href="https://github.com/tastejs/todomvc" target="_blank" rel="external">TodoMVC</a>.</p>
<p><strong>Which sample should I choose for my app?</strong></p>
<p>That’s for you to decide: each sample has a README where you’ll find metrics and subjective assessments. Your mileage may vary depending on the size of the app, the size and experience of your team, the amount of maintenance that you foresee, whether you need a tablet layout or support multiple platforms, how compact you like your codebase, etc.</p>
<p><strong>Who is behind this project?</strong></p>
<p>This project is made by the <a href="https://github.com/googlesamples/android-architecture/graphs/contributors" target="_blank" rel="external">community</a> and curated by Google and core maintainers. Each sample has a group of owners that look after it keeping it up to date and handling issues and pull requests.</p>
<p>Want to be part of it? Read <a href="https://github.com/googlesamples/android-architecture/blob/master/CONTRIBUTING.md" target="_blank" rel="external">how to become a contributor</a> and the <a href="https://github.com/googlesamples/android-architecture/wiki/Contributions" target="_blank" rel="external">contributor’s guide</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文 <a href="https://github.com/googlesamples/android-architecture">github.com</a></p>
<p>The Android framework offers a lot of flexibility when it comes to defining how to organize and <em>architect</em> an Android app. This freedom, whilst very valuable, can also result in apps with large classes, inconsistent naming and architectures (or lack of) that can make testing, maintaining and extending difficult.</p>
<p>Android Architecture Blueprints is meant to demonstrate possible ways to help with these common problems. In this project we offer the same application implemented using different architectural concepts and tools.</p>
<p>You can use these samples as a reference or as a starting point for creating your own apps. The focus here is on code structure, architecture, testing and maintainability. However, bear in mind that there are many ways to build apps with these architectures and tools, depending on your priorities, so these shouldn’t be considered canonical examples. The UI is deliberately kept simple.</p>
<p><strong>What does <em>*</em></strong>beta<strong>*</strong> mean?**</p>
<p>We’re still making decisions that could affect all samples so we’re keeping the initial number of variants low before the stable release.</p>
<p><strong>Samples</strong></p>
<p>All projects are released in their own branch. Check each project’s README for more information.<br>]]>
    
    </summary>
    
      <category term="架构的实例" scheme="http://apanda.club/tags/%E6%9E%B6%E6%9E%84%E7%9A%84%E5%AE%9E%E4%BE%8B/"/>
    
      <category term="技术" scheme="http://apanda.club/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从案例学习RxAndroid]]></title>
    <link href="http://apanda.club/2016/03/25/RxJava/RxAndroid/"/>
    <id>http://apanda.club/2016/03/25/RxJava/RxAndroid/</id>
    <published>2016-03-25T13:01:45.000Z</published>
    <updated>2016-04-07T03:37:12.000Z</updated>
    <content type="html"><![CDATA[<p><a herf="https://medium.com/@kurtisnusbaum/rxandroid-basics-part-1-c0d5edcf6850">原文链接</a></p>
<p>如果你在阅读这篇文章，相信你一定很想了解RxJava以及如何在Android应用中使用它。可能你已经见过RxJava的代码了，但仍然有些疑惑，愿你能在这篇文章里找到答案。</p>
<p>当我第一次使用RxJava的时候我只是在照搬代码，这些代码能跑起来，但是我对RxJava的基础部分仍然存在误解，而且我找不到好的源码来学习。所以为了理解RxJava，我不得不一点一点学习，踩了不少坑。</p>
<p>为了不让你把我踩过的坑再踩一遍，我会基于我的学习成果写一些例子出来，目的就是让你能够对RxJava有足够的了解，并能在你的Android应用中使用它。</p>
<p>源码可以在这里找到。在每个例子的开始，我会写清每个代码段是属于哪个Activity的。我会将本文分为两个部分，在前三个例子里，我会着重讲解如何用RxJava异步加载数据；在后三个例子里，我会探索一些更高级的用法。</p>
<p>在开始说代码之前，先澄清几个概念。RxJava最核心的东西就是Observable和Observer。Observable会发出数据，而与之相对的Observer则会通过订阅Observable来进行观察。</p>
<p>Observer可以在Observable发出数据、报错或者声明没有数据可以发送时进行相应的操作。这三个操作被封装在Observer接口中，相应的方法为onNext()，onError()和onCompleted()。</p>
<p>明确了这些概念以后，让我们来看一些例子。<br><a id="more"></a><br>案例1：基础</p>
<p>现在要写一个用来展示一个颜色列表的Activity。我们要写一个能发送一个字符串列表、然后结束的Observeable。而后我们会通过这个字符串列表来填充颜色列表，这里要使用到Observable.just()方法。由这个方法创建的Observable对象的特点是：所有Observer一旦订阅这个Observable就会立即调用onNext()方法并传入Observable.just()的参数，而后因为Observable没有数据可以发送了，onComplete()方法会被调用。</p>
<p>Observable<list<string>&gt; listObservable = Observable.just(getColorList());</list<string></p>
<p>注意这里的getColorList()是一个不耗时的方法。虽然现在看来这个方法无足轻重，但一会我们会回到这个方法。</p>
<p>下一步，我们写一个Observer来观察Observable。</p>
<p>listObservable.subscribe(new Observer<list<string>&gt;() {</list<string></p>
<pre><code>@Override
public void onCompleted() { }

@Override
public void onError(Throwable e) { }

@Override
public void onNext(List&lt;String&gt; colors) {
    mSimpleStringAdapter.setStrings(colors);
}
</code></pre><p>});</p>
<p>而后神奇的事情就发生了。如我刚才所说，一旦通过subscribe()方法订阅Observable，就会发生一系列事情：</p>
<ul>
<li><p>onNext()方法被调用，被发送的颜色列表会作为参数传入。</p>
</li>
<li><p>既然不再有数据可以发送（我们在Observable.just()中只让Observable发送一个数据），onComplete()方法会被调用。</p>
</li>
</ul>
<p>请记住：通过Observable被订阅后的行为来区分它们。</p>
<p>在这个例子中我们不关心Observable何时完成数据的传输，所以我们不用在onComplete()方法里写代码。而且在这里不会有异常抛出，所以我们也不用管onError()方法。</p>
<p>写了这么多你可能觉得很多余，毕竟我们本可以在adapter中直接设置作为数据源的颜色列表。请带着这个疑问，和我看下面这个更有趣一些的例子。</p>
<p>案例2：异步加载</p>
<p>在这里我们要写一个显示电视剧列表的Activity。在Android中RxJava的主要用途就在于异步数据加载。首先让我们写一个Observable：</p>
<p>Observable<list<string>&gt; tvShowObservable = Observable.fromCallable(new Callable<list<string>&gt;() {</list<string></list<string></p>
<pre><code>@Override
public List&lt;String&gt; call() {
    return mRestClient.getFavoriteTvShows();
}
</code></pre><p>});</p>
<p>在刚才的例子中，我们使用Observable.just()来创建Observable，你可能认为在这里可以通过Observable.just(mRestClient.getFavoriteTvShows())来创建Observable。</p>
<p>但在这里我们不能这么做，因为mRestClient.getFavoriteTvShows()会发起网络请求。如果在这里我们使用Observable.just()，mRestClient.getFavoriteTvShows()会被立即执行并阻塞UI线程。</p>
<p>使用Observable.fromCallable()方法有两点好处：</p>
<ul>
<li><p>获取要发送的数据的代码只会在有Observer订阅之后执行。</p>
</li>
<li><p>获取数据的代码可以在子线程中执行。</p>
</li>
</ul>
<p>这两点好处有时可能非常重要。现在让我们订阅这个Observable。</p>
<p>mTvShowSubscription = tvShowObservable<br>    .subscribeOn(Schedulers.io())<br>    .observeOn(AndroidSchedulers.mainThread())<br>    .subscribe(new Observer<list<string>&gt;() {</list<string></p>
<pre><code>    @Override
    public void onCompleted() { }

    @Override
    public void onError(Throwable e) { }

    @Override
    public void onNext(List&lt;String&gt; tvShows){
        displayTvShows(tvShows);
    }
});
</code></pre><p>让我们一个方法一个方法地来看这段代码。subscribeOn会修改我们刚刚创建的Observable。在默认情况下Observable的所有代码，包括刚才说到的只有在被订阅之后才会执行的代码，都会在执行subscribe()方法的线程中运行。而通过subscribeOn()方法，这些代码可以在其他线程中执行。但具体是哪个线程呢？</p>
<p>在这个例子中我们让代码在”IO Scheduler”中执行（Schedulers.io()）。现在我们可以只把Scheduler当做一个可以工作的子线程，这个描述对于现在的我们已经足够了，不过这其中还有更深层次的内容。</p>
<p>不过我们的确遇到了一个小障碍。既然Observable会在IO Scheduler中运行，那么它与Observer的连接也会在IO Scheduler中完成。这就意味着Observer的onNext()方法也会在IO Scheduler中运行，而onNext()方法会操作UI中的View，但View只能在UI主线程中操作。</p>
<p>事实上解决这个问题也很简单，我们可以告诉RxJava我们要在UI线程中观察这个Observable，也就是，我们想让onNext()方法在UI线程中执行。这一点我们可以通过在observeOn()方法中指定另一个Scheduler来完成，在这里也就是AndroidSchedules.mainThread()所返回的Scheduler(UI线程的Scheduler)。</p>
<p>而后我们调用subscribe()方法。这个方法最重要，因为Callable只会在有Observer订阅后运行。还记得刚才我说Observable通过其被订阅后的行为来区分吗？这就是一个很好的例子。</p>
<p>还有最后一件事。这个mTvShowSubscription到底是什么？每当Observer订阅Observable时就会生成一个Subscription对象。一个Subscription代表了一个Observer与Observable之间的连接。有时我们需要操作这个连接，这里拿在Activity的onDestroy()方法中的代码举个例子：</p>
<p>if (mTvShowSubscription != null &amp;&amp; !mTvShowSubscription.isUnsubscribed()) {<br>    mTvShowSubscription.unsubscribe();<br>}</p>
<p>如果你与多线程打过交道，你肯定会意识到一个大坑：当Activity执行onDestroy()后线程才结束（甚至永不结束）的话，就有可能发生内存泄漏与NullPointerException空指针异常。</p>
<p>Subscription就可以解决这个问题，我们可以通过调用unsubscribe()方法告诉Observable它所发送的数据不再被Observer所接收。在调用unsubscribe()方法后，我们创建的Observer就不再会收到数据了，同时也就解决了刚才说的问题。</p>
<p>说到这里难点已经过去，让我们来总结一下：</p>
<ul>
<li><p>Observable.fromCallable()方法可以拖延Observable获取数据的操作，这一点在数据需要在其他线程获取时尤其重要。</p>
</li>
<li><p>subscribeOn()让我们在指定线程中运行获取数据的代码，只要不是UI线程就行。</p>
</li>
<li><p>observeOn()让我们在合适的线程中接收Observable发送的数据，在这里是UI主线程。</p>
</li>
<li><p>记住要让Observer取消订阅以免Observable异步加载数据时发生意外。</p>
</li>
</ul>
<p>案例3：使用Single</p>
<p>这次我们还是写一个展示电视剧列表的Activity，但这次我们走一种更简单的风格。Observable挺好用的，但在某些情况下过于重量级。比如说，你可能一经发现在过去的两个方法中我们只是让Observable发送一个数据，而且我们从来也没写过onComplete()回调方法。</p>
<p>其实呢，Observable还有一个精简版，叫做Single。Single几乎和Observable一模一样，但其回调方法不是onComplete()/onNext()/onError()，而是onSuccess()/onError()。</p>
<p>我们现在把刚才写过的Observable用Single重写一遍。首先我们要创建一个Single:</p>
<p>Single<list<string>&gt; tvShowSingle = Single.fromCallable(new Callable<list<string>&gt;() {<br>    @Override<br>    public List<string> call() throws Exception {<br>        mRestClient.getFavoriteTvShows();<br>    }<br>});</string></list<string></list<string></p>
<p>然后订阅一下：</p>
<p>mTvShowSubscription = tvShowSingle<br>    .subscribeOn(Schedulers.io())<br>    .observeOn(AndroidSchedulers.mainThread())<br>    .subscribe(new SingleSubscriber<list<string>&gt;() {</list<string></p>
<pre><code>    @Override
    public void onSuccess(List&lt;String&gt; tvShows) {
        displayTvShows(tvShows);
    }

    @Override
    public void onError(Throwable error) {
        displayErrorMessage();
    }
});
</code></pre><p>这段代码和刚才很像，我们调用subscribeOn()方法以确保getFavoriteTvShows()在子线程中执行。而后我们调用observeOn()以确保Single的数据被发送到UI线程。</p>
<p>但这次我们不再使用Observer，而是使用一个叫SingleSubscriber的类。这个类和Observer非常像，只不过它只有上述两个方法：onSuccess()和onError()。SingleSubscriber之于Single就如Observer之于Observable。</p>
<p>订阅一个Single的同时也会自动创建一个Subscription对象。这里的Subscription和案例2中没有区别，一定要在onDestroy()中解除订阅。</p>
<p>最后一点：在这里我们添加了处理异常的代码，所以如果mRestClient出了问题，onError()就会被调用。建议你亲手写一个案例玩一玩，体验一下有异常时程序是怎么运行的。</p>
<p>案例4：Subjects</p>
<p>现在我们写一个Activity，里面要展示一个数字并有一个自增按钮。在看代码之前，先介绍另一个有关RxJava的概念，Subject。Subject这个对象既是Observable又是Observer，我会把Subject想象成一个管道：从一端把数据注入，结果就会从另一端输出。</p>
<p>Subject有好几类，在这里我们使用最简单的：PublishSubject。使用PublishSubject时，一旦数据从一端注入，结果会立即从另一端输出。</p>
<p>首先我们要写这个管道的输出端。刚才说了Subject也是Observable，也就是说我们可以像观察任何一个Observable一样观察它。这段代码的功能就是观察管道的输出端到底输出了什么。我们在这里写一个很简单的Observer来更新mCounterDisplay控件。</p>
<p>mCounterEmitter = PublishSubject.create();<br>mCounterEmitter.subscribe(new Observer<integer>() {</integer></p>
<pre><code>@Override
public void onCompleted() { }

@Override
public void onError(Throwable e) { }

@Override
public void onNext(Integer integer) {
    mCounterDisplay.setText(String.valueOf(integer));
}
</code></pre><p>});</p>
<p>与前面的几个例子不同，在这个例子中onNext()会被调用多次。每次发送新的数据时，mCounterDisplay都会展示新的数据。但是PublishSubject怎么发送数据呢？让我们看一下mIncrementButton的监听代码。</p>
<p>mIncrementButton.setOnClickListener(new View.OnClickListener() {</p>
<pre><code>@Override
public void onClick(View v) {
    mCounter++;
    mCounterEmitter.onNext(mCounter);
}
</code></pre><p>});</p>
<p>可以看到mIncrementButton在onClick()回调方法中做了两件事情：</p>
<ul>
<li><p>让mCounter变量自增。</p>
</li>
<li><p>调用mCounterEmitter的onNext()方法并传入mCounter。</p>
</li>
</ul>
<p>由于Subject同时也是Observer，所以它也有onNext()方法，因此我们可以通过调用onNext()方法把数据注入管道的输入端，可以理解为同我们在一端中观察自增按钮是否被点击，然后把信息告知管道另一端的Observer。</p>
<p>案例5：Map()</p>
<p>我们现在要写一个只显示一个数字的Activity。这将是一个很简单的Activity，因为我们要在这里使用map方法。如果你接触过函数式编程，你可能对map并不陌生。你可以把map当做一个方法，它接收一个数据，然后输出另一个数据，当然输入输出的两个数据之间是有联系的。</p>
<p>我们先写一个只发送一个数字4的Single对象。</p>
<p>Single.just(4).map(new Func1<integer, string="">() {</integer,></p>
<pre><code>@Override
public String call(Integer integer) {
    return String.valueOf(integer);
}
</code></pre><p>}).subscribe(new SingleSubscriber<string>() {</string></p>
<pre><code>@Override
public void onSuccess(String value) {
    mValueDisplay.setText(value);
}

@Override
public void onError(Throwable error) { }
</code></pre><p>});</p>
<p>我们最终要显示Single所发送的数据，但首先我们需要将这个数据从Integer转为String，而这里的解决方法就是使用map()函数。正如刚才所说，map接收一个数据，进行处理而后输出它，这正是我们需要的。现在Single会发送数字4，我们使用map()方法将其转为String，而后交给Observer去展示它。</p>
<p>这个例子中对于map方法的使用很轻量，不过map可是非常强大的，在下一个例子中你可以看到，map可以被用来执行任意代码，在处理数据方面起到很重要的作用。</p>
<p>案例6：综合使用</p>
<p>现在我们要写一个用来根据名字搜索城市的Activity。在这个Activity中，我们要使用在这两篇文章中所学的所有知识并写一个比较大的例子。同时还要介绍一个新的概念：deboundce。开始。</p>
<p>现在我们要写一个PublishSubject，并能接收用书输入进输入框的数据，而后根据输入获取符合的列表，并展示。</p>
<p>mTextWatchSubscription = mSearchResultsSubject<br>    .debounce(400, TimeUnit.MILLISECONDS)<br>    .observeOn(Schedulers.io())<br>    .map(new Func1<string, list<string="">&gt;() {</string,></p>
<pre><code>    @Override
    public List&lt;String&gt; call(String s) {
        return mRestClient.searchForCity(s);
    }
})
.observeOn(AndroidSchedulers.mainThread())
.subscribe(new Observer&lt;List&lt;String&gt;&gt;() {

    @Override
    public void onCompleted() { }

    @Override
    public void onError(Throwable e) { }

    @Override
    public void onNext(List&lt;String&gt; cities) {
        handleSearchResults(cities);
    }
});
</code></pre><p>mSearchInput.addTextChangedListener(new TextWatcher() {</p>
<pre><code>@Override
public void beforeTextChanged(CharSequence s, int start, int count, int after) { }

@Override
public void onTextChanged(CharSequence s, int start, int before, int count) {
    mSearchResultsSubject.onNext(s.toString());
}

@Override
public void afterTextChanged(Editable s) { }
</code></pre><p>});</p>
<p>这段代码有不少内容，让我们一点一点分析。</p>
<p>首先你会看到debounce()方法。这是啥？有啥用？如果你看一下我们是如何给输入框添加监听器的，你会发现每当输入的内容改变时都会有输入发送到mSearchResultsSubject，不过我们不想让用户每点一个键都向服务器请求一次。我们想等一会，等用户停止输入（代表差不多输完）的时候再请求服务器。</p>
<p>而debounce()方法就是做这个的。这个方法告诉mSearchResultsSubject在没有数据传入达400毫秒时才发送数据。意思就是，仅当用户400ms都没有改变输入内容时，Subject才会发送最新的搜索字符串。这样以来我们就不会进行无意义的网络请求了，UI也不会每输入一个字符都更新。</p>
<p>我们想通过RestClient来访问服务器，而因为RestClient涉及IO操作，我们需要在IO Scheduler中进行这个操作，所以要写observeOn(Schedulers.io())。</p>
<p>好了，现在我们会把搜索字段发送到IO Scheduler中，在这里map就要发挥作用了，我们在map方法中通过关键字获取搜索结果的列表。在map中我们可以调用任意外部方法，在这里使用RestClient获取搜索结果。</p>
<p>因为map方法会在IO Scheduler中运行，而我们又要用其返回值填充View，所以要重新切换到UI线程，所以要写observeOn(AndroidSchedulers.mainThread())。现在搜索结果会被发送到UI线程。要注意两个observeOn()方法的顺序，这一点至关重要。现在我们总结一下数据发送的顺序。</p>
<p>mSearchResultsSubject<br>            |<br>            |<br>            V<br>        debounce<br>          |||<br>          |||<br>          V<br>          map<br>          |<br>          |<br>          V<br>        observer</p>
<p>一个竖杠代表数据在UI线程中发送，三个竖杠代表数据在IO Scheduler中发送。</p>
<p>最终，我们获得搜索结果，并展示给用户。</p>
<p>有关RxJava就说这么多了，希望这篇文章能帮你了解RxJava的基础。强烈建议你自己探索有关RxJava的其他方面。如果你有问题或者只是想说点什么，欢迎在下方留言。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a herf="https://medium.com/@kurtisnusbaum/rxandroid-basics-part-1-c0d5edcf6850">原文链接</a></p>
<p>如果你在阅读这篇文章，相信你一定很想了解RxJava以及如何在Android应用中使用它。可能你已经见过RxJava的代码了，但仍然有些疑惑，愿你能在这篇文章里找到答案。</p>
<p>当我第一次使用RxJava的时候我只是在照搬代码，这些代码能跑起来，但是我对RxJava的基础部分仍然存在误解，而且我找不到好的源码来学习。所以为了理解RxJava，我不得不一点一点学习，踩了不少坑。</p>
<p>为了不让你把我踩过的坑再踩一遍，我会基于我的学习成果写一些例子出来，目的就是让你能够对RxJava有足够的了解，并能在你的Android应用中使用它。</p>
<p>源码可以在这里找到。在每个例子的开始，我会写清每个代码段是属于哪个Activity的。我会将本文分为两个部分，在前三个例子里，我会着重讲解如何用RxJava异步加载数据；在后三个例子里，我会探索一些更高级的用法。</p>
<p>在开始说代码之前，先澄清几个概念。RxJava最核心的东西就是Observable和Observer。Observable会发出数据，而与之相对的Observer则会通过订阅Observable来进行观察。</p>
<p>Observer可以在Observable发出数据、报错或者声明没有数据可以发送时进行相应的操作。这三个操作被封装在Observer接口中，相应的方法为onNext()，onError()和onCompleted()。</p>
<p>明确了这些概念以后，让我们来看一些例子。<br>]]>
    
    </summary>
    
      <category term="RxAndroid" scheme="http://apanda.club/tags/RxAndroid/"/>
    
      <category term="技术" scheme="http://apanda.club/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android小经验]]></title>
    <link href="http://apanda.club/2016/03/23/%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84%E9%82%A3%E4%BA%9BAndroid%E5%B0%8F%E7%BB%8F%E9%AA%8C/"/>
    <id>http://apanda.club/2016/03/23/小知识点/你应该知道的那些Android小经验/</id>
    <published>2016-03-23T15:33:02.000Z</published>
    <updated>2016-04-10T10:08:20.000Z</updated>
    <content type="html"><![CDATA[<p>原文出处：<a href="http://jayfeng.com/2016/03/18/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84%E9%82%A3%E4%BA%9BAndroid%E5%B0%8F%E7%BB%8F%E9%AA%8C/" target="_blank" rel="external">http://jayfeng.com/</a> </p>
<p>做Android久了，就会踩很多坑，被坑的多了就有经验了，闲暇之余整理了部分，现挑选一些重要或者偏门的“小”经验做个记录。</p>
<h2 id="u67E5_u770BSQLite_u65E5_u5FD7"><a href="#u67E5_u770BSQLite_u65E5_u5FD7" class="headerlink" title="查看SQLite日志"></a>查看SQLite日志</h2><p><code>adb shell setprop log.tag.SQLiteLog V</code></p>
<p><code>adb shell setprop log.tag.SQLiteStatements V</code></p>
<p>因为实现里用了Log.isLoggable(TAG, Log.VERBOSE)做了判断，LessCode的LogLess中也参考了这种机制：<a href="https://github.com/openproject/LessCode/blob/master/lesscode-core/src/main/java/com/jayfeng/lesscode/core/LogLess.java" target="_blank" rel="external">LogLess</a>。<br>使用这种方法就可以在Release版本也能做到查看应用的打印日志了。</p>
<h2 id="PNG_u4F18_u5316"><a href="#PNG_u4F18_u5316" class="headerlink" title="PNG优化"></a>PNG优化</h2><p>APK打包会自动对PNG进行无损压缩，如果自行无损压缩是无效的。<br>当然进行有损压缩是可以的：<a href="https://tinypng.com/" target="_blank" rel="external">https://tinypng.com/</a></p>
<h2 id="Tcpdump_u6293_u5305"><a href="#Tcpdump_u6293_u5305" class="headerlink" title="Tcpdump抓包"></a>Tcpdump抓包</h2><a id="more"></a>
<p>有些模拟器比如genymotion自带了tcpdump，如果没有的话，需要下载tcpdump:<br><a href="http://www.strazzere.com/android/tcpdump" target="_blank" rel="external">http://www.strazzere.com/android/tcpdump</a><br>把tcpdump push到/data/local下，抓包命令：</p>
<p><code>adb shell  /data/local/tcpdump -i any -p -s 0 -w /sdcard/capture.pcap</code></p>
<p>很多开发者服务都需要绑定签名信息，用下面的命令可以查看签名：</p>
<p><code>keytool -list -v -keystore release.jks</code></p>
<p>注意，这个是需要密码的，可以查看MD5, SHA1，SHA256等等。</p>
<h2 id="u5355_u4F8B_u6A21_u5F0F_28_u61D2_u6C49_u5F0F_29_u7684_u66F4_u597D_u7684_u5199_u6CD5"><a href="#u5355_u4F8B_u6A21_u5F0F_28_u61D2_u6C49_u5F0F_29_u7684_u66F4_u597D_u7684_u5199_u6CD5" class="headerlink" title="单例模式(懒汉式)的更好的写法"></a>单例模式(懒汉式)的更好的写法</h2><p>特别说到这个问题，是因为网上很多这样的代码：</p>
<p><code>public class Singleton {</code></p>
<p><code>private static Singleton instance;</code></p>
<p><code>private Singleton (){}</code></p>
<p><code>public static Singleton getInstance() {</code></p>
<p><code>if</code> <code>(instance == ``null``) {</code></p>
<p><code>instance = ``new</code> <code>Singleton();</code></p>
<p><code>}</code></p>
<p><code>return</code> <code>instance;</code></p>
<p><code>}</code></p>
<p><code>}</code></p>
<p>这种写法线程不安全，改进一下，加一个同步锁：</p>
<p><code>public class Singleton {</code></p>
<p><code>private static Singleton instance;</code></p>
<p><code>private Singleton (){}</code></p>
<p><code>public static synchronized Singleton getInstance() {</code></p>
<p><code>if</code> <code>(instance == ``null``) {</code></p>
<p><code>instance = ``new</code> <code>Singleton();</code></p>
<p><code>}</code></p>
<p><code>return</code> <code>instance;</code></p>
<p><code>}</code></p>
<p><code>}</code></p>
<p>网上这样的代码更多，可以很好的工作，但是缺点是效率低。<br>实际上，早在JDK1.5就引入volatile关键字，所以又有了一种更好的双重校验锁写法：</p>
<p><code>public class Singleton {</code></p>
<p><code>private volatile static Singleton singleton;</code></p>
<p><code>private Singleton (){}</code></p>
<p><code>public static Singleton getSingleton() {</code></p>
<p><code>if</code> <code>(singleton == ``null``) {</code></p>
<p><code>synchronized (Singleton.class) {</code></p>
<p><code>if</code> <code>(singleton == ``null``) {</code></p>
<p><code>singleton = ``new</code> <code>Singleton();</code></p>
<p><code>}</code></p>
<p><code>}</code></p>
<p><code>}</code></p>
<p><code>return</code> <code>singleton;</code></p>
<p><code>}</code></p>
<p><code>}</code></p>
<p>注意，别忘记volatile关键字哦，否则就是10重，100重也可能还是会出问题。<br>上面是用的最多的，还有一种静态内部类写法更推荐：</p>
<p><code>publlic class Singleton {</code></p>
<p><code>private Singleton() {}</code></p>
<p><code>private static class SingletonLoader {</code></p>
<p><code>private static final Singleton INSTANCE = ``new</code> <code>Singleton();</code></p>
<p><code>}</code></p>
<p><code>public static Singleton getInstance() {</code></p>
<p><code>return</code> <code>SingletonLoader.INSTANCE;</code></p>
<p><code>}</code></p>
<p><code>}</code></p>
<h2 id="u591A_u8FDB_u7A0BApplication"><a href="#u591A_u8FDB_u7A0BApplication" class="headerlink" title="多进程Application"></a>多进程Application</h2><p>是不是经常发现Application里的方法执行了多次？百思不得其解。<br>因为当有多个进程的时候，Application会执行多次，可以通过pid来判断那些方法只执行一次，避免浪费资源。</p>
<h2 id="u9690_u5F0F_u542F_u52A8Service"><a href="#u9690_u5F0F_u542F_u52A8Service" class="headerlink" title="隐式启动Service"></a>隐式启动Service</h2><p>这是Android5.0的一个改动，不支持隐式的Service调用。下面的代码在Android 5.0+上会报错：Service Intent must be explicit：</p>
<p><code>Intent serviceIntent = ``new</code> <code>Intent();</code></p>
<p><code>serviceIntent.setAction(``&quot;com.jayfeng.MyService&quot;``);</code></p>
<p><code>context.startService(serviceIntent);</code></p>
<p>可改成如下：</p>
<p><code>// 指定具体Service类，或者有packageName也行</code></p>
<p><code>Intent serviceIntent = ``new</code> <code>Intent(context, MyService.class);</code></p>
<p><code>context.startService(serviceIntent);</code></p>
<h2 id="fill_parent_u7684_u5BFF_u547D"><a href="#fill_parent_u7684_u5BFF_u547D" class="headerlink" title="fill_parent的寿命"></a>fill_parent的寿命</h2><p>在Android2.2之后，支持使用match_parent。你的布局文件里是不是既有fill_parent和match_parent显得很乱？<br>如果你现在的minSdkVersion是8+的话，就可以忽略fill_parent，统一使用match_parent了，否则请使用fill_parent。</p>
<h2 id="ListView_u7684_u5C40_u90E8_u5237_u65B0"><a href="#ListView_u7684_u5C40_u90E8_u5237_u65B0" class="headerlink" title="ListView的局部刷新"></a>ListView的局部刷新</h2><p>有的列表可能notifyDataSetChanged()代价有点高，最好能局部刷新。<br>局部刷新的重点是，找到要更新的那项的View，然后再根据业务逻辑更新数据即可。</p>
<p><code>private void updateItem(int index) {</code></p>
<p><code>int visiblePosition = listView.getFirstVisiblePosition();</code></p>
<p><code>if</code> <code>(index - visiblePosition &gt;= 0) {</code></p>
<p><code>//得到要更新的item的view</code></p>
<p><code>View view = listView.getChildAt(index - visiblePosition);</code></p>
<p><code>// 更新界面（示例参考）</code></p>
<p><code>// TextView nameView = ViewLess.$(view, R.id.name);</code></p>
<p><code>// nameView.setText(&quot;update &quot; + index);</code></p>
<p><code>// 更新列表数据（示例参考）</code></p>
<p><code>// list.get(index).setName(&quot;Update &quot; + index);</code></p>
<p><code>}</code></p>
<p><code>}</code></p>
<p>强调一下，最后那个列表数据别忘记更新， 不然数据源不变，一滚动可能又还原了。</p>
<h2 id="u7CFB_u7EDF_u65E5_u5FD7_u4E2D_u51E0_u4E2A_u91CD_u8981_u7684TAG"><a href="#u7CFB_u7EDF_u65E5_u5FD7_u4E2D_u51E0_u4E2A_u91CD_u8981_u7684TAG" class="headerlink" title="系统日志中几个重要的TAG"></a>系统日志中几个重要的TAG</h2><p><code>// 查看Activity跳转</code></p>
<p><code>adb logcat -v time | grep ActivityManager</code></p>
<p><code>// 查看崩溃信息</code></p>
<p><code>adb logcat -v time | grep AndroidRuntime</code></p>
<p><code>// 查看Dalvik信息，比如GC</code></p>
<p><code>adb logcat -v time | grep ``&quot;D\/Dalvik&quot;</code></p>
<p><code>// 查看art信息，比如GC</code></p>
<p><code>adb logcat -v time | grep ``&quot;I\/art&quot;</code></p>
<h2 id="u4E00_u884C_u5C45_u4E2D_uFF0C_u591A_u884C_u5C45_u5DE6_u7684TextView"><a href="#u4E00_u884C_u5C45_u4E2D_uFF0C_u591A_u884C_u5C45_u5DE6_u7684TextView" class="headerlink" title="一行居中，多行居左的TextView"></a>一行居中，多行居左的TextView</h2><p>这个一般用于提示信息对话框，如果文字是一行就居中，多行就居左。<br>在TextView外套一层wrap_content的ViewGroup即可简单实现：</p>
<p><code>&lt;RelativeLayout xmlns:android=``&quot;&lt;http://schemas.android.com/apk/res/android&gt;&quot;</code></p>
<p><code>android:layout_width=``&quot;match_parent&quot;</code></p>
<p><code>android:layout_height=``&quot;match_parent&quot;``&gt;</code></p>
<p><code>&lt;!-- 套一层wrap_content的ViewGroup --&gt;</code></p>
<p><code>&lt;LinearLayout</code></p>
<p><code>android:layout_width=``&quot;wrap_content&quot;</code></p>
<p><code>android:layout_height=``&quot;wrap_content&quot;</code></p>
<p><code>android:layout_centerInParent=``&quot;true&quot;``&gt;</code></p>
<p><code>&lt;TextView</code></p>
<p><code>android:layout_width=``&quot;wrap_content&quot;</code></p>
<p><code>android:layout_height=``&quot;wrap_content&quot;</code></p>
<p><code>android:text=``&quot;@string/hello_world&quot;</code> <code>/&gt;</code></p>
<p><code>&lt;/LinearLayout&gt;</code></p>
<p><code>&lt;/RelativeLayout&gt;</code></p>
<h2 id="setCompoundDrawablesWithIntrinsicBounds_28_29"><a href="#setCompoundDrawablesWithIntrinsicBounds_28_29" class="headerlink" title="setCompoundDrawablesWithIntrinsicBounds()"></a>setCompoundDrawablesWithIntrinsicBounds()</h2><p>网上一大堆setCompoundDrawables()方法无效不显示的问题，然后解决方法是setBounds，需要计算大小…<br>不用这么麻烦，用setCompoundDrawablesWithIntrinsicBounds()这个方法最简单！</p>
<h2 id="u8BA1_u7B97_u7A0B_u5E8F_u8FD0_u884C_u65F6_u95F4"><a href="#u8BA1_u7B97_u7A0B_u5E8F_u8FD0_u884C_u65F6_u95F4" class="headerlink" title="计算程序运行时间"></a>计算程序运行时间</h2><p>为了计算一段代码运行时间，一般的做法是，在代码的前面加个startTime，在代码的后面把当前时间减去startTime，这个时间差就是运行时间。<br>这里提供一种写起来更方便的方法，完全无时间逻辑，只是加一个打印log就够了。</p>
<p><code>// 测试setContentView()的时间</code></p>
<p><code>Log.d(``&quot;TAG&quot;``, ``&quot;Start&quot;``);</code></p>
<p><code>setContentView(R.layout.activity_http);</code></p>
<p><code>Log.d(``&quot;TAG&quot;``, ``&quot;End&quot;``);</code></p>
<p>没有计算时间的逻辑，这能测出来？<br>把日志过滤出来，运行命令“adb logcat -v time | grep TAG”：</p>
<p><code>03-18 14:47:25.477 D/TAG     (14600): Start</code></p>
<p><code>03-18 14:47:25.478 D/TAG     (14600): End</code></p>
<p>通过-v time参数，可以比较日志左边的时间来算出中间的代码运行的时间。</p>
<h2 id="JAVA_u5F15_u7528_u7C7B_u578B_u4E00_u89C8_u8868"><a href="#JAVA_u5F15_u7528_u7C7B_u578B_u4E00_u89C8_u8868" class="headerlink" title="JAVA引用类型一览表"></a>JAVA引用类型一览表</h2><p>对象引用：强引用 > 软引用 > 弱引用 > 虚引用。</p>
<p>引用类型回收时机用途生存时间强引用从来不会对象的一般状态JVM停止运行时终止软引用在内存不足时对象缓存内存不足时终止弱引用在垃圾回收时对象缓存GC运行后终止虚引用在垃圾回收时对象跟踪GC运行后终止</p>
<h2 id="Context_u4F7F_u7528_u573A_u666F"><a href="#Context_u4F7F_u7528_u573A_u666F" class="headerlink" title="Context使用场景"></a>Context使用场景</h2><p>为了防止Activity，Service等这样的Context泄漏于一些生命周期更长的对象，可以使用生命周期更长的ApplicationContext，但是不是所有的Context的都能替换为ApplicationContext<br>这是网上流传的一份表格：</p>
<p>ApplicationActivityServiceContentProviderBroadcastReceiverShow Dialog否是否否否Start Activity否是否否否Layout Inflation否是否否否Start Service是是是是是Bind Service是是是是否Send Broadcast是是是是是Regist BroadcastReceiver是是是是否Load Resource Value是是是是是</p>
<h2 id="u56FE_u7247_u7F13_u5B58_u5927_u5C0F"><a href="#u56FE_u7247_u7F13_u5B58_u5927_u5C0F" class="headerlink" title="图片缓存大小"></a>图片缓存大小</h2><p>现在很多图片库需要给图片设置一个最大缓存，但是这个值设置多少合适呢？<br>高端机和低端机的配置显然应该不同，可以考虑设置一个动态值。<br>建议设置为应用可用内存的1/8:</p>
<p><code>int memoryCache = (int) (Runtime.getRuntime().maxMemory() / 8);</code></p>
<h2 id="u7CFB_u7EDF_u5185_u7F6E_u7684_u4E00_u4E9B_u5DE5_u5177_u7C7B"><a href="#u7CFB_u7EDF_u5185_u7F6E_u7684_u4E00_u4E9B_u5DE5_u5177_u7C7B" class="headerlink" title="系统内置的一些工具类"></a>系统内置的一些工具类</h2><p>在AOSP源码全局搜了一下包含Util关键字的类，整理出这个列表供大家参考：</p>
<p><code>// 系统</code></p>
<p><code>./android/database/DatabaseUtils.java</code></p>
<p><code>./android/transition/TransitionUtils.java</code></p>
<p><code>./android/view/animation/AnimationUtils.java</code></p>
<p><code>./android/view/ViewAnimationUtils.java</code></p>
<p><code>./android/webkit/URLUtil.java</code></p>
<p><code>./android/bluetooth/le/BluetoothLeUtils.java</code></p>
<p><code>./android/gesture/GestureUtils.java</code></p>
<p><code>./android/text/TextUtils.java</code></p>
<p><code>./android/text/format/DateUtils.java</code></p>
<p><code>./android/os/FileUtils.java</code></p>
<p><code>./android/os/CommonTimeUtils.java</code></p>
<p><code>./android/net/NetworkUtils.java</code></p>
<p><code>./android/util/MathUtils.java</code></p>
<p><code>./android/util/TimeUtils.java</code></p>
<p><code>./android/util/ExceptionUtils.java</code></p>
<p><code>./android/util/DebugUtils.java</code></p>
<p><code>./android/drm/DrmUtils.java</code></p>
<p><code>./android/media/ThumbnailUtils.java</code></p>
<p><code>./android/media/ImageUtils.java</code></p>
<p><code>./android/media/Utils.java</code></p>
<p><code>./android/opengl/GLUtils.java</code></p>
<p><code>./android/opengl/ETC1Util.java</code></p>
<p><code>./android/telephony/PhoneNumberUtils.java</code></p>
<p><code>// 设计和支持库</code></p>
<p><code>./design/src/android/support/design/widget/ViewGroupUtils.java</code></p>
<p><code>./design/src/android/support/design/widget/ThemeUtils.java</code></p>
<p><code>./design/src/android/support/design/widget/ViewUtils.java</code></p>
<p><code>./design/lollipop/android/support/design/widget/ViewUtilsLollipop.java</code></p>
<p><code>./design/base/android/support/design/widget/AnimationUtils.java</code></p>
<p><code>./design/base/android/support/design/widget/MathUtils.java</code></p>
<p><code>./design/honeycomb/android/support/design/widget/ViewGroupUtilsHoneycomb.java</code></p>
<p><code>./v7/recyclerview/src/android/support/v7/widget/helper/ItemTouchUIUtil.java</code></p>
<p><code>./v7/recyclerview/src/android/support/v7/widget/helper/ItemTouchUIUtilImpl.java</code></p>
<p><code>./v7/recyclerview/src/android/support/v7/util/MessageThreadUtil.java</code></p>
<p><code>./v7/recyclerview/src/android/support/v7/util/AsyncListUtil.java</code></p>
<p><code>./v7/recyclerview/src/android/support/v7/util/ThreadUtil.java</code></p>
<p><code>./v7/recyclerview/tests/src/android/support/v7/widget/AsyncListUtilLayoutTest.java</code></p>
<p><code>./v7/recyclerview/tests/src/android/support/v7/util/AsyncListUtilTest.java</code></p>
<p><code>./v7/recyclerview/tests/src/android/support/v7/util/ThreadUtilTest.java</code></p>
<p><code>./v7/appcompat/src/android/support/v7/graphics/drawable/DrawableUtils.java</code></p>
<p><code>./v7/appcompat/src/android/support/v7/widget/DrawableUtils.java</code></p>
<p><code>./v7/appcompat/src/android/support/v7/widget/ThemeUtils.java</code></p>
<p><code>./v7/appcompat/src/android/support/v7/widget/ViewUtils.java</code></p>
<p><code>./v4/tests/java/android/support/v4/graphics/ColorUtilsTest.java</code></p>
<p><code>./v4/jellybean-mr1/android/support/v4/text/TextUtilsCompatJellybeanMr1.java</code></p>
<p><code>./v4/jellybean/android/support/v4/app/BundleUtil.java</code></p>
<p><code>./v4/jellybean/android/support/v4/app/NavUtilsJB.java</code></p>
<p><code>./v4/java/android/support/v4/app/NavUtils.java</code></p>
<p><code>./v4/java/android/support/v4/database/DatabaseUtilsCompat.java</code></p>
<p><code>./v4/java/android/support/v4/graphics/ColorUtils.java</code></p>
<p><code>./v4/java/android/support/v4/text/TextUtilsCompat.java</code></p>
<p><code>./v4/java/android/support/v4/util/TimeUtils.java</code></p>
<p><code>./v4/java/android/support/v4/util/DebugUtils.java</code></p>
<p><code>./v4/java/android/support/v4/content/res/TypedArrayUtils.java</code></p>
<p>这么多工具类，一定可以找到对你有用的。</p>
<h2 id="ClipPadding"><a href="#ClipPadding" class="headerlink" title="ClipPadding"></a>ClipPadding</h2><p>这个不多说，ListView的ClipPadding设为false，就能为ListView设置各种padding而不会出现丑陋的滑动“禁区”了。</p>
<h2 id="u5F3A_u5927_u7684dumpsys"><a href="#u5F3A_u5927_u7684dumpsys" class="headerlink" title="强大的dumpsys"></a>强大的dumpsys</h2><p>dumpsys可以查看系统服务和状态，非常强大，可通过如下查看所有支持的子命令：</p>
<p><code>dumpsys | grep ``&quot;DUMP OF SERVICE&quot;</code></p>
<p>这里列举几个稍微常用的：</p>
<p>子命令备注activity显示所有的activities的信息cpuinfo显示CPU信息window显示键盘，窗口和它们的关系meminfo内存信息（meminfo $package_name or $pid 使用包名或者进程id显示内存信息）alarm显示Alarm信息statusbar显示状态栏相关的信息（找出广告通知属于哪个应用）usagestats每个界面启动的时间</p>
<h2 id="bugreport_u547D_u4EE4"><a href="#bugreport_u547D_u4EE4" class="headerlink" title="bugreport命令"></a>bugreport命令</h2><p>很多人都用过adb logcat，但是如果想要更详细的信息，logcat则无能为力。<br>所以大多数手机厂商测试更多的是用adb bugreport来抓log给开发人员分析。</p>
<p><code>// 除了log，还包括启动后的系统状态,包括进程列表，内存信息，VM信息等等</code></p>
<p><code>// 而且不像logcat是一直打印的，bugreport命令输出到当前时间就停止结束了。</code></p>
<p><code>adb bugreport &gt; main.log</code></p>
<h2 id="dpi_u6587_u4EF6_u5939_u7684_u6362_u7B97_u6BD4_u4F8B"><a href="#dpi_u6587_u4EF6_u5939_u7684_u6362_u7B97_u6BD4_u4F8B" class="headerlink" title="dpi文件夹的换算比例"></a>dpi文件夹的换算比例</h2><p>之前的ldpi基本可以抛弃了，主流的dpi已经从很早之前的mdip转移到了xhdpi了，特别提醒。</p>
<p>PPIRESOLUTIONDPPXmdpi(160dp)320P11hdpi(240dp)480P11.5xhdpi(320dp)720P12xxhdpi(480dpi)1080P13</p>
<h2 id="u66F4_u65B0_u5A92_u4F53_u5E93_u6587_u4EF6"><a href="#u66F4_u65B0_u5A92_u4F53_u5E93_u6587_u4EF6" class="headerlink" title="更新媒体库文件"></a>更新媒体库文件</h2><p>以前做ROM的时候经常碰到一些第三方软件（某音乐APP）下载了新文件或删除文件之后，但是媒体库并没有更新，因为这个是需要第三方软件主动触发。</p>
<p><code>// 通知媒体库更新单个文件状态</code></p>
<p><code>Uri fileUri = Uri.fromFile(file);</code></p>
<p><code>sendBroadcast(``new</code> <code>Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE,fileUri));</code></p>
<p>媒体库会在手机启动，SD卡插拔的情况下进行全盘扫描，不是实时的而且代价比较大，所以单个文件的刷新很有必要。</p>
<h2 id="Monkey_u53C2_u6570"><a href="#Monkey_u53C2_u6570" class="headerlink" title="Monkey参数"></a>Monkey参数</h2><p>大家都知道，跑monkey的参数设置有一些要注意的地方，比如太快了不行不切实际，太慢了也不行等等，这里给出一个参考：</p>
<p><code>adb shell monkey -p &lt;packageName&gt; -s 1000 --ignore-crashes --ignore-timeouts --ignore-security-exceptions  --pct-trackball 0 --pct-nav 0 --pct-majornav 0 --pct-anyevent 0  -v --throttle 300 1200000000</code></p>
<p>一边跑monkey，一边抓log吧。</p>
<p>无论是大经验还是小经验，有用就是好经验。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文出处：<a href="http://jayfeng.com/2016/03/18/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84%E9%82%A3%E4%BA%9BAndroid%E5%B0%8F%E7%BB%8F%E9%AA%8C/">http://jayfeng.com/</a> </p>
<p>做Android久了，就会踩很多坑，被坑的多了就有经验了，闲暇之余整理了部分，现挑选一些重要或者偏门的“小”经验做个记录。</p>
<h2 id="u67E5_u770BSQLite_u65E5_u5FD7"><a href="#u67E5_u770BSQLite_u65E5_u5FD7" class="headerlink" title="查看SQLite日志"></a>查看SQLite日志</h2><p><code>adb shell setprop log.tag.SQLiteLog V</code></p>
<p><code>adb shell setprop log.tag.SQLiteStatements V</code></p>
<p>因为实现里用了Log.isLoggable(TAG, Log.VERBOSE)做了判断，LessCode的LogLess中也参考了这种机制：<a href="https://github.com/openproject/LessCode/blob/master/lesscode-core/src/main/java/com/jayfeng/lesscode/core/LogLess.java">LogLess</a>。<br>使用这种方法就可以在Release版本也能做到查看应用的打印日志了。</p>
<h2 id="PNG_u4F18_u5316"><a href="#PNG_u4F18_u5316" class="headerlink" title="PNG优化"></a>PNG优化</h2><p>APK打包会自动对PNG进行无损压缩，如果自行无损压缩是无效的。<br>当然进行有损压缩是可以的：<a href="https://tinypng.com/">https://tinypng.com/</a></p>
<h2 id="Tcpdump_u6293_u5305"><a href="#Tcpdump_u6293_u5305" class="headerlink" title="Tcpdump抓包"></a>Tcpdump抓包</h2>]]>
    
    </summary>
    
      <category term="知识库" scheme="http://apanda.club/tags/%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    
      <category term="技术" scheme="http://apanda.club/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android开发代码片段]]></title>
    <link href="http://apanda.club/2016/03/21/%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/android%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/"/>
    <id>http://apanda.club/2016/03/21/小知识点/android代码片段/</id>
    <published>2016-03-21T12:33:02.000Z</published>
    <updated>2016-04-06T04:04:15.000Z</updated>
    <content type="html"><![CDATA[<h3 id="1_u3001_u83B7_u53D6_u7535_u6E90_u9501"><a href="#1_u3001_u83B7_u53D6_u7535_u6E90_u9501" class="headerlink" title="1、获取电源锁"></a>1、获取电源锁</h3><pre><code>public static void acquireWakeLock() {
    unlockKeyBoard();
    try {
        if (null == mWakeLock) {
            PowerManager pm = (PowerManager) BaseApplication.getInstance()
                    .getSystemService(Context.POWER_SERVICE);
            try {
                mWakeLock = pm.newWakeLock(PowerManager.FULL_WAKE_LOCK
                        | PowerManager.ACQUIRE_CAUSES_WAKEUP
                        | PowerManager.ON_AFTER_RELEASE, &quot;PushMessageReceiver&quot;); // |
                                                                                    // PowerManager.ON_AFTER_RELEASE
            } catch (Exception e) {
                DbUtils.exceptionHandler(e);
            }
        }
        if (null != mWakeLock) {
            mWakeLock.acquire();
        }
    } catch (Exception e) {
        DbUtils.exceptionHandler(e);
    }
}
</code></pre><a id="more"></a>
<h3 id="2_u3001_u91CA_u653E_u8BBE_u5907_u7535_u6E90_u9501"><a href="#2_u3001_u91CA_u653E_u8BBE_u5907_u7535_u6E90_u9501" class="headerlink" title="2、释放设备电源锁"></a>2、释放设备电源锁</h3><pre><code>public static void releaseWakeLock() {
    try {
        if (null != mWakeLock) {
            mWakeLock.release();
            mWakeLock = null;
        }
    } catch (Exception e) {
        DbUtils.exceptionHandler(e);
    }
}
</code></pre><h3 id="3_u3001_u89E3_u9501_u952E_u76D8"><a href="#3_u3001_u89E3_u9501_u952E_u76D8" class="headerlink" title="3、解锁键盘"></a>3、解锁键盘</h3><pre><code>public static void unlockKeyBoard () {
    KeyguardManager km = (KeyguardManager)ApplicationContext.getInstance().getContext().getSystemService(Context.KEYGUARD_SERVICE);
    km.newKeyguardLock(&quot;Tag For Debug&quot;).disableKeyguard();
}
</code></pre><p>4、获取当前程序版本名</p>
<pre><code>/**  
* 返回当前程序版本名  
*/    
public static String getAppVersionName(Context context) {    
    String versionName = &quot;&quot;;    
    try {    
        // ---get the package info---    
        PackageManager pm = context.getPackageManager();    

        PackageInfo pi = pm.getPackageInfo(context.getPackageName(), 0);    
        versionName = pi.versionName;    //版本名称
        versioncode = pi.versionCode;  //版本号
        if (versionName == null || versionName.length() &lt;= 0) {    
            return &quot;&quot;;    
        }    
    } catch (Exception e) {    
        Log.e(&quot;VersionInfo&quot;, &quot;Exception&quot;, e);    
    }    
    return versionName;    
} 
</code></pre><h3 id="5_u3001_u83B7_u53D6_u5F53_u524D_u5E94_u7528_u7684_u7248_u672C_u53F7"><a href="#5_u3001_u83B7_u53D6_u5F53_u524D_u5E94_u7528_u7684_u7248_u672C_u53F7" class="headerlink" title="5、获取当前应用的版本号"></a>5、获取当前应用的版本号</h3><pre><code>public static String getVersionName() throws Exception  
{  
        // 获取packagemanager的实例  
        PackageManager packageManager = getPackageManager();  
        // getPackageName()是你当前类的包名，0代表是获取版本信息  
        PackageInfo packInfo = packageManager.getPackageInfo(getPackageName(),0);  
        String version = packInfo.versionName;  
        return version;  
}
</code></pre><h3 id="6_u3001_u83B7_u53D6_u5F53_u524D_u7CFB_u7EDF_u7684_u7248_u672C_u53F7"><a href="#6_u3001_u83B7_u53D6_u5F53_u524D_u7CFB_u7EDF_u7684_u7248_u672C_u53F7" class="headerlink" title="6、获取当前系统的版本号"></a>6、获取当前系统的版本号</h3><pre><code>/** 
 * 手机系统版本 
 */  
 public static String getSdkVersion() {  
     return android.os.Build.VERSION.RELEASE;  
 }  
</code></pre><h3 id="7_u3001_u5F53_u6211_u4EEC_u70B9_u51FB_u67D0_u4E2A_u8BDD_u9898_u7684_u9009_u9879_u5361_uFF0C_u4F1A_u5F39_u51FA_u4E00_u4E2Apopupwindow_uFF0C_u91CC_u9762_u6709_u8BF8_u5982__u8BC4_u8BBA_u3001_u56DE_u590D_u7684_u9009_u9879_uFF0C_u4F60_u70B9_u51FB_u8FD9_u4E2A_u9009_u9879_u7684_u65F6_u5019_uFF0C_u9700_u8981_u5B9A_u4F4D_u5230EditText_u7F16_u8F91_u6846_uFF0C_u5E76_u4E14_u81EA_u52A8_u5F39_u51FA_u8F93_u5165_u6CD5_u3002_u53EF_u4EE5_u8003_u8651_u5982_u4E0B_u65B9_u6CD5_uFF1A"><a href="#7_u3001_u5F53_u6211_u4EEC_u70B9_u51FB_u67D0_u4E2A_u8BDD_u9898_u7684_u9009_u9879_u5361_uFF0C_u4F1A_u5F39_u51FA_u4E00_u4E2Apopupwindow_uFF0C_u91CC_u9762_u6709_u8BF8_u5982__u8BC4_u8BBA_u3001_u56DE_u590D_u7684_u9009_u9879_uFF0C_u4F60_u70B9_u51FB_u8FD9_u4E2A_u9009_u9879_u7684_u65F6_u5019_uFF0C_u9700_u8981_u5B9A_u4F4D_u5230EditText_u7F16_u8F91_u6846_uFF0C_u5E76_u4E14_u81EA_u52A8_u5F39_u51FA_u8F93_u5165_u6CD5_u3002_u53EF_u4EE5_u8003_u8651_u5982_u4E0B_u65B9_u6CD5_uFF1A" class="headerlink" title="7、当我们点击某个话题的选项卡，会弹出一个popupwindow，里面有诸如 评论、回复的选项，你点击这个选项的时候，需要定位到EditText编辑框，并且自动弹出输入法。可以考虑如下方法："></a>7、当我们点击某个话题的选项卡，会弹出一个popupwindow，里面有诸如 评论、回复的选项，你点击这个选项的时候，需要定位到EditText编辑框，并且自动弹出输入法。可以考虑如下方法：</h3><pre><code>// 获取编辑框焦点
editText.setFocusable(true);
//打开软键盘
InputMethodManager imm = (InputMethodManager) ctx
.getSystemService(Context.INPUT_METHOD_SERVICE);
imm.toggleSoftInput(0, InputMethodManager.HIDE_NOT_ALWAYS);

//关闭软键盘
imm.hideSoftInputFromWindow(editText.getWindowToken(), 0);
</code></pre><h3 id="8_u3001EditText_u8F6F_u952E_u76D8"><a href="#8_u3001EditText_u8F6F_u952E_u76D8" class="headerlink" title="8、EditText软键盘"></a>8、EditText软键盘</h3><pre><code>//打开软键盘
et_feedback_content.setFocusable(true);
getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_VISIBLE);
//关闭软键盘
((InputMethodManager)getSystemService(Context.INPUT_METHOD_SERVICE)).hideSoftInputFromWindow(input.getWindowToken(), 0); 
</code></pre><h3 id="9_u3001_u8BBE_u7F6E_u5168_u5C4F_u7684Dialog"><a href="#9_u3001_u8BBE_u7F6E_u5168_u5C4F_u7684Dialog" class="headerlink" title="9、设置全屏的Dialog"></a>9、设置全屏的Dialog</h3><pre><code>//在代码里设置Dialog的Theme
Dialog dialog = new Dialog(this, R.style.Dialog_Fullscreen);  
dialog.setContentView(R.layout.main);  
dialog.show(); 

//设置style
 &lt;style name=&quot;Dialog_Fullscreen&quot;&gt; 
   &lt;item name=&quot;android:windowFullscreen&quot;&gt;true&lt;/item&gt; 
   &lt;item name=&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt;  
&lt;/style&gt;   
</code></pre><h3 id="10_u3001_u8BBE_u7F6E_u5168_u5C4F_u7684Dialog_uFF08_u4E8C_uFF09"><a href="#10_u3001_u8BBE_u7F6E_u5168_u5C4F_u7684Dialog_uFF08_u4E8C_uFF09" class="headerlink" title="10、设置全屏的Dialog（二）"></a>10、设置全屏的Dialog（二）</h3><p>我们也可以自定义Dialog，首先继承Dialig，然后再构造函数中添加</p>
<pre><code>super(context, android.R.style.Theme); 
setOwnerActivity((Activity)context);  
</code></pre><h3 id="11_u3001_u8BBE_u7F6E_u5168_u5C4FDialog_uFF08_u4E09_uFF09"><a href="#11_u3001_u8BBE_u7F6E_u5168_u5C4FDialog_uFF08_u4E09_uFF09" class="headerlink" title="11、设置全屏Dialog（三）"></a>11、设置全屏Dialog（三）</h3><p>首先介绍一个方法：getDecorView()</p>
<p>decorView是window中的最顶层view，可以从window中获取到decorView，然后decorView有个getWindowVisibleDisplayFrame方法可以获取到程序显示的区域，包括标题栏，但不包括状态栏。 于是，我们就可以算出状态栏的高度了。</p>
<pre><code>Rect frame = new Rect();
getWindow().getDecorView().getWindowVisibleDisplayFrame(frame);
int statusBarHeight = frame.top;
</code></pre><p>同样我们获取标题栏的高度</p>
<pre><code>getWindow().findViewById(Window.ID_ANDROID_CONTENT)这个方法获取到的view就是程序不包括标题栏的部分，然后就可以知道标题栏的高度了，代码如下：
int contentTop = getWindow().findViewById(Window.ID_ANDROID_CONTENT).getTop();         
int titleBarHeight = contentTop - statusBarHeight; //statusBarHeight是上面所求的状态栏的高度
</code></pre><p>最后：知道上述原理，我们就可以设置我们的Dialog和activity一样大了，Java代码如下：</p>
<pre><code>final Dialog dialog = new Dialog(WenDetailActivity.this, R.style.popupDialog);
        dialog.requestWindowFeature(Window.FEATURE_NO_TITLE);
        dialog.setContentView(R.layout.wen_cover_pager);
        dialog.setCanceledOnTouchOutside(false);
        dialog.setCancelable(false);
        WindowManager.LayoutParams lay = dialog.getWindow().getAttributes();
        DisplayMetrics dm = new DisplayMetrics();
        getWindowManager().getDefaultDisplay().getMetrics(dm);
        Rect rect = new Rect();
        View view = getWindow().getDecorView();//decorView是window中的最顶层view，可以从window中获取到decorView
        view.getWindowVisibleDisplayFrame(rect);
        lay.height = dm.heightPixels - rect.top;
        lay.width = dm.widthPixels;
</code></pre><p>style.xml如下：</p>
<pre><code>&lt;style name=&quot;popupDialog&quot; parent=&quot;@android:style/Theme.Dialog&quot;&gt;
        &lt;item name=&quot;android:windowBackground&quot;&gt;@drawable/filled_activity_bg&lt;/item&gt;
        &lt;item name=&quot;android:backgroundDimEnabled&quot;&gt;false&lt;/item&gt;
        &lt;item name=&quot;android:windowIsFloating&quot;&gt;true&lt;/item&gt;
        &lt;item name=&quot;android:windowIsTranslucent&quot;&gt;true&lt;/item&gt;
        &lt;item name=&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt;
        &lt;item name=&quot;android:windowContentOverlay&quot;&gt;@null&lt;/item&gt;
        &lt;!--&lt;item name=&quot;android:windowAnimationStyle&quot;&gt;@style/dialog_animation&lt;/item&gt;--&gt;
        &lt;item name=&quot;android:colorBackgroundCacheHint&quot;&gt;@null&lt;/item&gt;
        &lt;item name=&quot;android:backgroundDimAmount&quot;&gt;0.6&lt;/item&gt;&lt;!-- 灰度 --&gt;
        &lt;!--&lt;item name=&quot;android:windowFullscreen&quot;&gt;true&lt;/item&gt;--&gt;
 &lt;/style&gt;
</code></pre><h3 id="12_u3001_u5229_u7528_u4EE3_u7801_u6E05_u9664App_u7684_u6570_u636E"><a href="#12_u3001_u5229_u7528_u4EE3_u7801_u6E05_u9664App_u7684_u6570_u636E" class="headerlink" title="12、利用代码清除App的数据"></a>12、利用代码清除App的数据</h3><pre><code>/** 
* 利用代码清除App的数据 
* 平常我们在清除App的数据时,多半在设置中找到对应的App 
* 然后选择其清除数据.下面给出代码实现. 
*  
* 注意事项: 
* 1 设备需要root 
* 2 该示例中删除的是系统级应用 
* 2 注意在命令的末尾需要加上换行\n 
*   这就相当于我们平时在Dos中输入命令后再换行一样. 
*   否则命令不会被执行. 
*/  
private void cleanData(String packageName){  
    try {  
        Process su= Runtime.getRuntime().exec(&quot;su&quot;);  
        String cmd = &quot;cd /data/data/&quot;+packageName+&quot;;&quot;+&quot;rm -r `ls|grep -v lib`&quot;;  
        System.out.println(&quot;------cmd=&quot;+cmd);  
        cmd = cmd + &quot;\n exit\n&quot;;  
        su.getOutputStream().write(cmd.getBytes());  
        if ((su.waitFor() != 0)) {  
            throw new SecurityException();  
        }  
    } catch (Exception e) {  
        System.out.println(&quot;---&gt; 9527 清除数据时 e=&quot;+e.toString());  
    }  

} 
</code></pre><h3 id="13_u3001_u6E05_u9664_u5185/_u5916_u7F13_u5B58_uFF0C_u6E05_u9664_u6570_u636E_u5E93_uFF0C_u6E05_u9664sharedPreference_uFF0C_u6E05_u9664files_u548C_u6E05_u9664_u81EA_u5B9A_u4E49_u76EE_u5F55"><a href="#13_u3001_u6E05_u9664_u5185/_u5916_u7F13_u5B58_uFF0C_u6E05_u9664_u6570_u636E_u5E93_uFF0C_u6E05_u9664sharedPreference_uFF0C_u6E05_u9664files_u548C_u6E05_u9664_u81EA_u5B9A_u4E49_u76EE_u5F55" class="headerlink" title="13、清除内/外缓存，清除数据库，清除sharedPreference，清除files和清除自定义目录"></a>13、清除内/外缓存，清除数据库，清除sharedPreference，清除files和清除自定义目录</h3><pre><code>/** 文 件 名:  DataCleanManager.java  * 描    述:  主要功能有清除内/外缓存，清除数据库，清除sharedPreference，清除files和清除自定义目录  */
import java.io.File;
import android.content.Context;
import android.os.Environment;

/** * 本应用数据清除管理器 */
public class DataCleanManager {
/** * 清除本应用内部缓存(/data/data/com.xxx.xxx/cache) * * @param context */
public static void cleanInternalCache(Context context) {
    deleteFilesByDirectory(context.getCacheDir());
}

/** * 清除本应用所有数据库(/data/data/com.xxx.xxx/databases) * * @param context */
public static void cleanDatabases(Context context) {
    deleteFilesByDirectory(new File(&quot;/data/data/&quot;
            + context.getPackageName() + &quot;/databases&quot;));
}

/**
 * * 清除本应用SharedPreference(/data/data/com.xxx.xxx/shared_prefs) * * @param
 * context
 */
public static void cleanSharedPreference(Context context) {
    deleteFilesByDirectory(new File(&quot;/data/data/&quot;
            + context.getPackageName() + &quot;/shared_prefs&quot;));
}

/** * 按名字清除本应用数据库 * * @param context * @param dbName */
public static void cleanDatabaseByName(Context context, String dbName) {
    context.deleteDatabase(dbName);
}

/** * 清除/data/data/com.xxx.xxx/files下的内容 * * @param context */
public static void cleanFiles(Context context) {
    deleteFilesByDirectory(context.getFilesDir());
}

/**
 * * 清除外部cache下的内容(/mnt/sdcard/android/data/com.xxx.xxx/cache) * * @param
 * context
 */
public static void cleanExternalCache(Context context) {
    if (Environment.getExternalStorageState().equals(
            Environment.MEDIA_MOUNTED)) {
        deleteFilesByDirectory(context.getExternalCacheDir());
    }
}

/** * 清除自定义路径下的文件，使用需小心，请不要误删。而且只支持目录下的文件删除 * * @param filePath */
public static void cleanCustomCache(String filePath) {
    deleteFilesByDirectory(new File(filePath));
}

/** * 清除本应用所有的数据 * * @param context * @param filepath */
public static void cleanApplicationData(Context context, String... filepath) {
    cleanInternalCache(context);
    cleanExternalCache(context);
    cleanDatabases(context);
    cleanSharedPreference(context);
    cleanFiles(context);
    for (String filePath : filepath) {
        cleanCustomCache(filePath);
    }
}

/** * 删除方法 这里只会删除某个文件夹下的文件，如果传入的directory是个文件，将不做处理 * * @param directory */
private static void deleteFilesByDirectory(File directory) {
    if (directory != null &amp;&amp; directory.exists() &amp;&amp; directory.isDirectory()) {
        for (File item : directory.listFiles()) {
            item.delete();
        }
    }
}
}
</code></pre><h3 id="14_u3001Listview_u6D4B_u91CF_u9AD8_u5EA6__uFF08_u653E_u5728_u8BBE_u7F6E_u5B8C_u9002_u914D_u5668_u4E4B_u540E_u8FDB_u884C_u6D4B_u91CF_uFF0C_u653E_u5728_u4E4B_u524D_uFF0C_u6CA1_u6709_u6548_u679C_uFF09"><a href="#14_u3001Listview_u6D4B_u91CF_u9AD8_u5EA6__uFF08_u653E_u5728_u8BBE_u7F6E_u5B8C_u9002_u914D_u5668_u4E4B_u540E_u8FDB_u884C_u6D4B_u91CF_uFF0C_u653E_u5728_u4E4B_u524D_uFF0C_u6CA1_u6709_u6548_u679C_uFF09" class="headerlink" title="14、Listview测量高度 （放在设置完适配器之后进行测量，放在之前，没有效果）"></a>14、Listview测量高度 （放在设置完适配器之后进行测量，放在之前，没有效果）</h3><pre><code>/**
 * 设置高度
 */
 private void setHeight(ListView listView) {
     // 获取listView的适配器
     ListAdapter adapter = listView.getAdapter();
     // 获取视图的个数
     int count = adapter.getCount();
     // 总高度
     int totalHeight = 0;
     // 循环获取视图
     for (int i = 0; i &lt; count; i++) {
         // 通过i获取每个视图
         View view = adapter.getView(i, null, listView);
         // 重新测量view的高度
         view.measure(MeasureSpec.UNSPECIFIED, MeasureSpec.UNSPECIFIED);
         // 获取测量后的高度添加到总高度
         totalHeight += view.getMeasuredHeight();
     }
     // 总高度加上所有分割线的总高度
     totalHeight += listView.getDividerHeight() * (count - 1);
     // 获取listView的布局属性
     LayoutParams params = listView.getLayoutParams();
     // 设置高度
     params.height = totalHeight;
     // 重新设置布局属性
     listView.setLayoutParams(params);
 }
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1_u3001_u83B7_u53D6_u7535_u6E90_u9501"><a href="#1_u3001_u83B7_u53D6_u7535_u6E90_u9501" class="headerlink" title="1、获取电源锁"></a>1、获取电源锁</h3><pre><code>public static void acquireWakeLock() {
    unlockKeyBoard();
    try {
        if (null == mWakeLock) {
            PowerManager pm = (PowerManager) BaseApplication.getInstance()
                    .getSystemService(Context.POWER_SERVICE);
            try {
                mWakeLock = pm.newWakeLock(PowerManager.FULL_WAKE_LOCK
                        | PowerManager.ACQUIRE_CAUSES_WAKEUP
                        | PowerManager.ON_AFTER_RELEASE, &quot;PushMessageReceiver&quot;); // |
                                                                                    // PowerManager.ON_AFTER_RELEASE
            } catch (Exception e) {
                DbUtils.exceptionHandler(e);
            }
        }
        if (null != mWakeLock) {
            mWakeLock.acquire();
        }
    } catch (Exception e) {
        DbUtils.exceptionHandler(e);
    }
}
</code></pre>]]>
    
    </summary>
    
      <category term="写作" scheme="http://apanda.club/tags/%E5%86%99%E4%BD%9C/"/>
    
      <category term="技术" scheme="http://apanda.club/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android开发工作中的细节]]></title>
    <link href="http://apanda.club/2016/03/02/%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/Android%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C%E4%B8%AD%E7%9A%84%E7%BB%86%E8%8A%82/"/>
    <id>http://apanda.club/2016/03/02/小知识点/Android开发工作中的细节/</id>
    <published>2016-03-01T18:33:45.000Z</published>
    <updated>2016-04-05T06:44:02.000Z</updated>
    <content type="html"><![CDATA[<ol>
<li><p>全部 Activity 可继承自 BaseActivity，便于统一风格与处理公共事件，构建对话框统一构建器的建立，万一需要整体变动，一处修改到处有效。</p>
</li>
<li><p>数据库表段字段常量和 SQL 逻辑分离，更清晰，建议使用 Lite 系列框架 LiteOrm 库，超级清晰且重心可以放在业务上不用关心数据库细节。</p>
</li>
<li><p>全局变量放全局类中，模块私有放自己的管理类中，让常量清晰且集中.</p>
</li>
<li><p>不要相信庞大的管理类的东西会带来什么好处，可能是一场灾难，而要时刻注意单一职责原则，一个类专心做好一件事情更为清晰。</p>
<a id="more"></a></li>
<li><p>如果数据没有必要加载，数据请务必延迟初始化，谨记为用户节省内存，总不会有坏处。</p>
</li>
<li><p>异常抛出，在合适的位置处理或者集中处理，不要搞的到处是 catch，混乱且性能低，尽量不要在循环体中捕获异常，以提升性能。</p>
</li>
<li><p>地址引用链长时（3 个以上指向）小心内存泄漏，和警惕堆栈地址指向，典型的易发事件是：数据更新了，ListView 视图却没有刷新，这时 Adapter 很可能指向并的并不是你更新的数据容器地址（一般为 List）。</p>
</li>
<li><p>信息同步：不管是数据库还是网网络操作，新插入的数据注意返回 ID（如果没有赋予唯一 ID），否则相当于没有同步。</p>
</li>
<li><p>多线程操作数据库时，db 关闭了会报错，也很可能出现互锁的问题，推荐使用事务，推荐使用自动化的 LiteOrm 库操作。</p>
</li>
<li><p>做之前先考虑那些可以公用，资源，layout，类，做一个结构、架构分析以加快开发，提升代码可复用度。</p>
</li>
<li><p>有序队列操作 add、delete 操作时注意保持排序，否则你会比较难堪喔。</p>
</li>
<li><p>数据库删除数据时，要注意级联操作避免出现永远删不掉的脏数据喔。</p>
</li>
<li><p>关于形参实参：调用函数时参数为基本类型传的是值，即传值；参数为对象传递的是引用，即传址。</p>
</li>
<li><p>listview 在数据未满一屏时，setSelection 函数不起作用；ListView 批量操作时各子项和视图正确对应，可见即所选。</p>
</li>
</ol>
<p>15 控制 Activity 的代码量，保持主要逻辑清晰。其他类遵守 SRP（单一职能），ISP（接口隔离）原则。</p>
<ol>
<li><p>arraylist 执行 remove 时注意移除 int 和 Integer 的区别。你懂得。</p>
</li>
<li><p>Log 请打上 Tag，调试打印一定要做标记，能定位打印位置，否则尴尬是：不知道是哪里在打印。</p>
</li>
<li><p>码块/常量/资源可以集中公用的一定共用，即使共用逻辑稍复杂一点也会值得，修改起来很轻松，修改一种，到处有效。</p>
</li>
<li><p>setSelection 不起作用，尝试 smoothScrollToPosition。ListView 的 LastVisiblePosition（最后一个可见子项）会随着 getView 方法执行位置不同变动而变。</p>
</li>
<li><p>与 Activity 通讯使用 Handler 更方便； 如果你的框架回调链变长，考虑监听者模式简化回调。</p>
</li>
<li><p>监听者模式不方便使用时，推荐 EventBus 框架库，使用时间总线，没接触过的同学可以自行脑补一下哦。</p>
</li>
<li><p>Handler 在子线程线程使用 Looper.prepare，或者 new 的时候给构造函数传入 MainLooper 来确保在主线程 run。</p>
</li>
<li><p>timepicker 点击确定后需要 clearFocus 才能获取手动输入的时间。</p>
</li>
<li><p>构造函数里面极度不推荐启动异步线程，会埋下隐患。比如：异步线程调用了本例的示例，就会悲剧等着崩溃吧。</p>
</li>
<li><p>千万不要理所当然的以为一个对象不会为空，充分的做好容错处理；另外注意 null 也可以插入 ArrayList 等容器中。</p>
</li>
<li><p>ExpandableListView 的子列表不能点击（禁用）要把 Adapter 的 isChildSelectable 方法返回 true。</p>
</li>
<li><p>UI 显示注意内容过长的情形要提前使用 ScrollView 否则在小手机上尴尬你懂得。</p>
</li>
<li><p>注意按钮的感应范围不小于 9mm 否则不易点击；输入框注意光标的位置更易用户输入。</p>
</li>
<li><p>服务器和客户端尽量统一唯一标识（有可能是 ID），否则多少会有歧义和问题。</p>
</li>
<li><p>注释，尽量去写足够的注释，去描述一下思路，达到看了可以明白某一块代码的效果。</p>
</li>
<li><p>完整型数据一定要用 Sqlite 的 Transaction，大数据一定要用。粗略测试插入 100 个数据有 20 倍的提速，插入 1000 个数据就有 100 多倍的提速。</p>
</li>
<li><p>避免 String=”null”的情况出现 String = null,=””都可以。避免出现 title=”无主题”这样的数据提交到数据库浪费空间。</p>
</li>
<li><p>存在多个不同的 dbhelper 实例情况下，sqlitedatabase 对象必然存在不同的实例，多线程同时写入数据，轮流写入数据时会不定时的报 db is locked，引起崩溃，不管是操作同张表还是异表。读和写可以同时并发，轮流无规律的交替执行。同时写入数据时解决方案是用并发的每个线程都用事 务，db 则不会 lock，按次整体写入。</p>
</li>
<li><p>建议整个应用维护一个 dbhelper 实例，只要 db 没有关闭，全局就只有一个 db 实例，多线程并发写入 db 不会 lock，严格交替进行写入：123123123。。。（123 代表不同线程，轮流插入一个记录），读和写均不会锁住 db，读写交替并没有规律，执行次数和程度看 cpu 分配给哪个线程的时间片长。</p>
</li>
<li><p>一个任务使用事务嵌套N个事务，N个事务中有一个失败，这个任务整体失败，全部成功后，数据才写入，具有安全性，整体性。并且事务写入大批量数据的效率经 实际测试成百上千倍的高于一般的单个写入。数据库大量数据、多线程操作建议使用 LiteOrm 数据库框架，更稳定简单。</p>
</li>
<li><p>经常需要用 ListView 或者其它显示大量 Items 的控件实时跟踪或者查看信息，并且希望最新的条目可以自动滚动到可视范围内。通过设置的控件 transcriptMode 属性可以将 Android 平台的控件（支持 ScrollBar）自动滑动到最底部。</p>
</li>
<li><p>Long a; 判断a有没有赋值，if (a == 0) 在a没有赋值情况下会报错。应该 if (a == null)，Integer、Floag 等也一样，原因你懂，只是提醒你要小心喔。</p>
</li>
<li><p>编码遇到读写、出入等逻辑要双向考虑，文件导入导出，字符字节相互转换都要两边转码。</p>
</li>
<li><p>一个 int 值与一个 Integer 对象（能包含 int 值的最小对象）的大小比率约为 1:4（32 位和 64 位机器有不同）。额外的开销源于 JVM 用于描述 Java 对象的元数据也就是 Integer，（Long、Double 等也是）。</p>
</li>
<li><p>对象由元数据和数据组成。元数据包括类（指向类的指针，描述了类的类型），标记（描述了对象状态，如散列码、形状等），锁（对象同步信息）。数组对象还包括大小的元数据。</p>
</li>
<li><p>一个在 32 位 Java 运行时中使用 1GB  Java 堆的 Java 应用程序在迁移到 64 位 Java 运行时之后，通常需要使用 1.7GB 的 Java 堆。</p>
</li>
<li><p>Hash 集合的访问性能比任何 List 的性能都要高，但每条目的成本也要更高。由于访问性能方面的原因，如果您正在创建大集合（例如，用于实现缓存），那么最好使用基于 Hash 的集合，而不必考虑额外的开销。</p>
</li>
<li><p>对于并不那么注重访问性能的较小集合而言，List 则是合理的选择。ArrayList 和 LinkedList 集合的性能大体相同，但其内存占用完全不同：ArrayList 的每条目大小要比 LinkedList 小得多，但它不是准确设置大小的。List 要使用的正确实现是 ArrayList 还是 LinkedList 取决于 List 长度的可预测性。如果长度未知，那么正确的选择可能是 LinkedList，因为集合包含的空白空间更少。如果大小已知或可预知或比较小，那么 ArrayList 的内存开销会更低一些。</p>
</li>
<li><p>选择正确的集合类型使你能够在集合性能与内存占用之间达到合理的平衡。除此之外，你可以通过正确调整集合大小来最大化填充率、最小化未得到利用的空间，从而最大限度地减少内存占用。</p>
</li>
<li><p>充分利用封装（提供接口类来控制访问数据）和委托（helper 对象来实施任务）两种理念。</p>
</li>
<li><p>延迟分配 Hashtable：如果 Hashtable 为空是经常发生的普遍现象，那么仅在存在需要存储的数据时分配 Hashtable 应该是一种合理的做法。将 Hashtable 分配为准确的大小：虽然会有默认大小，但建议使用更为准确的初始大小。</p>
</li>
<li><p>EditText 在 setText 时不要忘记是否需要 setSelection。在大多数情况下是需要设置的。</p>
</li>
<li><p>XML 两种情况要注意：1 属性名字时候有重复；2 注意文本是否包含非法字符，注意使用 CDATA 包裹。</p>
</li>
<li><p>当逻辑没有明显问题时考虑对象属性、函数参数、网络传输参数是否全部了解，是否设置正确。</p>
</li>
<li><p>当出现编译或者运行时错误，别人那没问题时，考虑你的编译环境和环境版本是否有问题。</p>
</li>
<li><p>由于 String 类的 immutable 性质，当 String 变量需要经常变换其值时，应该考虑使用 StringBuilder 提升性能，多线程使用 StringBuffer 操作 string 提高程序效率。</p>
</li>
<li><p>java 栈的优势是比堆速度快，可共享，主要存放临时变量、参数等，堆的优势是可动态分配内存大小。</p>
</li>
<li><p>只要是用 new ()来新建对象的，都会在堆中创建，而且其数据是单独存值的，即使与栈中的数据（值）相同，也不会与栈中的数据共享。</p>
</li>
<li><p>基本数据类型定义的变量称自动变量，存的是‘字面值’，存在于栈中，可共享（存在即不新建）。</p>
</li>
<li><p>多个 RandomAccessFile 对象指向同一个文件，可使用多个线程一起写入无需再自己加锁，经试验结论：三个线程分别写入 100 万次数据，使用锁约 12 秒，不使用约 8.5 秒。100 个线程分别写入 1 万次数据使用锁耗时约 4.2 秒，不使用锁耗时约 3 秒。</p>
</li>
<li><p>XmlPullParser 解析慎用 nextText ()方法，xml 比较复杂，含有空标签、重复名字标签时容易出现异常问题；TEXT 中使用 getText ()方法代替 START_TAG 中使用 nextText ()方法；START_TAG，TEXT，END_TAG 三个事件配合使用。注意每个 xml 节点之间（不管是开始节点还是结束节点）都会出现 TEXT 事件。</p>
</li>
<li><p>改变逻辑的时候考虑全部用到这项功能的地方，分散的地方多了，容易大意。</p>
</li>
<li><p>当系统原生组件出现问题时，查看错误栈信息，自己写一个该组件的子类，并在合适的地方将出错方法复写一下，加上 try catch 保证不崩溃掉。不要扰乱了该系统控件的正常逻辑。</p>
</li>
<li><p>输入控件注意对空格、换行等符号的控制；输入框里内容注意和左右控件的空间，防止误点击。</p>
</li>
<li><p>注意函数参数里的++或者–操作。是++c 还是 c++，区别很大。</p>
</li>
<li><p>各种地方、永远的不要小看 null 指针问题，甚至有些场合宁可错杀（try catch），不可放过。</p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<ol>
<li><p>全部 Activity 可继承自 BaseActivity，便于统一风格与处理公共事件，构建对话框统一构建器的建立，万一需要整体变动，一处修改到处有效。</p>
</li>
<li><p>数据库表段字段常量和 SQL 逻辑分离，更清晰，建议使用 Lite 系列框架 LiteOrm 库，超级清晰且重心可以放在业务上不用关心数据库细节。</p>
</li>
<li><p>全局变量放全局类中，模块私有放自己的管理类中，让常量清晰且集中.</p>
</li>
<li><p>不要相信庞大的管理类的东西会带来什么好处，可能是一场灾难，而要时刻注意单一职责原则，一个类专心做好一件事情更为清晰。</p>]]>
    
    </summary>
    
      <category term="知识库" scheme="http://apanda.club/tags/%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    
      <category term="技术" scheme="http://apanda.club/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[日常使用到的梯子]]></title>
    <link href="http://apanda.club/2016/03/01/%E9%9A%8F%E7%AC%94/%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E5%88%B0%E7%9A%84%E6%A2%AF%E5%AD%90/"/>
    <id>http://apanda.club/2016/03/01/随笔/日常使用到的梯子/</id>
    <published>2016-03-01T04:33:45.000Z</published>
    <updated>2016-04-05T08:47:20.000Z</updated>
    <content type="html"><![CDATA[<p>日常生活中,由于天朝的局域网的限制,很多网站都无法进行使用,虽然国内也有替代的网站,但是作为开发人员来讲,这些事远远不够的,现在就讲我个人在生活工作中使用到梯子,进行总结一下</p>
<h2 id="PC_u7AEF"><a href="#PC_u7AEF" class="headerlink" title="PC端"></a>PC端</h2><p>##全局梯子<br>目前在PC上(window)使用到的全局的梯子 就是 赛风和VPN Gate</p>
<h3 id="u8D5B_u98CE"><a href="#u8D5B_u98CE" class="headerlink" title="赛风"></a>赛风</h3><p>如果能够直接访问 <a herf="http://www.psiphon3.net/zh/index.html"> 直达</a></p>
<h4 id="u7B80_u5355_u4ECB_u7ECD"><a href="#u7B80_u5355_u4ECB_u7ECD" class="headerlink" title="简单介绍"></a>简单介绍</h4><p>赛风是赛风公司的一款新翻墙工具，利用VPN, SSH和HTTP代理软件提供未经审查的访问互联网。赛风的客户端将自动寻找新的接入点，力求最大限度的绕过网络审查。<br><a id="more"></a><br>赛风旨在为您提供在线内容的开放访问。赛风不会增加暴露您的在线隐私，也不应被用作是在线安全工具。</p>
<p><a herf="https://github.com/Psiphon-Labs">源码地址</a></p>
<h3 id="VPN_Gate"><a href="#VPN_Gate" class="headerlink" title="VPN Gate"></a>VPN Gate</h3><h4 id="u7EFC_u8FF0"><a href="#u7EFC_u8FF0" class="headerlink" title="综述"></a>综述</h4><p>VPN Gate 学术实验项目是一个在线服务，由日本国立筑波大学研究生院为学术研究目的运营。本研究的目的是推广 “全球分布式公共 VPN 中继服务器” 的知识。</p>
<h4 id="u4EAE_u70B9"><a href="#u4EAE_u70B9" class="headerlink" title="亮点"></a>亮点</h4><p>VPN 可以绕过防火墙。VPN 可以隐藏你的真实 IP 地址。VPN 可以防止在本地网络上的窃听</p>
<h4 id="u4F7F_u7528"><a href="#u4F7F_u7528" class="headerlink" title="使用"></a>使用</h4><p>这里提供一个<a herf="http://39.118.148.162:33281/cn/">daily链接</a>,不能保证能否使用,如果不能使用,自己又搜索不到,可以邮件给我</p>
<p>##浏览器梯子 </p>
<h3 id="Lantern"><a href="#Lantern" class="headerlink" title="Lantern"></a>Lantern</h3><p>自己用的 最出名的就是<a href="https://getlantern.org/" target="_blank" rel="external">Lantern</a>,配合Chrome使用,安装完成,打开lantern即可访问Google<br><a herf="https://github.com/getlantern">源码地址</a></p>
<h3 id="u4E09_u65B9_u5C01_u88C5_u7684"><a href="#u4E09_u65B9_u5C01_u88C5_u7684" class="headerlink" title="三方封装的"></a>三方封装的</h3><p><a href="http://www.ccav1.me/chromegae.html" target="_blank" rel="external">ChromeGAE</a></p>
<h4 id="u4ECB_u7ECD"><a href="#u4ECB_u7ECD" class="headerlink" title="介绍"></a>介绍</h4><p>ChromeGAE 是基于 Google Chrome 制作的免费浏览器。</p>
<p>集成多个实用的扩展，可以过滤 视频广告、网页广告 等等。</p>
<p>内置科学上网工具，可畅游 Youtube Facebook Twitter 等网站！</p>
<h2 id="u624B_u673A_u68AF_u5B50"><a href="#u624B_u673A_u68AF_u5B50" class="headerlink" title="手机梯子"></a>手机梯子</h2><p>赛风 lantern</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>日常生活中,由于天朝的局域网的限制,很多网站都无法进行使用,虽然国内也有替代的网站,但是作为开发人员来讲,这些事远远不够的,现在就讲我个人在生活工作中使用到梯子,进行总结一下</p>
<h2 id="PC_u7AEF"><a href="#PC_u7AEF" class="headerlink" title="PC端"></a>PC端</h2><p>##全局梯子<br>目前在PC上(window)使用到的全局的梯子 就是 赛风和VPN Gate</p>
<h3 id="u8D5B_u98CE"><a href="#u8D5B_u98CE" class="headerlink" title="赛风"></a>赛风</h3><p>如果能够直接访问 <a herf="http://www.psiphon3.net/zh/index.html"> 直达</a></p>
<h4 id="u7B80_u5355_u4ECB_u7ECD"><a href="#u7B80_u5355_u4ECB_u7ECD" class="headerlink" title="简单介绍"></a>简单介绍</h4><p>赛风是赛风公司的一款新翻墙工具，利用VPN, SSH和HTTP代理软件提供未经审查的访问互联网。赛风的客户端将自动寻找新的接入点，力求最大限度的绕过网络审查。<br>]]>
    
    </summary>
    
      <category term="VPN" scheme="http://apanda.club/tags/VPN/"/>
    
      <category term="随笔" scheme="http://apanda.club/categories/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android小知识库]]></title>
    <link href="http://apanda.club/2016/03/01/%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/Android%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"/>
    <id>http://apanda.club/2016/03/01/小知识点/Android开发中的小知识点汇总/</id>
    <published>2016-02-29T18:33:45.000Z</published>
    <updated>2016-04-07T03:26:16.000Z</updated>
    <content type="html"><![CDATA[<p>这份是我工作以来，总结的小知识库，有些知识点现在看来太LOW了，把还觉得有用的分享出来！</p>
<h3 id="Genymotion_u4E0B_u8F7D_u865A_u62DF_u955C_u50CFConnection_timeout"><a href="#Genymotion_u4E0B_u8F7D_u865A_u62DF_u955C_u50CFConnection_timeout" class="headerlink" title="Genymotion下载虚拟镜像Connection timeout"></a>Genymotion下载虚拟镜像Connection timeout</h3><p>Add new device出现的问题：</p>
<p>Failed to deploy virtual device.<br>Unable to create virtual device.Connection timeout occurred.</p>
<p>解决方案：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#24403;&#36873;&#25321;Google Nexus 5 - 6.0.0 - API 23 - 1080x1920&#19979;&#36733;device&#22833;&#36133;&#21518;&#65292;&#21040;C:\Users\&#29992;&#25143;&#20027;&#30446;&#24405;\AppData\Local\Genymobile\Genymotion\ova&#19979;&#30475;&#21040;genymotion_vbox86p_6.0_160114_090449.ova&#65292;&#22823;&#23567;&#21364;&#26159;0KB&#65292;&#22312;C:\Users\&#29992;&#25143;&#20027;&#30446;&#24405;\AppData\Local\Genymobile\genymotion.log&#65292;&#25171;&#24320;&#35813;&#25991;&#20214;&#65292;&#25214;&#21040;&#31867;&#20284;&#10;    &#10;    &#8220;http://files2.genymotion.com/dists/6.0.0/ova/genymotion_vbox86p_6.0_160114_090449.ova&#8221;&#36335;&#24452;&#65292;&#21363;&#24744;&#24819;&#35201;&#19979;&#36733;&#30340;&#38236;&#20687;&#25991;&#20214;URL&#65307;`&#10;&#10;&#29992;&#36805;&#38647;&#21435;&#19979;&#36733;&#65292;&#19979;&#36733;&#23436;&#25104;&#21518;&#25918;&#21040;C:\Users\&#29992;&#25143;&#20027;&#30446;&#24405;\AppData\Local\Genymobile\Genymotion\ova&#65307;&#10;&#37325;&#26032;&#28857;&#20987;Google Nexus 5 - 6.0.0 - API 23 - 1080x1920&#21435;&#19979;&#36733;&#65292;&#39564;&#35777;&#23433;&#35013;&#21518;&#21363;&#20250;&#26174;&#31034;&#22312;&#35774;&#22791;&#21015;&#34920;&#20013;&#12290;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h3 id="Android_Studio__u5982_u4F55Debug"><a href="#Android_Studio__u5982_u4F55Debug" class="headerlink" title="Android Studio 如何Debug"></a>Android Studio 如何Debug</h3><p>单击F5(Step Over)，单行一个个方法执行<br>单击F6(Step Into)，单行执行<br>单击F7(Step Out)，不往下执行，回到上一行<br>单击F8(Resume Program)，跳出当前断点</p>
<h3 id="Android_Studio_u8BBE_u7F6E_u9ED8_u8BA4_u7684_u7B7E_u540D_u6587_u4EF6"><a href="#Android_Studio_u8BBE_u7F6E_u9ED8_u8BA4_u7684_u7B7E_u540D_u6587_u4EF6" class="headerlink" title="Android Studio设置默认的签名文件"></a>Android Studio设置默认的签名文件</h3><p>新浪微博SSO登录，微信分享这些都需要签名打包，才能看到效果，设置默认签名文件为自己的签名jks，这样就不需要打包了。<br>在app目录下添加你的.jks，然后app的build.gradle文件中的增加以下内容：<br>第一种：</p>
<pre><code>android {  
    signingConfigs {  
        debug {  
            storeFile file(&quot;你的.jks&quot;)
            storePassword &apos;android&apos;
            keyAlias &apos;android&apos;
            keyPassword &apos;android&apos;
        }          
    }      
}
</code></pre><p>第二种：</p>
<pre><code>android {  
    signingConfigs {  
        release {  
            storeFile file(&quot;你的.jks&quot;)
            storePassword &apos;android&apos;
            keyAlias &apos;android&apos;
            keyPassword &apos;android&apos;
        }          
    }  
    buildTypes {
        debug {
            signingConfig signingConfigs.release
        }        
    }
}
</code></pre><p>这样编译出来的debug版本直接用的是你的正式签名</p>
<h3 id="Fragment_u61D2_u52A0_u8F7D"><a href="#Fragment_u61D2_u52A0_u8F7D" class="headerlink" title="Fragment懒加载"></a>Fragment懒加载</h3><pre><code>protected boolean isVisible;

@Override
public void setUserVisibleHint(boolean isVisibleToUser) {
    super.setUserVisibleHint(isVisibleToUser);
    if (getUserVisibleHint()) {
        isVisible = true;
        onVisible();
    } else {
        isVisible = false;
        onInvisible();
    }
}

protected void onVisible() {
    lazyLoad();
}

protected void lazyLoad() {
    if (!isVisible) {
        return;
    }
    getData();
}

protected void onInvisible() {
}
</code></pre><h3 id="Android_studio_u5934_u6CE8_u91CA_u548C_u65B9_u6CD5_u6CE8_u91CA"><a href="#Android_studio_u5934_u6CE8_u91CA_u548C_u65B9_u6CD5_u6CE8_u91CA" class="headerlink" title="Android studio头注释和方法注释"></a>Android studio头注释和方法注释</h3><blockquote>
<p>File | Settings | Editor|File and Code Templates|Includes|File Header</p>
</blockquote>
<pre><code>/**
* Created by ${USER} on ${DATE}.
*/
</code></pre><p>输入我们想要设置的注释模板</p>
<pre><code>adapter.getPositionForSelection()和getSectionForPosition()
getPositionForSection()根据分类列的索引号获得该序列的首个位置
getSectionForPosition()通过该项的位置，获得所在分类组的索引号

getResources().getColor(R.color.color_name) is deprecated和drawableTop

textView.setTextColor(Color.parseColor(&quot;#FFFFFF&quot;));
//或者
ContextCompat.getColor(context, R.color.color_name)

private void showPopupMenu(View v) {
    final View bgView = View.inflate(DemoApplication.getContext(), R.layout.demo_popup_window_bg, null);
    bgView.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            hidePopupWindow();
        }
    });
    if (mPopupBackground == null) {
        mPopupBackground = new PopupWindow(bgView, ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);
    }
    mPopupBackground.showAtLocation(v, Gravity.BOTTOM, 0, 0);
}
</code></pre><p>v：父布局<br>    demo_popup_window_bg.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:background=&quot;@color/aliwx_common_alpha_black&quot;&gt;

&lt;/LinearLayout&gt;
</code></pre><h3 id="onFinishInflate_28_29"><a href="#onFinishInflate_28_29" class="headerlink" title="onFinishInflate()"></a>onFinishInflate()</h3><p>view的onFinishInflate()何时调用的？</p>
<p>当View中所有的子控件均被映射成xml后触发；</p>
<pre><code>MyView mv = (MyView)View.inflate (context,R.layout.my_view,null);
</code></pre><p>当加载完成xml后，就会执行那个方法；</p>
<p>我们一般使用View的流程是在onCreate中使用setContentView来设置要显示Layout文件或直接创建一个View，在当设置了ContentView之后系统会对这个View进行解析，然后回调当前视图View中的onFinishInflate方法。只有解析了这个View我们才能在这个View容器中获取到拥有Id的组件，同样因为系统解析完View之后才会调用onFinishInflate方法，所以我们自定义组件时可以onFinishInflate方法中获取指定子View的引用。</p>
<h3 id="Fragment_u8BBE_u7F6E_u9690_u85CF_u6216_u663E_u793A_u67D0_u4E2AFragment"><a href="#Fragment_u8BBE_u7F6E_u9690_u85CF_u6216_u663E_u793A_u67D0_u4E2AFragment" class="headerlink" title="Fragment设置隐藏或显示某个Fragment"></a>Fragment设置隐藏或显示某个Fragment</h3><h4 id="MainFragment_u70B9_u51FB"><a href="#MainFragment_u70B9_u51FB" class="headerlink" title="MainFragment点击"></a>MainFragment点击</h4><pre><code>public void onItemClick(AdapterView&lt;?&gt; adapterView, View view,
                            int position, long id) {

        ((MainActivity) getActivity()).showImageFragment(true, mData.get(position).get(&quot;title&quot;).toString(), mData.get(position).get(&quot;imgUrl&quot;).toString());

    }
</code></pre><h4 id="MainActivity"><a href="#MainActivity" class="headerlink" title="MainActivity"></a>MainActivity</h4><pre><code>public void showImageFragment(boolean show, String imgTxt, String imgUrl) {
        // showActionbarWithTabs(!show);
        if (show) {
            getSupportFragmentManager().beginTransaction()
                    .show(imageDetailFragment).commit();
            imageDetailFragment.setImgData(imgTxt, imgUrl);
        } else {
            getSupportFragmentManager().beginTransaction()
                    .hide(imageDetailFragment).commit();
        }

    }
</code></pre><h3 id="u83B7_u53D6arrt_u7684_u503C"><a href="#u83B7_u53D6arrt_u7684_u503C" class="headerlink" title="获取arrt的值"></a>获取arrt的值</h3><p>不同主题下需要把颜色，数值写成attr属性<br>xml里，我们可以简单的引用attr属性值</p>
<pre><code>android:background=&quot;?attr/colorPrimary&quot;
</code></pre><h4 id="u4EE3_u7801_u83B7_u53D6"><a href="#u4EE3_u7801_u83B7_u53D6" class="headerlink" title="代码获取"></a>代码获取</h4><pre><code>TypedValue typedValue = new TypedValue();
mContext.getTheme().resolveAttribute(R.attr.colorPrimary, typedValue, true);
int colorPrimary = typedValue.data;//value.data里面存储着的就是获取到的colorPrimary的值
</code></pre><h3 id="u62E8_u53F7_u76D8_u62E8_u6253_u7535_u8BDD"><a href="#u62E8_u53F7_u76D8_u62E8_u6253_u7535_u8BDD" class="headerlink" title="拨号盘拨打电话"></a>拨号盘拨打电话</h3><pre><code>Intent intent = new Intent(Intent.ACTION_CALL,
Uri.parse(&quot;tel:&quot; + &quot;400-036-1977&quot;));
// intent.setAction(Intent.ACTION_CALL);// 直接拨号
intent.setAction(Intent.ACTION_DIAL);// 拨号盘
startActivity(intent);
</code></pre><h3 id="Drawable_/Bitmap_u3001String/InputStream_u3001Bitmap/byte_5B_5D_u4E92_u8F6C"><a href="#Drawable_/Bitmap_u3001String/InputStream_u3001Bitmap/byte_5B_5D_u4E92_u8F6C" class="headerlink" title="Drawable /Bitmap、String/InputStream、Bitmap/byte[]互转"></a>Drawable /Bitmap、String/InputStream、Bitmap/byte[]互转</h3><pre><code>http://wuxiaolong.me/2015/08/10/Drawable-to-Bitmap/
</code></pre><h3 id="ProgressDialog"><a href="#ProgressDialog" class="headerlink" title="ProgressDialog"></a>ProgressDialog</h3><pre><code>final ProgressDialog progress = new ProgressDialog(LoginActivity.this);
        progress.setMessage(&quot;请稍等...&quot;);
        progress.setCanceledOnTouchOutside(false);
        progress.show();
progress.dismiss();
</code></pre><h3 id="u6BEB_u79D2"><a href="#u6BEB_u79D2" class="headerlink" title="毫秒"></a>毫秒</h3><p>毫秒Calendar.getInstance().getTimeInMillis()和System.currentTimeMillis()</p>
<h3 id="Fragment_setUserVisibleHint_28boolean_isVisibleToUser_29"><a href="#Fragment_setUserVisibleHint_28boolean_isVisibleToUser_29" class="headerlink" title="Fragment setUserVisibleHint(boolean isVisibleToUser)"></a>Fragment setUserVisibleHint(boolean isVisibleToUser)</h3><pre><code>@Override
public void setUserVisibleHint(boolean isVisibleToUser) {
    super.setUserVisibleHint(isVisibleToUser);
    if (isVisibleToUser) {
        //相当于Fragment的onResume
    } else {
        //相当于Fragment的onPause
    }
}
</code></pre><h3 id="Fragment_onActivityResult"><a href="#Fragment_onActivityResult" class="headerlink" title="Fragment onActivityResult"></a>Fragment onActivityResult</h3><pre><code>public void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        getActivity();
        if (resultCode == Activity.RESULT_OK
                &amp;&amp; requestCode == AppUtils.REQUEST_CODE_ISLOGIN) {
            // 检查是否完善资料

            if (AppUtils.getSharedPreferences(getActivity()).getBoolean(
                    &quot;hasPersonalData&quot;, false)) {
                // 取本地存取是否完善资料,完善直接提示咨询对话框
                consultationDialog();
            } else {
                getCheckPersonalData();
            }

        }
    } 

startActivityForResult(intent,AppConfig.REQUEST_CODE_DIALOGUE);// 不是调用 getActivity().startActivityForResult()。
</code></pre><h3 id="dimen_u4EE3_u7801_u53D6_u503C"><a href="#dimen_u4EE3_u7801_u53D6_u503C" class="headerlink" title="dimen代码取值"></a>dimen代码取值</h3><p>getDimension方法获取到资源文件中定义的dimension值。</p>
<pre><code>Resources res = getResources();
float fontSize = res.getDimension(R.dimen.font_size);
</code></pre><h3 id="u6570_u7EC4_u521D_u59CB_u5316_u8D4B_u503C"><a href="#u6570_u7EC4_u521D_u59CB_u5316_u8D4B_u503C" class="headerlink" title="数组初始化赋值"></a>数组初始化赋值</h3><p>1、创建数组后，通过循环对数组赋值。<br>例如代码：</p>
<pre><code>int [] nums = new int [100];
for(int i=0;i&lt;10;i++){
nums[i] = i;
}
</code></pre><p>2、例如代码：</p>
<pre><code>int [] nums = {0,1,2,3,4,5,6,7,8,9};
</code></pre><p>3、</p>
<pre><code>int [] nums = new int[]{0,1,2,3,4,5,6,7,8,9};
</code></pre><h3 id="Fragment-isAdded_28_29"><a href="#Fragment-isAdded_28_29" class="headerlink" title="Fragment.isAdded()"></a>Fragment.isAdded()</h3><pre><code>Fragment mBeforeFragment = new Fragment();
public void switchFragment(Fragment currentFragment) {
if (currentFragment.isAdded()) {
getSupportFragmentManager().beginTransaction().hide(mBeforeFragment).show(currentFragment).commit();
} else {
getSupportFragmentManager().beginTransaction().hide(mBeforeFragment).add(R.id.container, currentFragment).commit();
}
mBeforeFragment = currentFragment;
}
</code></pre><p>调用：</p>
<pre><code>switchFragment(HomeFragment.newInstance());
HomeFragment


public static HomeFragment homeFragment = null;

public static HomeFragment newInstance() {
if (homeFragment == null) {
homeFragment = new HomeFragment();
}
return homeFragment;
}
</code></pre><h3 id="android_u4E4BinputType_u5C5E_u6027"><a href="#android_u4E4BinputType_u5C5E_u6027" class="headerlink" title="android之inputType属性"></a>android之inputType属性</h3><pre><code>&lt;EditText android:layout_width=&quot;fill_parent&quot; 
android:layout_height=&quot;wrap_content&quot; 
android:inputType=&quot;phone&quot; /&gt;
</code></pre><p>//文本类型，多为大写、小写和数字符号。</p>
<pre><code>android:inputType=&quot;none&quot;
android:inputType=&quot;text&quot;
android:inputType=&quot;textCapCharacters&quot; 字母大写
android:inputType=&quot;textCapWords&quot; 首字母大写
android:inputType=&quot;textCapSentences&quot; 仅第一个字母大写
android:inputType=&quot;textAutoCorrect&quot; 自动完成
android:inputType=&quot;textAutoComplete&quot; 自动完成
android:inputType=&quot;textMultiLine&quot; 多行输入
android:inputType=&quot;textImeMultiLine&quot; 输入法多行（如果支持）
android:inputType=&quot;textNoSuggestions&quot; 不提示
android:inputType=&quot;textUri&quot; 网址
android:inputType=&quot;textEmailAddress&quot; 电子邮件地址
android:inputType=&quot;textEmailSubject&quot; 邮件主题
android:inputType=&quot;textShortMessage&quot; 短讯
android:inputType=&quot;textLongMessage&quot; 长信息
android:inputType=&quot;textPersonName&quot; 人名
android:inputType=&quot;textPostalAddress&quot; 地址
android:inputType=&quot;textPassword&quot; 密码
android:inputType=&quot;textVisiblePassword&quot; 可见密码
android:inputType=&quot;textWebEditText&quot; 作为网页表单的文本
android:inputType=&quot;textFilter&quot; 文本筛选过滤
android:inputType=&quot;textPhonetic&quot; 拼音输入
</code></pre><p>//数值类型</p>
<pre><code>android:inputType=&quot;number&quot; 数字
android:inputType=&quot;numberSigned&quot; 带符号数字格式
android:inputType=&quot;numberDecimal&quot; 带小数点的浮点格式
android:inputType=&quot;phone&quot; 拨号键盘
android:inputType=&quot;datetime&quot; 时间日期
android:inputType=&quot;date&quot; 日期键盘
android:inputType=&quot;time&quot; 时间键盘
</code></pre><h3 id="ImageView-ScaleType"><a href="#ImageView-ScaleType" class="headerlink" title="ImageView.ScaleType"></a>ImageView.ScaleType</h3><pre><code>（1）ImageView.ScaleType.center:图片位于视图中间，但不执行缩放。
（2）ImageView.ScaleType.CENTER_CROP 按统一比例缩放图片（保持图片的尺寸比例）便于图片的两维（宽度和高度）等于或者大于相应的视图的维度
（3）ImageView.ScaleType.CENTER_INSIDE按统一比例缩放图片（保持图片的尺寸比例）便于图片的两维（宽度和高度）等于或者小于相应的视图的维度
（4）ImageView.ScaleType.FIT_CENTER缩放图片使用center
（5）ImageView.ScaleType.FIT_END缩放图片使用END
（6）ImageView.ScaleType.FIT_START缩放图片使用START
（7）ImageView.ScaleType.FIT_XY缩放图片使用XY
（8）ImageView.ScaleType.MATRIX当绘制时使用图片矩阵缩放
</code></pre><h3 id="u8C03_u7528_u7CFB_u7EDF_u53D1_u9001_u77ED_u4FE1_u754C_u9762"><a href="#u8C03_u7528_u7CFB_u7EDF_u53D1_u9001_u77ED_u4FE1_u754C_u9762" class="headerlink" title="调用系统发送短信界面"></a>调用系统发送短信界面</h3><pre><code>/**
* 发送短信
* @param smsBody
*/
private void sendSMS(String smsBody)
{
//Uri smsToUri = Uri.parse(&quot;smsto:10000&quot;); //如果想指定发送人
Uri smsToUri = Uri.parse(&quot;smsto:&quot;);
Intent intent = new Intent(Intent.ACTION_SENDTO, smsToUri);
intent.putExtra(&quot;sms_body&quot;, smsBody);
startActivity(intent);
}
</code></pre><h3 id="u8DF3_u8F6C_u5E02_u573A_u641C_u7D22_u67D0_u6B3E_u8F6F_u4EF6"><a href="#u8DF3_u8F6C_u5E02_u573A_u641C_u7D22_u67D0_u6B3E_u8F6F_u4EF6" class="headerlink" title="跳转市场搜索某款软件"></a>跳转市场搜索某款软件</h3><pre><code>Intent intent = new Intent(
                &quot;android.intent.action.VIEW&quot;);
        intent.setData(Uri
                .parse(&quot;market://details?id=com.adobe.flashplayer&quot;));
        startActivity(intent);
</code></pre><h3 id="u68C0_u6D4B_u7CFB_u7EDF_u4E2D_u662F_u5426_u5B89_u88C5_u67D0_u6B3E_u8F6F_u4EF6"><a href="#u68C0_u6D4B_u7CFB_u7EDF_u4E2D_u662F_u5426_u5B89_u88C5_u67D0_u6B3E_u8F6F_u4EF6" class="headerlink" title="检测系统中是否安装某款软件"></a>检测系统中是否安装某款软件</h3><pre><code>//检测系统中是否已经安装了adobe flash player插件，插件的packageName是com.adobe.flashplayer：
private boolean check() {
        PackageManager pm = getPackageManager();
        List&lt;PackageInfo&gt; infoList = pm
                .getInstalledPackages(PackageManager.GET_SERVICES);
        for (PackageInfo info : infoList) {
            if (&quot;com.adobe.flashplayer&quot;.equals(info.packageName)) {
                return true;
            }
        }
        return false;
}

private void isAvilible(String packageName) {

        PackageInfo packageInfo;
        try {
            packageInfo = this.getPackageManager().getPackageInfo(packageName,
                    0);

        } catch (NameNotFoundException e) {
            packageInfo = null;
            e.printStackTrace();
        }
        if (packageInfo != null) {

        //1、通过包名
        Intent intent = new Intent();
        intent = getPackageManager().getLaunchIntentForPackage(packageName);
        startActivity(intent);

        //2、通过类名： 
        Intent intent=new Intent();  
        intent.setComponent(new ComponentName(packageName, &quot;com.joe.internet.Main&quot;));  
        startActivity(intent);  
            } 

        }
</code></pre><h3 id="u5BF9_u8BDD_u6846_u83DC_u5355"><a href="#u5BF9_u8BDD_u6846_u83DC_u5355" class="headerlink" title="对话框菜单"></a>对话框菜单</h3><pre><code>new AlertDialog.Builder(this)
                    .setTitle(&quot;choice&quot;)
                    .setItems(new String[] { &quot;选择1&quot;, &quot;选择2&quot;, &quot;选择3&quot;, &quot;选择4&quot; },
                            new DialogInterface.OnClickListener() {

                                @Override
                                public void onClick(DialogInterface dialog,
                                        int which) {
                                    Toast.makeText(MyContentActivity.this,
                                            which + &quot;&quot;, Toast.LENGTH_SHORT)
                                            .show();

                                }
                            }).show();
</code></pre><h3 id="u5B9A_u4E49ProgressBar"><a href="#u5B9A_u4E49ProgressBar" class="headerlink" title="定义ProgressBar"></a>定义ProgressBar</h3><pre><code>&lt;ProgressBar
        android:id=&quot;@+id/mProgress&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;          
        android:indeterminateDrawable=&quot;@drawable/progress_rotate&quot; /&gt;
</code></pre><p>progress_rotate：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt;
    &lt;item&gt;
        &lt;rotate
            android:drawable=&quot;@drawable/progressbar&quot;
            android:duration=&quot;300&quot;
            android:fromDegrees=&quot;0.0&quot;
            android:pivotX=&quot;50.0%&quot;
            android:pivotY=&quot;50.0%&quot;
            android:toDegrees=&quot;360.0&quot; /&gt;
    &lt;/item&gt;
&lt;/layer-list&gt;
</code></pre><h3 id="u5E7B_u706F_u7247_u6548_u679C"><a href="#u5E7B_u706F_u7247_u6548_u679C" class="headerlink" title="幻灯片效果"></a>幻灯片效果</h3><p>xml</p>
<pre><code>&lt;ProgressBar
        android:id=&quot;@+id/ProgressBar01&quot;
        style=&quot;@style/animStyle&quot;
        android:layout_width=&quot;fill_parent&quot;
        android:layout_height=&quot;fill_parent&quot;
        android:layout_centerInParent=&quot;true&quot; /&gt;
</code></pre><p>style</p>
<pre><code>&lt;style name=&quot;animStyle&quot; parent=&quot;@android:style/Widget.ProgressBar.Large&quot;&gt;
        &lt;item name=&quot;android:indeterminateDrawable&quot;&gt;@anim/test&lt;/item&gt;
&lt;/style&gt;
</code></pre><p>anim</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:oneshot=&quot;false&quot; &gt;

    &lt;item
        android:drawable=&quot;@drawable/t1&quot;
        android:duration=&quot;500&quot;/&gt;
    &lt;item
        android:drawable=&quot;@drawable/t2&quot;
        android:duration=&quot;500&quot;/&gt;
    &lt;item
        android:drawable=&quot;@drawable/t3&quot;
        android:duration=&quot;500&quot;/&gt;
    &lt;item
        android:drawable=&quot;@drawable/t4&quot;
        android:duration=&quot;500&quot;/&gt;
    &lt;item
        android:drawable=&quot;@drawable/t5&quot;
        android:duration=&quot;500&quot;/&gt;

&lt;/animation-list&gt;
</code></pre><h3 id="MD5_u52A0_u5BC6"><a href="#MD5_u52A0_u5BC6" class="headerlink" title="MD5加密"></a>MD5加密</h3><pre><code>public String Md5(String plainText) {
        String result = &quot;&quot;;
        try {
            MessageDigest md = MessageDigest.getInstance(&quot;MD5&quot;);
            md.update(plainText.getBytes());
            byte b[] = md.digest();

            int i;

            StringBuffer buf = new StringBuffer(&quot;&quot;);
            for (int offset = 0; offset &lt; b.length; offset++) {
                i = b[offset];
                if (i &lt; 0)
                    i += 256;
                if (i &lt; 16)
                    buf.append(&quot;0&quot;);
                buf.append(Integer.toHexString(i));
            }
            result = buf.toString().toUpperCase();// 32位的加密（转成大写）

            buf.toString().substring(8, 24);// 16位的加密

        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
        return result;
    }
</code></pre><h3 id="u8BBE_u7F6E_u81EA_u52A8_u8DF3_u8F6C_u9875_u9762"><a href="#u8BBE_u7F6E_u81EA_u52A8_u8DF3_u8F6C_u9875_u9762" class="headerlink" title="设置自动跳转页面"></a>设置自动跳转页面</h3><p>Timer</p>
<pre><code>Timer timer = new Timer();
        timer.schedule(new TimerTask() {
            @Override
            public void run() {
                // TODO Auto-generated method stub
                Intent goIntent = new Intent();
                goIntent.setClass(LauncherActivity.this, DemoActivity.class);
                startActivity(goIntent);
            }
        }, 3 * 1000);
    }
</code></pre><h3 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h3><pre><code>new Handler().postDelayed(new Runnable() {
            @Override
            public void run() {
                startActivity(new Intent(SplashScreen.this,
                        DomobSampleActivity.class));
                finish();
            }
        }, 1000);
</code></pre><h3 id="u968F_u673A_u53D6_u6570"><a href="#u968F_u673A_u53D6_u6570" class="headerlink" title="随机取数"></a>随机取数</h3><pre><code>List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
        for (int i = 0; i &lt; 10; i++) {
            list.add(i);
        }
        Collections.shuffle(list);
        for (int v : list) {
            Log.d(&quot;wxl&quot;, &quot;V===&quot; + v);
        }
</code></pre><p>或：</p>
<pre><code>Random random = new Random();
int ran = random.nextInt(keywordsList.size());
String tmp = keywordsList.get(ran).get(&quot;keyword&quot;).toString();
</code></pre><h3 id="selector_u4E0B_u7684_u5C5E_u6027_u503C"><a href="#selector_u4E0B_u7684_u5C5E_u6027_u503C" class="headerlink" title="selector下的属性值"></a>selector下的属性值</h3><pre><code>android:state_pressed
如果是true，当被点击时显示该图片，如果是false没被按下时显示默认。
android:state_focused
true，获得焦点时显示；false，没获得焦点显示默认。
android:state_selected
true，当被选择时显示该图片；false，当未被选择时显示该图片。
android:state_checkable
true，当 能使用时显示该图片；false，当CheckBox不能使用时显示该图片。
android:state_checked
true，当CheckBox选中时显示该图片；false，当CheckBox为选中时显示该图片。
android:state_enabled
true，当该组件能使用时显示该图片；false，当该组件不能使用时显示该图片。
android:state_window_focused
true，当此activity获得焦点在最前面时显示该图片；false，当没在最前面时显示该图片。


&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
    &lt;item android:state_pressed=&quot;true&quot;
        android:drawable=&quot;@drawable/button_pressed&quot;/&gt;&lt;!-- pressed --&gt;
    &lt;item android:state_focused=&quot;true&quot;
        android:drawable=&quot;@drawable/button_focused&quot;/&gt;&lt;!-- focused --&gt;
    &lt;item android:drawable=&quot;@drawable/button_normal&quot;/&gt;&lt;!-- default --&gt;
&lt;/selector&gt;
</code></pre><h3 id="u5E26_u4E0B_u5212_u7EBF_u7684EditText"><a href="#u5E26_u4E0B_u5212_u7EBF_u7684EditText" class="headerlink" title="带下划线的EditText"></a>带下划线的EditText</h3><pre><code>public class LinedEditText extends EditText {
    private Paint linePaint;
    private float margin;
    private int paperColor;

    public LinedEditText(Context paramContext, AttributeSet paramAttributeSet) {
        super(paramContext, paramAttributeSet);
        this.linePaint = new Paint();
    }
    @Override
    protected void onDraw(Canvas paramCanvas) {
        paramCanvas.drawColor(this.paperColor);
        int i = getLineCount();// 得到总的行數
        int j = getHeight();// 获得TextView的高度
        int k = getLineHeight();// 获得TextView的行高
        int m = j / k + 1;// 总的线数
        if (i &lt; m)
            i = m;
        int n = getCompoundPaddingTop();
        Log.d(&quot;wxl&quot;, &quot;n----&quot; + n);
        paramCanvas.drawLine(0.0F, n, getRight(), n, this.linePaint);
        for (int i2 = 0;; i2++) {
            if (i2 &gt;= i) {
                setPadding(10 + (int) this.margin, 0, 0, 0);
                super.onDraw(paramCanvas);
                paramCanvas.restore();
                return;
            }
            n += k;
            paramCanvas.drawLine(0.0F, n, getRight(), n, this.linePaint);
            paramCanvas.save();
        }
    }
}
</code></pre><p>主要工作就是重载onDraw方法，利用从TextView继承下来的getLineCount函数获取文本所占的行数，以及getLineBounds来获取特定行的基准高度值，而且这个函数第二个参数会返回此行的“外包装”值。再利用这些值绘制这一行的线条。为了让界面的View使用自定义的EditText类，必须在配置文件中进行设置</p>
<h3 id="u5173_u95ED_u952E_u76D8"><a href="#u5173_u95ED_u952E_u76D8" class="headerlink" title="关闭键盘"></a>关闭键盘</h3><pre><code>public static void hideSoftInput(Activity activity) {
        if (activity.getCurrentFocus() != null)
            ((InputMethodManager) activity
                    .getSystemService(Context.INPUT_METHOD_SERVICE))
                    .hideSoftInputFromWindow(activity.getCurrentFocus()
                            .getWindowToken(), InputMethodManager.HIDE_NOT_ALWAYS);
    }
</code></pre><p>界面不被弹出的键盘盖住<br>一进入activity就弹出键盘</p>
<pre><code>android:windowSoftInputMode=&quot;adjustResize&quot; 
android:windowSoftInputMode=&quot;adjustPan|stateAlwaysVisible&quot;
</code></pre><p>第一个软键盘和输入框会完全分离，而第二个输入框还是会被软键盘盖住一点点<br>而且第二个要把两个属性叠加起来，为什么要叠加起来呢，因为如果只用adjustPan 的话需要点击输入框才会弹出软键盘</p>
<p>在 AndroidMainfest.xml中选择哪个activity，设置windowSoftInputMode属性为</p>
<pre><code>adjustUnspecified|stateHidden
android:windowSoftInputMode=&quot;adjustUnspecified|stateHidden&quot;
</code></pre><h3 id="windowSoftInputMode_u5404_u503C_u7684_u542B_u4E49_uFF1A"><a href="#windowSoftInputMode_u5404_u503C_u7684_u542B_u4E49_uFF1A" class="headerlink" title="windowSoftInputMode各值的含义："></a>windowSoftInputMode各值的含义：</h3><pre><code>stateUnspecified：软键盘的状态并没有指定，系统将选择一个合适的状态或依赖于主题的设置
stateUnchanged：当这个activity出现时，软键盘将一直保持在上一个activity里的状态，无论是隐藏还是显示
stateHidden：用户选择activity时，软键盘总是被隐藏
stateAlwaysHidden：当该Activity主窗口获取焦点时，软键盘也总是被隐藏的
stateVisible：软键盘通常是可见的
stateAlwaysVisible：用户选择activity时，软键盘总是显示的状态
adjustUnspecified：默认设置，通常由系统自行决定是隐藏还是显示
adjustResize：该Activity总是调整屏幕的大小以便留出软键盘的空间
adjustPan：当前窗口的内容将自动移动以便当前焦点从不被键盘覆盖和用户能总是看到输入内容的部分
</code></pre><h3 id="u63A7_u4EF6_u7F8E_u5316Shape"><a href="#u63A7_u4EF6_u7F8E_u5316Shape" class="headerlink" title="控件美化Shape"></a>控件美化Shape</h3><p><a href="http://wuxiaolong.me/2013/07/09/shape/" target="_blank" rel="external">http://wuxiaolong.me/2013/07/09/shape/</a></p>
<h3 id="u83B7_u53D6_u7248_u672C_u540D_u79F0_VersionName"><a href="#u83B7_u53D6_u7248_u672C_u540D_u79F0_VersionName" class="headerlink" title="获取版本名称 VersionName"></a>获取版本名称 VersionName</h3><pre><code>public String getVersionName(Context context) {
        PackageManager manager = context.getPackageManager();
        String packageName = context.getPackageName();
        try {
            PackageInfo info = manager.getPackageInfo(packageName, 0);
            return info.versionName;
        } catch (NameNotFoundException e) {
            return &quot;1.0&quot;;
        }
    }
</code></pre><h3 id="u83B7_u53D6Android_u624B_u673A_u8BBE_u5907_u7684IMSI_/_IMEI__u4FE1_u606F"><a href="#u83B7_u53D6Android_u624B_u673A_u8BBE_u5907_u7684IMSI_/_IMEI__u4FE1_u606F" class="headerlink" title="获取Android手机设备的IMSI / IMEI 信息"></a>获取Android手机设备的IMSI / IMEI 信息</h3><pre><code>TelephonyManager mTelephonyMgr = (TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE);
String imsi = mTelephonyMgr.getSubscriberId(); 
String imei = mTelephonyMgr.getDeviceId(); 
Log.i(&quot;wxl&quot;, &quot;imsi=&quot;+imsi);为null
Log.i(&quot;wxl&quot;, &quot;imei=&quot;+imei); 
</code></pre><p> 另外不要忘了在AndroidManifest.xml中加上读取手机状态的权限</p>
<pre><code>&lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot;/&gt;
</code></pre><h3 id="u81EA_u5B9A_u4E49Log_u662F_u5426_u663E_u793A"><a href="#u81EA_u5B9A_u4E49Log_u662F_u5426_u663E_u793A" class="headerlink" title="自定义Log是否显示"></a>自定义Log是否显示</h3><pre><code>public class Log {
    private static final String TAG = &quot;wxl&quot;;
    private static final boolean LOG = true;
    public static void i(String msg) {
        if (LOG)
            android.util.Log.i(TAG , msg);
    }
    public static void d(String msg) {
        if (LOG)
            android.util.Log.d(TAG , msg);
    }
    public static void w(String msg) {
        if (LOG)
            android.util.Log.w(TAG , msg);
    }
    public static void w(String msg, Throwable throwable) {
        if (LOG)
            android.util.Log.w(TAG , msg, throwable);
    }
    public static void v(String msg) {
        if (LOG)
            android.util.Log.v(TAG , msg);
    }
    public static void e(String msg) {
        android.util.Log.e(TAG , msg);
    }
    public static void e(String msg, Throwable throwable) {
        android.util.Log.e(TAG , msg, throwable);
    }
}
</code></pre><h3 id="u5F02_u6B65_u64CD_u4F5CAsyncTask"><a href="#u5F02_u6B65_u64CD_u4F5CAsyncTask" class="headerlink" title="异步操作AsyncTask"></a>异步操作AsyncTask</h3><pre><code>//参数1：向后台任务的执行方法传递参数的类型 ； 
//参数2：在后台任务执行过程中，要求主UI线程处理中间状态，通常是一些UI处理中传递的参数类型；
//参数3：后台任务执行完返回时的参数类型。
private class MyAsyncTask extends AsyncTask&lt;Integer, String, Void&gt; {

        // 实现抽象方法doInBackground()，代码将在后台线程中执行，由execute()触发
        protected Void doInBackground(Integer... params) {
            return null;
        }

        // 任务启动，可以在这里显示一个对话框，这里简单处理
        protected void onPreExecute() {
            super.onPreExecute();
        }

        // 取消
        protected void onCancelled() {
            super.onCancelled();
        }

        // 定义后台进程执行完后的处理
        protected void onPostExecute(Void result) {
            super.onPostExecute(result);
            Toast.makeText(MainActivity.this, &quot;OK&quot;, Toast.LENGTH_SHORT).show();
        }

        // 更新进度,在UI主线程执行的内容，将item加入list中。方法中的参数为范式方式，实质为数组，由于我们只传递了item一个String，要获取，为values[0]
        protected void onProgressUpdate(String... values) {
            super.onProgressUpdate(values);
        }

    }
</code></pre><p>调用：</p>
<pre><code>new MyAsyncTask().execute(参数1);// 创建后台任务的对象
</code></pre><p>检查网络状态</p>
<pre><code>public boolean checkNetworkInfo() {
        ConnectivityManager conMan = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);
        // mobile 3G Data Network
        State mobile = conMan.getNetworkInfo(ConnectivityManager.TYPE_MOBILE)
                .getState();
        // wifi
        State wifi = conMan.getNetworkInfo(ConnectivityManager.TYPE_WIFI)
                .getState();
        // 如果3G网络和wifi网络都未连接，且不是处于正在连接状态 则进入Network Setting界面 由用户配置网络连接
        if (mobile == State.CONNECTED || mobile == State.CONNECTING)
            return true;
        if (wifi == State.CONNECTED || wifi == State.CONNECTING)
            return true;
        AlertDialog.Builder builder = new AlertDialog.Builder(this);
        builder.setMessage(getResources().getString(R.string.no_network))
                .setCancelable(false)
                .setPositiveButton(
                        getResources().getString(R.string.configuration),
                        new DialogInterface.OnClickListener() {
                            public void onClick(DialogInterface dialog, int id) {

                                // 进入无线网络配置界面
                                startActivity(new Intent(
                                        Settings.ACTION_WIRELESS_SETTINGS));
                                MainActivity.this.finish();
                            }
                        })
                .setNegativeButton(getResources().getString(R.string.quit),
                        new DialogInterface.OnClickListener() {
                            public void onClick(DialogInterface dialog, int id) {
                                MainActivity.this.finish();
                            }
                        });
        builder.show();
        return false;
    }
</code></pre><p>代码判断调用：</p>
<pre><code>// 检查网络状态
if (!checkNetworkInfo()) {
    return;
}
</code></pre><h3 id="u8BA9_u6570_u636E_u63A5_u53D7_u7F51_u9875_u7684_u683C_u5F0F"><a href="#u8BA9_u6570_u636E_u63A5_u53D7_u7F51_u9875_u7684_u683C_u5F0F" class="headerlink" title="让数据接受网页的格式"></a>让数据接受网页的格式</h3><pre><code>Html.fromHtml（）

URLEncoder.encode(String s); 网址请求中文解析
&amp;#8230;代表省略号
URLEncoder.encode
网址请求带中文

URLEncoder.encode(content, &quot;utf-8&quot;)
</code></pre><p>Android中字体加粗<br>在xml文件中使用</p>
<pre><code>android:textStyle=”bold”
</code></pre><p>Java 代码<br>（网上查XML不能将中文设置成粗体，只能通过Java code。Android 2.2 可以通过XML将中文设置成粗体）</p>
<pre><code>TextView tv = (TextView)findViewById(R.id.TextView01); 
TextPaint tp = tv.getPaint();
tp.setFakeBoldText(true);
Html.fromHtml(“\&lt;\b&gt;”)


(1)viewHolder.title.setText(Html.fromHtml(&quot;&lt;b&gt;&quot;+ listTitle.get(position).get(&quot;title&quot;) + &quot;&lt;/b&gt;&quot;));
(2)TextView.setText(Html.fromHtml(&quot;&lt;font color=#FF0000&gt;hello&lt;/font&gt;&quot;));
</code></pre><h3 id="u4EE3_u7801_u8BBE_u7F6E_u80CC_u666F_u56FEsetImageResource/setBackgroundResource"><a href="#u4EE3_u7801_u8BBE_u7F6E_u80CC_u666F_u56FEsetImageResource/setBackgroundResource" class="headerlink" title="代码设置背景图setImageResource/setBackgroundResource"></a>代码设置背景图setImageResource/setBackgroundResource</h3><pre><code>textView.setBackgroundResource(R.drawable.bg_menu_1);设置背景图片
textView.setBackgroundColor(0xffffffff);
setImageResource與xml中的src的屬性才是相匹配的，而setBackgroundResource是與xml中的background屬性相匹配
的
holder.chat_sound_iv_right.setBackgroundResource(0);//没有图片
</code></pre><h3 id="android_u4E2D_u7684ellipsize"><a href="#android_u4E2D_u7684ellipsize" class="headerlink" title="android中的ellipsize"></a>android中的ellipsize</h3><p>用法如下：<br>在xml中</p>
<pre><code>android:ellipsize = &quot;end&quot;　　  省略号在结尾
android:ellipsize = &quot;start&quot; 　　省略号在开头
android:ellipsize = &quot;middle&quot;     省略号在中间
android:ellipsize = &quot;marquee&quot;  跑马灯
</code></pre><p>最好加一个约束android:singleline = “true”<br>跑马灯</p>
<pre><code>android:singleLine=&quot;true&quot;
android:ellipsize=&quot;marquee&quot;
android:focusableInTouchMode=&quot;true&quot;
android:focusable=&quot;true&quot;
android:marqueeRepeatLimit=&quot;marquee_forever&quot;
android:singleLine=true 表示使用单行文字，多行文字也就无所谓使用Marquee效果了。
android:marqueeRepeatLimit，设置走马灯滚动的次数。
android:ellipsize，设置了文字过长时如何切断文字，可以有none, start,middle, end, 如果使用走马灯效果则设为marquee.
android:focusable，Android的缺省行为是在控件获得Focus时才会显示走马灯效果
</code></pre><p>###控件点击效果</p>
<pre><code>&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
    &lt;item android:state_focused=&quot;true&quot; android:state_pressed=&quot;false&quot; android:drawable=&quot;@drawable/professional_1&quot;/&gt;
    &lt;item android:state_focused=&quot;false&quot; android:state_pressed=&quot;true&quot; android:drawable=&quot;@drawable/professional_1&quot;/&gt;
    &lt;item android:drawable=&quot;@drawable/professional&quot;/&gt;
&lt;/selector&gt;
</code></pre><p>###保留小数点<br>方法一：</p>
<pre><code>private DecimalFormat df;
df = new DecimalFormat(&quot;0.0&quot;);
float data;
df.format(data);//返回值
</code></pre><p>方法二：</p>
<pre><code>double juli = 1569;
String result = String.format(&quot;%.1f&quot;, juli/1000);
</code></pre><h3 id="RadioGroup"><a href="#RadioGroup" class="headerlink" title="RadioGroup"></a>RadioGroup</h3><pre><code>&lt;RadioGroup
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:orientation=&quot;vertical&quot; &gt;

    &lt;RadioButton
        android:id=&quot;@+id/open&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_marginLeft=&quot;10dip&quot;
        android:layout_marginTop=&quot;10dip&quot;
        android:button=&quot;@drawable/radiobutton&quot;
        android:checked=&quot;true&quot;
        android:text=&quot;@string/open_album&quot;
        android:textColor=&quot;#000000&quot;
        android:textSize=&quot;16dip&quot; /&gt;

    &lt;RadioButton
        android:id=&quot;@+id/secrecy&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_marginLeft=&quot;10dip&quot;
        android:button=&quot;@drawable/radiobutton&quot;
        android:text=&quot;@string/secrecy_album&quot;
        android:textColor=&quot;#000000&quot;
        android:textSize=&quot;16dip&quot; /&gt;
&lt;/RadioGroup&gt;
</code></pre><p>android:button=”@null” 去除RadioButton前面的圆点<br>android:background=”@drawable/radio” 使用定义的样式</p>
<h3 id="u5360_u4F4D_u7B26_25s_u66FF_u6362"><a href="#u5360_u4F4D_u7B26_25s_u66FF_u6362" class="headerlink" title="占位符%s替换"></a>占位符%s替换</h3><pre><code>%d （表示整数）
%f （表示浮点数）
%s （表示字符串）
</code></pre><p>txt.setText(String.format (“被替换%1$s”,”替换内容”));</p>
<h3 id="TextView_u4E2D_u5D4C_u5957_u56FE_u7247Drawable"><a href="#TextView_u4E2D_u5D4C_u5957_u56FE_u7247Drawable" class="headerlink" title="TextView中嵌套图片Drawable"></a>TextView中嵌套图片Drawable</h3><pre><code>Drawable drawable = getResources().getDrawable(R.drawable.ji_dot_nor);
drawable.setBounds(0, 0, drawable.getIntrinsicWidth(),drawable.getIntrinsicHeight());
textView.setCompoundDrawablesWithIntrinsicBounds(null, drawable, null, null); 
</code></pre><p>说明：<code>setCompoundDrawablesWithIntrinsicBounds(left, top, right, bottom)</code><br>意思是设置Drawable显示在text的左、上、右、下位置。(Textview、Button都可以)</p>
<p>TextView做成分割线</p>
<pre><code>&lt;TextView
    android:id=&quot;@id/textView2&quot;
    android:layout_width=&quot;fill_parent&quot;
    android:layout_height=&quot;2.0px&quot;
android:background=&quot;@color/orange&quot; /&gt;
</code></pre><h3 id="SpannableString_u5355_u51FB_u6587_u5B57_u94FE_u63A5"><a href="#SpannableString_u5355_u51FB_u6587_u5B57_u94FE_u63A5" class="headerlink" title="SpannableString单击文字链接"></a>SpannableString单击文字链接</h3><pre><code>SpannableString spannableString = new SpannableString(str);
        spannableString.setSpan(new ClickableSpan() {
            public void onClick(View view) {
                // Intent intent = new Intent(ApkTest.this, Apk.class);
                Intent intent = new Intent(Intent.ACTION_CALL, Uri.parse(&quot;tel:&quot;
                        + &quot;15261589767&quot;));
                startActivity(intent);
            }
        }, 0, str.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        TextView.setText(spannableString);
        TextView.setMovementMethod(LinkMovementMethod.getInstance());
</code></pre><p>TextView中文字通过SpannableString来设置超链接、颜色、字体等属性</p>
<pre><code>String  title =”123456”;
SpannableString titleStr = new SpannableString(title);
titleStr.setSpan(new ForegroundColorSpan(Color.RED), 0,
                        titleStr.length(), 0);
textView.setText(titleStr);
</code></pre><h3 id="android_3AdrawableTop_u5C5E_u6027"><a href="#android_3AdrawableTop_u5C5E_u6027" class="headerlink" title="android:drawableTop属性"></a>android:drawableTop属性</h3><pre><code>写在TextView里，实现图片+文字
</code></pre><h3 id="u83B7_u53D6_u5206_u8FA8_u7387"><a href="#u83B7_u53D6_u5206_u8FA8_u7387" class="headerlink" title="获取分辨率"></a>获取分辨率</h3><pre><code>DisplayMetrics displayMetrics = new DisplayMetrics();
getWindowManager().getDefaultDisplay().getMetrics(displayMetrics);

displayMetrics.widthPixels + &quot;x&quot;+ displayMetrics.heightPixels;
</code></pre><h3 id="u4EE3_u7801_u5B8C_u6210_u63A7_u4EF6"><a href="#u4EE3_u7801_u5B8C_u6210_u63A7_u4EF6" class="headerlink" title="代码完成控件"></a>代码完成控件</h3><p>Button</p>
<pre><code>linearLayout = (LinearLayout) findViewById(R.id.linearLayout2);
LayoutParams layoutParams = new LinearLayout.LayoutParams(0,
                LinearLayout.LayoutParams.WRAP_CONTENT, 1);//1均分属性
layoutParams.setMargins(10, 10, 10, 10);

Button button = new Button(MainActivity.this);
button.setLayoutParams(layoutParams);
linearLayout.addView(button);
</code></pre><p>TextView</p>
<pre><code>private TextView overlay;
private void initOverlay() {
        LayoutInflater inflater = LayoutInflater.from(this);
        overlay = (TextView) inflater.inflate(R.layout.overlay, null);
        overlay.setVisibility(View.INVISIBLE);
        WindowManager.LayoutParams lp = new WindowManager.LayoutParams(
                LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT,
                WindowManager.LayoutParams.TYPE_APPLICATION,
                WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE
                        | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE,
                PixelFormat.TRANSLUCENT);
        WindowManager windowManager = (WindowManager) this
                .getSystemService(Context.WINDOW_SERVICE);
        windowManager.addView(overlay, lp);
    }
</code></pre><p> xml：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;TextView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:background=&quot;#ffffff&quot;
    android:gravity=&quot;center&quot;
    android:maxWidth=&quot;80dip&quot;
    android:minWidth=&quot;80dip&quot;
    android:padding=&quot;5dip&quot;
    android:textColor=&quot;#3399ff&quot;
    android:textSize=&quot;70sp&quot; /&gt;
</code></pre><p>代码：</p>
<pre><code>private LinearLayout.LayoutParams layoutParams = null;
        private LinearLayout.LayoutParams btnParmas;

layoutParams = new LinearLayout.LayoutParams(
                            LinearLayout.LayoutParams.WRAP_CONTENT,
                            LinearLayout.LayoutParams.WRAP_CONTENT);
                    layoutParams.setMargins(
                            (int) getResources().getDimension(
                                    R.dimen.lable_left), 0, 0, 0);
                    btnParmas = new LinearLayout.LayoutParams(
                            LinearLayout.LayoutParams.WRAP_CONTENT,
                            (int) getResources().getDimension(
                                    R.dimen.lable_height));

                    for (int i = 0; i &lt; lables.length; i++) {
                        LinearLayout linearLayout = new LinearLayout(activity);
                        lableColor = random.nextInt(lableColors.length);
                        Button lable = new Button(activity);
                        lable.setText(lables[i]);
                        lable.setGravity(Gravity.CENTER_HORIZONTAL
                                | Gravity.CENTER_VERTICAL);
                        lable.setTextSize(getResources().getDimension(
                                R.dimen.lable));
                        lable.setTextColor(getResources().getColor(
                                R.color.white));
                        lable.setBackgroundResource(lableColors[i]);
                        linearLayout.addView(lable, btnParmas);
                        holder.play_lables.addView(linearLayout, layoutParams);
                    }
</code></pre><h3 id="TextWatcher"><a href="#TextWatcher" class="headerlink" title="TextWatcher"></a>TextWatcher</h3><pre><code>editText1.addTextChangedListener(watcher);
TextWatcher watcher = new TextWatcher() {
        public void onTextChanged(CharSequence arg0, int arg1, int arg2,
                int arg3) {
        }
        public void beforeTextChanged(CharSequence arg0, int arg1, int arg2,
                int arg3) {
        }
        public void afterTextChanged(Editable arg0) {            
        }
    };
</code></pre><h3 id="u5C4F_u5E55_u65CB_u8F6C_u65F6_u4E0D_u9500_u6BC1"><a href="#u5C4F_u5E55_u65CB_u8F6C_u65F6_u4E0D_u9500_u6BC1" class="headerlink" title="屏幕旋转时不销毁"></a>屏幕旋转时不销毁</h3><p>AndroidManifest加入</p>
<pre><code>android:configChanges=&quot;orientation|keyboardHidden&quot;
</code></pre><p>###获取屏幕方向</p>
<pre><code>Configuration newConfig = getResources().getConfiguration();    
        if (newConfig.orientation == Configuration.ORIENTATION_LANDSCAPE){    
            //横屏    
        }else if(newConfig.orientation == Configuration.ORIENTATION_PORTRAIT){    
            //竖屏    
        }else if(newConfig.hardKeyboardHidden == Configuration.KEYBOARDHIDDEN_NO){    
            //键盘没关闭。屏幕方向为横屏    
        }else if(newConfig.hardKeyboardHidden == Configuration.KEYBOARDHIDDEN_YES){    
            //键盘关闭。屏幕方向为竖屏    
        }
</code></pre><h3 id="List_u589E_u52A0_u6570_u636E"><a href="#List_u589E_u52A0_u6570_u636E" class="headerlink" title="List增加数据"></a>List增加数据</h3><p>简单</p>
<pre><code>private List&lt;String&gt; getData() {
        List&lt;String&gt; data = new ArrayList&lt;String&gt;();
        data.add(&quot;123&quot;);
        data.add(&quot;345&quot;);
        data.add(&quot;456&quot;);
        data.add(&quot;567&quot;);
        return data;
    }
</code></pre><p>键值对</p>
<pre><code>private List&lt;Map&lt;String, Object&gt;&gt; getData() {
        List&lt;Map&lt;String, Object&gt;&gt; list = new ArrayList&lt;Map&lt;String, Object&gt;&gt;();

        Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();
        map.put(&quot;title&quot;, &quot;G1&quot;);
        map.put(&quot;info&quot;, &quot;google 1&quot;);
        map.put(&quot;img&quot;, R.drawable.i1);
        list.add(map);

        map = new HashMap&lt;String, Object&gt;();
        map.put(&quot;title&quot;, &quot;G2&quot;);
        map.put(&quot;info&quot;, &quot;google 2&quot;);
        map.put(&quot;img&quot;, R.drawable.i2);
        list.add(map);

        map = new HashMap&lt;String, Object&gt;();
        map.put(&quot;title&quot;, &quot;G3&quot;);
        map.put(&quot;info&quot;, &quot;google 3&quot;);
        map.put(&quot;img&quot;, R.drawable.i3);
        list.add(map);

        return list;
    }
</code></pre><p>清除数据：</p>
<pre><code>data.clear();
listView.setAdapter(new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_expandable_list_item_1,getData()));
</code></pre><p>LinkedList</p>
<pre><code>LinkedList&lt;String&gt; list = new LinkedList&lt;String&gt;();
list.addFirst(&quot;000&quot;);
</code></pre><h3 id="u9A8C_u8BC1_u662F_u5426_u624B_u673A_u53F7_u7801"><a href="#u9A8C_u8BC1_u662F_u5426_u624B_u673A_u53F7_u7801" class="headerlink" title="验证是否手机号码"></a>验证是否手机号码</h3><pre><code>public boolean isMobileNO(String mobiles) {
        String expression = &quot;((^(13|15|18)[0-9]{9}$)|(^0[1,2]{1}\\d{1}-?\\d{8}$)|(^0[3-9] {1}\\d{2}-?\\d{7,8}$)|(^0[1,2]{1}\\d{1}-?\\d{8}-(\\d{1,4})$)|(^0[3-9]{1}\\d{2}-? \\d{7,8}-(\\d{1,4})$))&quot;;
        Pattern pattern = Pattern.compile(expression);
        Matcher matcher = pattern.matcher(mobiles);
        Log.d(&quot;wxl&quot;, matcher.matches() + &quot;&quot;);
        return matcher.matches();
    }
</code></pre><p>正则表达式数字验证</p>
<pre><code>public boolean isNumber(String str)
    {
        java.util.regex.Pattern pattern=java.util.regex.Pattern.compile(&quot;[0-9]*&quot;);
        java.util.regex.Matcher match=pattern.matcher(str);
        if(match.matches()==false)
        {
            return false;
        }
        else
        {
            return true;
        }
    }
</code></pre><h3 id="SharedPreferences"><a href="#SharedPreferences" class="headerlink" title="SharedPreferences"></a>SharedPreferences</h3><p>SharedPreferences存数据</p>
<pre><code>SharedPreferences sharedPreferences = getSharedPreferences(&quot;test&quot;, Context.MODE_PRIVATE);
Editor editor = sharedPreferences.edit();//获取编辑器
editor.putString(&quot;name&quot;, &quot;张三&quot;);
editor.putInt(&quot;age&quot;, 24);
editor.putBoolean(&quot;AutoLogin&quot;, false);
editor.commit();//提交修改
</code></pre><p>SharedPreferences取数据</p>
<pre><code>SharedPreferences sharedPreferences = getSharedPreferences(&quot;test&quot;, Context.MODE_PRIVATE);
//getString()第二个参数为缺省值,如果preference中不存在该key,将返回缺省值
String name = sharedPreferences.getString(&quot;name&quot;, &quot;&quot;);
int age = sharedPreferences.getInt(&quot;age&quot;, 1);
boolean autoLogin= sharedPreferences. getBoolean(&quot;AutoLogin&quot;, false);
</code></pre><h3 id="Intent__u4F20_u503C"><a href="#Intent__u4F20_u503C" class="headerlink" title="Intent 传值"></a>Intent 传值</h3><p>简单传值<br>ActivityPage</p>
<pre><code>Intent intent = new Intent(ActivityPage.this, Player.class);
            //保存信息
            Bundle mBundle = new Bundle();
            mBundle.putString(&quot;realname &quot;, realname);
            intent.putExtras(mBundle);
</code></pre><p>Player接受</p>
<pre><code>realname = this.getIntent().getStringExtra(&quot;realname&quot;);
Intent intent = new Intent();
intent.setClass(HomeActivity.this, CompanyActivity.class);
intent.putExtra(&quot;mCompanySupply&quot;, mCompanySupply);
                startActivity(intent);
CompanyActivity.class:
ArrayList&lt;ClassifySub3Bean&gt;  mCompanySupply = (ArrayList&lt;ClassifySub3Bean&gt;) getIntent()
                .getSerializableExtra(&quot;mCompanySupply&quot;);
</code></pre><p>复杂传值<br>A页面：</p>
<pre><code>private static final int REQUEST_CODE_A = 0;
private static final int RESULT_CODE_B = 0;
Intent intent = new Intent();
                Bundle bundle = new Bundle();
                intent.setClass(MainActivity.this, TestBActivity.class);
                bundle.putString(&quot;msg&quot;, textView.getText().toString());
                intent.putExtras(bundle);
                startActivityForResult(intent, REQUEST_CODE_A);

protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        if (requestCode == REQUEST_CODE_A &amp;&amp; resultCode == RESULT_OK) {
            String str=data.getExtras().getString(&quot;result&quot;);
        }
    }
</code></pre><p>B页面</p>
<pre><code>private static final int RESULT_CODE_B = 0;

Intent intent = new Intent();
                intent.putExtra(&quot;result&quot;, textView.getText().toString());
                setResult(RESULT_OK, intent);
                finish();

public boolean onKeyDown(int keyCode, KeyEvent event) {
        if (keyCode == KeyEvent.KEYCODE_BACK) {
            Intent intent = new Intent();
            intent.putExtra(&quot;result&quot;, &quot;直接返回&quot;);
            setResult(RESULT_OK, intent);
            this.finish();
            return true;
        } else {
            return super.onKeyDown(keyCode, event);
        }
    }
</code></pre><p>List</p>
<pre><code>Intent intent = new Intent();
                    intent.putStringArrayListExtra(&quot;mSelectedPhotos&quot;,
                            mSelectedPhotos);
                    setResult(RESULT_OK, intent);


                    ArrayList&lt;String&gt; mSelectedPhotos = (ArrayList&lt;String&gt;) intent
                        .getStringArrayListExtra(&quot;mSelectedPhotos&quot;);
</code></pre><h3 id="xml_u6587_u4EF6_u4E2D_u5BFC_u5165_u53E6_u4E00_u4E2Axml_u6587_u4EF6_u7684_u65B9_u6CD5include"><a href="#xml_u6587_u4EF6_u4E2D_u5BFC_u5165_u53E6_u4E00_u4E2Axml_u6587_u4EF6_u7684_u65B9_u6CD5include" class="headerlink" title="xml文件中导入另一个xml文件的方法include"></a>xml文件中导入另一个xml文件的方法include</h3><pre><code>&lt;include 
android:id=&quot;@+id/included1&quot;
layout=&quot;@layout/anotherlayout&quot; /&gt;
</code></pre><h3 id="u5355_u51FB_u8FD4_u56DE_u952E_u4E24_u6B21_u9000_u51FA"><a href="#u5355_u51FB_u8FD4_u56DE_u952E_u4E24_u6B21_u9000_u51FA" class="headerlink" title="单击返回键两次退出"></a>单击返回键两次退出</h3><pre><code>private static Boolean isExit = false;
        @Override
        public boolean onKeyDown(int keyCode, KeyEvent event) {
                if (keyCode == KeyEvent.KEYCODE_BACK) {
                        if (isExit == false) {
                                isExit = true;
                                Toast.makeText(this, &quot;再按一次退出程序&quot;, Toast.LENGTH_SHORT).show();
                                new Timer().schedule(new TimerTask() {
                                        @Override
                                        public void run() {
                                                isExit = false;
                                        }
                                }, 2000);
                        } else {
                                finish();
                                System.exit(0);
                        }
                }
                return false;
        }
</code></pre><p>或者</p>
<pre><code>@Override 
public boolean onKeyUp(int keyCode, KeyEvent event) { 
    if (keyCode == KeyEvent.KEYCODE_BACK) { 
        long secondTime = System.currentTimeMillis(); 
        if (secondTime - firstTime &gt; 800) {//如果两次按键时间间隔大于800毫秒，则不退出 
            Toast.makeText(MainActivity.this, &quot;再按一次退出程序...&quot;, 
                    Toast.LENGTH_SHORT).show(); 
            firstTime = secondTime;//更新firstTime 
            return true; 
        } else { 
            System.exit(0);//否则退出程序 
        } 
    } 
    return super.onKeyUp(keyCode, event); 
}
</code></pre><h3 id="u56FE_u7247_u5DE6_u53F3_u5FAA_u73AF_u79FB_u52A8"><a href="#u56FE_u7247_u5DE6_u53F3_u5FAA_u73AF_u79FB_u52A8" class="headerlink" title="图片左右循环移动"></a>图片左右循环移动</h3><pre><code>TranslateAnimation left, right;
right = new TranslateAnimation(Animation.RELATIVE_TO_PARENT, -1f,
                Animation.RELATIVE_TO_PARENT, -2f,
                Animation.RELATIVE_TO_PARENT, 0f, Animation.RELATIVE_TO_PARENT,
                0f);
        left = new TranslateAnimation(Animation.RELATIVE_TO_PARENT, -2f,
                Animation.RELATIVE_TO_PARENT, -1f,
                Animation.RELATIVE_TO_PARENT, 0f, Animation.RELATIVE_TO_PARENT,
                0f);
        right.setDuration(25000);
        left.setDuration(25000);
        right.setFillAfter(true);
        left.setFillAfter(true);

        right.setAnimationListener(new Animation.AnimationListener() {
            @Override
            public void onAnimationStart(Animation animation) {
            }

            @Override
            public void onAnimationRepeat(Animation animation) {
            }

            @Override
            public void onAnimationEnd(Animation animation) {
                runImage.startAnimation(left);
            }
        });
        left.setAnimationListener(new Animation.AnimationListener() {
            @Override
            public void onAnimationStart(Animation animation) {
            }

            @Override
            public void onAnimationRepeat(Animation animation) {
            }

            @Override
            public void onAnimationEnd(Animation animation) {
                runImage.startAnimation(right);
            }
        });
        runImage.startAnimation(right);
</code></pre><h3 id="u63A7_u4EF6_u5DE6_u53F3_u6296_u52A8"><a href="#u63A7_u4EF6_u5DE6_u53F3_u6296_u52A8" class="headerlink" title="控件左右抖动"></a>控件左右抖动</h3><p>res下anim<br>animlayout.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;translate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:duration=&quot;1000&quot;
    android:fromXDelta=&quot;0&quot;
    android:interpolator=&quot;@anim/cycle_7&quot;
    android:toXDelta=&quot;10&quot; /&gt;
</code></pre><p>cycle_7.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;cycleInterpolator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
android:cycles=&quot;7&quot; /&gt;
</code></pre><p>(2)java代码</p>
<p>Animation shake = AnimationUtils.loadAnimation(<br>                        MainActivity.this, R.anim.animlayout);<br>                btn.setAnimation(shake);</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这份是我工作以来，总结的小知识库，有些知识点现在看来太LOW了，把还觉得有用的分享出来！</p>
<h3 id="Genymotion_u4E0B_u8F7D_u865A_u62DF_u955C_u50CFConnection_timeout"><a href="#Genymotion_u4E0B_u8F7D_u865A_u62DF_u955C_u50CFConnection_timeout" class="headerlink" title="Genymotion下载虚拟镜像Connection timeout"></a>Genymotion下载虚拟镜像Connection timeout</h3><p>Add new device出现的问题：</p>
<p>Failed to deploy virtual device.<br>Unable to create virtual device.Connection timeout occurred.</p>
<p>解决方案：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#24403;&#36873;&#25321;Google Nexus 5 - 6.0.0 - API 23 - 1080x1920&#19979;&#36733;device&#22833;&#36133;&#21518;&#65292;&#21040;C:\Users\&#29992;&#25143;&#20027;&#30446;&#24405;\AppData\Local\Genymobile\Genymotion\ova&#19979;&#30475;&#21040;genymotion_vbox86p_6.0_160114_090449.ova&#65292;&#22823;&#23567;&#21364;&#26159;0KB&#65292;&#22312;C:\Users\&#29992;&#25143;&#20027;&#30446;&#24405;\AppData\Local\Genymobile\genymotion.log&#65292;&#25171;&#24320;&#35813;&#25991;&#20214;&#65292;&#25214;&#21040;&#31867;&#20284;&#10;    &#10;    &#8220;http://files2.genymotion.com/dists/6.0.0/ova/genymotion_vbox86p_6.0_160114_090449.ova&#8221;&#36335;&#24452;&#65292;&#21363;&#24744;&#24819;&#35201;&#19979;&#36733;&#30340;&#38236;&#20687;&#25991;&#20214;URL&#65307;`&#10;&#10;&#29992;&#36805;&#38647;&#21435;&#19979;&#36733;&#65292;&#19979;&#36733;&#23436;&#25104;&#21518;&#25918;&#21040;C:\Users\&#29992;&#25143;&#20027;&#30446;&#24405;\AppData\Local\Genymobile\Genymotion\ova&#65307;&#10;&#37325;&#26032;&#28857;&#20987;Google Nexus 5 - 6.0.0 - API 23 - 1080x1920&#21435;&#19979;&#36733;&#65292;&#39564;&#35777;&#23433;&#35013;&#21518;&#21363;&#20250;&#26174;&#31034;&#22312;&#35774;&#22791;&#21015;&#34920;&#20013;&#12290;</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="知识库" scheme="http://apanda.club/tags/%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    
      <category term="技术" scheme="http://apanda.club/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Lambda for Android]]></title>
    <link href="http://apanda.club/2016/03/01/Android%20Skills/Lambda%20for%20Android/"/>
    <id>http://apanda.club/2016/03/01/Android Skills/Lambda for Android/</id>
    <published>2016-02-29T18:33:17.000Z</published>
    <updated>2016-04-06T04:28:28.000Z</updated>
    <content type="html"><![CDATA[<p>Lambda，它让代码看起来更加简洁，但个人认为代码的可读性差了很多，因此一直没有去深入学习。</p>
<h3 id="u4EC0_u4E48_u662Flambda"><a href="#u4EC0_u4E48_u662Flambda" class="headerlink" title="什么是lambda"></a>什么是lambda</h3><p>lambda是一种匿名表达式，retrolambda使得Android能使用lambda特性，举个例子：</p>
<pre><code>view.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View v) {
Log.d(&quot;wxl&quot;, &quot;retrolambda test&quot;);
}
});
</code></pre><p>使用 lambda</p>
<pre><code>view.setOnClickListener(
v -&gt; Log.d(&quot;wxl&quot;, &quot;retrolambda test&quot;));
</code></pre><h3 id="Android_u5982_u4F55_u4F7F_u7528"><a href="#Android_u5982_u4F55_u4F7F_u7528" class="headerlink" title="Android如何使用"></a>Android如何使用</h3><p>这里是使用Retrolambda的gradle插件，这样就可以在代码中使用lambda了。<br><a id="more"></a></p>
<h4 id="Android_Studio_u914D_u7F6ERetrolambda"><a href="#Android_Studio_u914D_u7F6ERetrolambda" class="headerlink" title="Android Studio配置Retrolambda"></a>Android Studio配置Retrolambda</h4><p>lambda需要安装JDK8，下载最新版本jdk-8u73</p>
<p>build.gradle</p>
<pre><code>buildscript {
    repositories {
             jcenter()
        }
        dependencies {
            classpath &apos;com.android.tools.build:gradle:1.5.0&apos;
            classpath &apos;me.tatarka:gradle-retrolambda:3.2.4&apos;//加上这句依赖，这会使用retrolambda来编译Java代码
    }
}
</code></pre><p>app/build.gradle</p>
<pre><code>apply plugin: &apos;com.android.application&apos;
apply plugin: &apos;me.tatarka.retrolambda&apos;//加上这句加,入plugin声明
android {
……
compileOptions {//使用JAVA8语法解析
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }
}
    retrolambda {//指定将源码编译的级别，使用下列代码，会将代码编译到兼容1.6的字节码格式
    javaVersion JavaVersion.VERSION_1_6
}
</code></pre><h4 id="Android_Studio_u81EA_u52A8_u751F_u6210lambda"><a href="#Android_Studio_u81EA_u52A8_u751F_u6210lambda" class="headerlink" title="Android Studio自动生成lambda"></a>Android Studio自动生成lambda</h4><p><img src="https://d7.usercdn.com/i/04033/9kdvn64rz5p9.png" alt=""></p>
<p>当配置Retrolambda成功后，Android Studio会有提示，按Alt+Enter键<br>hexo<br><img src="https://d7.usercdn.com/i/04033/8zt63yej4sql.png" alt=""></p>
<p>点击替换，这样就能自动生成，使用lambda了。到这里我就可以洗洗睡了，也很晚了，但为什么可以这样写呢，还是来简单了解lambda语法吧。<br>lambda语法简介</p>
<pre><code>input -&gt; body
</code></pre><h4 id="intput_u79CD_u7C7B"><a href="#intput_u79CD_u7C7B" class="headerlink" title="intput种类"></a>intput种类</h4><h5 id="u65E0_u8F93_u5165_void"><a href="#u65E0_u8F93_u5165_void" class="headerlink" title="无输入 void"></a>无输入 void</h5><pre><code>() -&gt; body

new Thread(new Runnable() {
@Override
public void run() {
Log.d(&quot;wxl&quot;, &quot;retrolambda test&quot;);
}
});
</code></pre><p>使用 lambda</p>
<pre><code>new Thread(() -&gt; Log.d(&quot;wxl&quot;, &quot;retrolambda test&quot;));
</code></pre><h5 id="u4E00_u4E2A_u53C2_u6570_u8F93_u5165"><a href="#u4E00_u4E2A_u53C2_u6570_u8F93_u5165" class="headerlink" title="一个参数输入"></a>一个参数输入</h5><pre><code>x -&gt; body

view.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View v) {
Log.d(&quot;wxl&quot;, &quot;retrolambda test&quot;);
}
});
</code></pre><p>使用 lambda</p>
<pre><code>view.setOnClickListener(
v -&gt; Log.d(&quot;wxl&quot;, &quot;retrolambda test&quot;));
</code></pre><h5 id="u591A_u4E2A_u53C2_u6570_u8F93_u5165"><a href="#u591A_u4E2A_u53C2_u6570_u8F93_u5165" class="headerlink" title="多个参数输入"></a>多个参数输入</h5><pre><code>(x, y) -&gt; x + y;

List&lt;String&gt; names = Arrays.asList(&quot;peter&quot;, &quot;anna&quot;, &quot;mike&quot;, &quot;xenia&quot;);
Collections.sort(names, new Comparator&lt;String&gt;() {
    @Override
    public int compare(String a, String b) {
        return b.compareTo(a);
    }
    });
    for (String name : names) {
    Log.d(&quot;wxl&quot;, name);
}
</code></pre><p>使用 lambda</p>
<pre><code>List&lt;String&gt; names = Arrays.asList(&quot;peter&quot;, &quot;anna&quot;, &quot;mike&quot;, &quot;xenia&quot;);
    Collections.sort(names, (a, b) -&gt; b.compareTo(a));
     for (String name : names) {
        Log.d(&quot;wxl&quot;, name);
}
</code></pre><h5 id="u4E0D_u7701_u7565_u578B_u5225"><a href="#u4E0D_u7701_u7565_u578B_u5225" class="headerlink" title="不省略型別"></a>不省略型別</h5><pre><code>(int x, int y) -&gt; x + y;
</code></pre><h4 id="body__u79CD_u7C7B"><a href="#body__u79CD_u7C7B" class="headerlink" title="body 种类"></a>body 种类</h4><h5 id="u4EC0_u9EBC_u90FD_u4E0D_u505A"><a href="#u4EC0_u9EBC_u90FD_u4E0D_u505A" class="headerlink" title="什麼都不做"></a>什麼都不做</h5><pre><code>() -&gt; {}
</code></pre><h5 id="u5355_u884C_u4E0D_u9700_u8981_u6709_u8FD4_u56DE_u503C_uFF0C_u5355_u884C_u53EF_u7701_u7565_7B_7D"><a href="#u5355_u884C_u4E0D_u9700_u8981_u6709_u8FD4_u56DE_u503C_uFF0C_u5355_u884C_u53EF_u7701_u7565_7B_7D" class="headerlink" title="单行不需要有返回值，单行可省略{}"></a>单行不需要有返回值，单行可省略{}</h5><pre><code>(x, y) -&gt; x + y;
</code></pre><h5 id="u5355_u884C_u9700_u8981_u6709_u8FD4_u56DE_u503C"><a href="#u5355_u884C_u9700_u8981_u6709_u8FD4_u56DE_u503C" class="headerlink" title="单行需要有返回值"></a>单行需要有返回值</h5><pre><code>(x, y) -&gt; x + y//注意没有分号结尾

Observable.just(&quot;Hello&quot;, &quot;RxJava&quot;)
.map(new Func1&lt;String, String&gt;() {
@Override
    public String call(String s) {
     return s.toUpperCase();
    }
});
</code></pre><p>使用 lambda</p>
<pre><code>Observable.just(&quot;Hello&quot;, &quot;RxJava&quot;)
.map(s -&gt; s.toUpperCase());
</code></pre><h5 id="u591A_u884C_u4E0D_u9700_u8981_u6709_u8FD4_u56DE_u503C"><a href="#u591A_u884C_u4E0D_u9700_u8981_u6709_u8FD4_u56DE_u503C" class="headerlink" title="多行不需要有返回值"></a>多行不需要有返回值</h5><pre><code>(x, y) -&gt;{
x x;
y y;
}
</code></pre><h5 id="u591A_u884C_u9700_u8981_u6709_u8FD4_u56DE_u503C"><a href="#u591A_u884C_u9700_u8981_u6709_u8FD4_u56DE_u503C" class="headerlink" title="多行需要有返回值"></a>多行需要有返回值</h5><pre><code>(x, y) -&gt;{
x x;
y y;
return x + y;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>Lambda，它让代码看起来更加简洁，但个人认为代码的可读性差了很多，因此一直没有去深入学习。</p>
<h3 id="u4EC0_u4E48_u662Flambda"><a href="#u4EC0_u4E48_u662Flambda" class="headerlink" title="什么是lambda"></a>什么是lambda</h3><p>lambda是一种匿名表达式，retrolambda使得Android能使用lambda特性，举个例子：</p>
<pre><code>view.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View v) {
Log.d(&quot;wxl&quot;, &quot;retrolambda test&quot;);
}
});
</code></pre><p>使用 lambda</p>
<pre><code>view.setOnClickListener(
v -&gt; Log.d(&quot;wxl&quot;, &quot;retrolambda test&quot;));
</code></pre><h3 id="Android_u5982_u4F55_u4F7F_u7528"><a href="#Android_u5982_u4F55_u4F7F_u7528" class="headerlink" title="Android如何使用"></a>Android如何使用</h3><p>这里是使用Retrolambda的gradle插件，这样就可以在代码中使用lambda了。<br>]]>
    
    </summary>
    
      <category term="Lambda" scheme="http://apanda.club/tags/Lambda/"/>
    
      <category term="技术" scheme="http://apanda.club/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[理解Android编译命令]]></title>
    <link href="http://apanda.club/2016/02/25/Android%20Skills/%E7%90%86%E8%A7%A3Android%E7%9A%84%E7%BC%96%E8%AF%91%E5%91%BD%E4%BB%A4/"/>
    <id>http://apanda.club/2016/02/25/Android Skills/理解Android的编译命令/</id>
    <published>2016-02-25T11:33:45.000Z</published>
    <updated>2016-04-06T11:04:55.000Z</updated>
    <content type="html"><![CDATA[<p>工欲善其事，必先利其器，对于想要深入学习Android源码，必须先掌握Android编译命令.</p>
<p>关于Android Build系统，这个话题很早就打算整理下，迟迟没有下笔，决定跟大家分享下。先看下面几条指令，相信编译过Android源码的人都再熟悉不过的。</p>
<p>source /opt/android1204_17.conf<br>source setenv.sh<br>lunch<br>make -j12<br><a id="more"></a></p>
<p>记得最初刚接触Android时，同事告诉我用上面的指令就可以编译Android源码，指令虽短但过几天就记不全或者忘记顺序，每次编译时还需要看看自己的云笔记，冰冷的指令总是难以让我记忆。后来我决定认真研究下这个指令的含义。知其然还需知其所以然，这样能更深层次的理解并记忆，才能与自身的知识体系建立强连接，或许还有意外收获，果然如此，接下来跟大家分享一下在研究上述几条指令含义的过程中，深入了解到的Android Build(编译)系统。</p>
<p>二、编译命令</p>
<p>准备好编译环境后，编译Android源码的第一步是 source build/envsetup.sh，其中source命令就是用于运行shell脚本命令，功能等价于”.”，因此该命令也等价于. build/envsetup.sh。在文件envsetup.sh声明了当前会话终端可用的命令，这里需要注意的是当前会话终端，也就意味着每次新打开一个终端都必须再一次执行这些指令。起初并不理解为什么新开的终端不能直接执行make指令，到这里总算明白了。</p>
<p>接下来，解释一下本文开头的引用的命令：</p>
<p>source /opt/android1204_17.conf  //初始化jdk环境变量（这个不是必需的，因厂商而异）<br>source setenv.sh  //初始化编译环境，包括后面的lunch和make指令<br>lunch  //指定此次编译的目标设备以及编译类型<br>make  -j12 //开始编译，默认为编译整个系统，其中-j12代表的是编译的job数量为12。</p>
<p>所有的编译命令都在envsetup.sh文件能找到相对应的function，比如上述的命令lunch，make，在文件一定能找到</p>
<p>function lunch{<br>…<br>}</p>
<p>function {<br>…<br>}</p>
<p>具体实现这里就不展开说明，下面精炼地总结了一下各个指令用法和功效。</p>
<p>2.1 代码编译</p>
<p>编译指令</p>
<p>解释</p>
<p>m</p>
<p>在源码树的根目录执行编译</p>
<p>mm</p>
<p>编译当前路径下所有模块，但不包含依赖</p>
<p>mmm [module_path]</p>
<p>编译指定路径下所有模块，但不包含依赖</p>
<p>mma</p>
<p>编译当前路径下所有模块，且包含依赖</p>
<p>mmma [module_path]</p>
<p>编译指定路径下所有模块，且包含依赖</p>
<p>make [module_name]</p>
<p>无参数，则表示编译整个Android代码</p>
<p>下面列举部分模块的编译指令：</p>
<p>模块</p>
<p>make命令</p>
<p>mmm命令</p>
<p>init</p>
<p>make init</p>
<p>mmm system/core/init</p>
<p>zygote</p>
<p>make app_process</p>
<p>mmm frameworks/base/cmds/app_process</p>
<p>system_server</p>
<p>make services</p>
<p>mmm frameworks/base/services</p>
<p>java framework</p>
<p>make framework</p>
<p>mmm frameworks/base</p>
<p>framework资源</p>
<p>make framework-res</p>
<p>mmm frameworks/base/core/res</p>
<p>jni framework</p>
<p>make libandroid_runtime</p>
<p>mmm frameworks/base/core/jni</p>
<p>binder</p>
<p>make libbinder</p>
<p>mmm frameworks/native/libs/binder</p>
<p>上述mmm命令同样适用于mm/mma/mmma，编译系统采用的是增量编译，只会编译发生变化的目标文件。当需要重新编译所有的相关模块，则需要编译命令后增加参数-B，比如make -B [module_name]，或者 mm -B [module_path]。</p>
<p>Tips:</p>
<ul>
<li>对于m、mm、mmm、mma、mmma这些命令的实现都是通过make方式来完成的。</li>
<li>mmm/mm编译的效率很高，而make/mma/mmma编译较缓慢；</li>
<li>make/mma/mmma编译时会把所有的依赖模块一同编译，但mmm/mm不会;</li>
<li>建议：首次编译时采用make/mma/mmma编译；当依赖模块已经编译过的情况，则使用mmm/mm编译。</li>
</ul>
<p>2.2 代码搜索</p>
<p>搜索指令</p>
<p>解释</p>
<p>cgrep</p>
<p>所有C/C++文件执行搜索操作</p>
<p>jgrep</p>
<p>所有Java文件执行搜索操作</p>
<p>ggrep</p>
<p>所有Gradle文件执行搜索操作</p>
<p>mangrep [keyword]</p>
<p>所有AndroidManifest.xml文件执行搜索操作</p>
<p>sepgrep [keyword]</p>
<p>所有sepolicy文件执行搜索操作</p>
<p>resgrep [keyword]</p>
<p>所有本地res/*.xml文件执行搜索操作</p>
<p>sgrep [keyword]</p>
<p>所有资源文件执行搜索操作</p>
<p>上述指令用法最终实现方式都是基于grep指令，各个指令用法格式：</p>
<p>xgrep [keyword]  //x代表的是上表的搜索指令</p>
<p>例如，搜索所有AndroidManifest.xml文件中的launcher关键字所在文件的具体位置，指令</p>
<p>mangrep launcher</p>
<p>再如，搜索所有system_app的selinux权限信息</p>
<p>sepgrep system_app</p>
<p>Tips: Android源码非常庞大，直接采用grep来搜索代码，不仅方法笨拙、浪费时间，而且搜索出很多无意义的混淆结果。根据具体需求，来选择合适的代码搜索指令，能节省代码搜索时间，提高搜索结果的精准度，方便定位目标代码。</p>
<p>2.3 导航指令</p>
<p>导航指令</p>
<p>解释</p>
<p>croot</p>
<p>切换至Android根目录</p>
<p>cproj</p>
<p>切换至工程的根目录</p>
<p>godir [filename]</p>
<p>跳转到包含某个文件的目录</p>
<p>Tips: 当每次修改完某个文件后需要编译时，执行cproj后会跳转到当前模块的根目录，也就是Android.mk文件所在目录，然后再执行mm指令，即可编译目标模块；当进入源码层级很深后，需要返回到根目录，使用croot一条指令完成；另外cd - 指令可用于快速切换至上次目录。</p>
<p>2.4 信息查询</p>
<p>查询指令</p>
<p>解释</p>
<p>hmm</p>
<p>查询所有的指令help信息</p>
<p>findmakefile</p>
<p>查询当前目录所在工程的Android.mk文件路径</p>
<p>print_lunch_menu</p>
<p>查询lunch可选的product</p>
<p>printconfig</p>
<p>查询各项编译变量值</p>
<p>gettop</p>
<p>查询Android源码的根目录</p>
<p>gettargetarch</p>
<p>获取TARGET_ARCH值</p>
<p>Tips: 当忘了前面的所有指令时，可以执行一个hmm便可输出这些指令的帮助信息。</p>
<p>其他指令：</p>
<ul>
<li>make clean：执行清理操作，等价于 rm -rf out/</li>
<li>make update-api：更新API，在framework API改动后需执行该指令，Api记录在目录frameworks/base/api；</li>
</ul>
<p>三、编译系统</p>
<p>Android 编译系统是Android源码的一部分，用于编译Android系统，Android SDK以及相关文档。该编译系统是由Make文件、Shell以及Python脚本共同组成，其中最为重要的便是Make文件。关于编译系统可参考 理解 Android Build 系统。</p>
<p>3.1 Makefile分类</p>
<p>整个Build系统的Make文件分为三大类：</p>
<ul>
<li>系统核心的Make文件：定义了Build系统的框架，文件全部位于路径/build/core，其他Make文件都是基于该框架编写的；</li>
<li>针对产品的Make文件：定义了具体某个型号手机的Make文件，文件路径位于/device，该目录下往往又以公司名和产品名划分两个子级目录，比如/device/qcom/msm8916；</li>
<li>针对模块的Make文件：整个系统分为各个独立的模块，每个模块都一个专门的Make文件，名称统一为”Android.mk”，该文件定义了当前模块的编译方式。Build系统会扫描整个源码树中名为”Android.mk”的问题，并执行相应模块的编译工作。</li>
</ul>
<p>3.2 编译产物</p>
<p>经过make编译后的产物，都位于/out目录，该目录下主要关注下面几个目录：</p>
<ul>
<li>/out/host：Android开发工具的产物，包含SDK各种工具，比如adb，dex2oat，aapt等。</li>
<li>/out/target/common：通用的一些编译产物，包含Java应用代码和Java库；</li>
<li>/out/target/product/[product_name]：针对特定设备的编译产物以及平台相关C/C++代码和二进制文件；</li>
</ul>
<p>在/out/target/product/[product_name]目录下，有几个重量级的镜像文件：</p>
<ul>
<li>system.img:挂载为根分区，主要包含Android OS的系统文件；</li>
<li>ramdisk.img:主要包含init.rc文件和配置文件等；</li>
<li>userdata.img:被挂载在/data，主要包含用户以及应用程序相关的数据；</li>
</ul>
<p>当然还有boot.img，reocovery.img等镜像文件，这里就不介绍了。</p>
<p>3.3 Android.mk解析</p>
<p>在源码树中每一个模块的所有文件通常都相应有一个自己的文件夹，在该模块的根目录下有一个名称为“Android.mk” 的文件。编译系统正是以模块为单位进行编译，每个模块都有唯一的模块名，一个模块可以有依赖多个其他模块，模块间的依赖关系就是通过模块名来引用的。也就是说当模块需要依赖一个jar包或者apk时，必须先将jar包或apk定义为一个模块，然后再依赖相应的模块。</p>
<p>对于Android.mk文件，通常都是以下面两行</p>
<p>LOCAL_PATH := $(call my-dir)  //设置当编译路径为当前文件夹所在路径<br>include $(CLEAR_VARS)  //清空编译环境的变量（由其他模块设置过的变量）</p>
<p>为方便模块编译，编译系统设置了很多的编译环境变量，如下：</p>
<ul>
<li>LOCAL_SRC_FILES：当前模块包含的所有源码文件；</li>
<li>LOCAL_MODULE：当前模块的名称（具有唯一性）；</li>
<li>LOCAL_PACKAGE_NAME：当前APK应用的名称（具有唯一性）；</li>
<li>LOCAL_C_INCLUDES：C/C++所需的头文件路径;</li>
<li>LOCAL_STATIC_LIBRARIES：当前模块在静态链接时需要的库名;</li>
<li>LOCAL_SHARED_LIBRARIES：当前模块在运行时依赖的动态库名;</li>
<li>LOCAL_STATIC_JAVA_LIBRARIES：当前模块依赖的Java静态库;</li>
<li>LOCAL_JAVA_LIBRARIES：当前模块依赖的Java共享库;</li>
<li>LOCAL_CERTIFICATE：签署当前应用的证书名称，比如flatform。</li>
<li>LOCAL_MODULE_TAGS：当前模块所包含的标签，可以包含多标签，可能值为debgu,eng,user,development或optional（默认值）</li>
</ul>
<p>针对这些环境变量，编译系统还定义了一些便捷函数，如下：</p>
<ul>
<li>$(call my-dir)：获取当前文件夹路径；</li>
<li>$(call all-java-files-under, )：获取指定目录下的所有Java文件；</li>
<li>$(call all-c-files-under, )：获取指定目录下的所有C文件；</li>
<li>$(call all-Iaidl-files-under, ) ：获取指定目录下的所有AIDL文件；</li>
<li><p>$(call all-makefiles-under, )：获取指定目录下的所有Make文件；</p>
<p>LOCAL_PATH = call my-dir)<br>include CLEAR_VARS)</p>
<h1 id="u83B7_u53D6_u6240_u6709_u5B50_u76EE_u5F55_u4E2D_u7684Java_u6587_u4EF6"><a href="#u83B7_u53D6_u6240_u6709_u5B50_u76EE_u5F55_u4E2D_u7684Java_u6587_u4EF6" class="headerlink" title="获取所有子目录中的Java文件"></a>获取所有子目录中的Java文件</h1><p>LOCAL_SRC_FILES = call all-subdir-java-files)</p>
<h1 id="u5F53_u524D_u6A21_u5757_u4F9D_u8D56_u7684_u52A8_u6001Java_u5E93_u540D_u79F0"><a href="#u5F53_u524D_u6A21_u5757_u4F9D_u8D56_u7684_u52A8_u6001Java_u5E93_u540D_u79F0" class="headerlink" title="当前模块依赖的动态Java库名称"></a>当前模块依赖的动态Java库名称</h1><p>LOCAL_JAVA_LIBRARIES = com.gityuan.lib</p>
<h1 id="u5F53_u524D_u6A21_u5757_u7684_u540D_u79F0"><a href="#u5F53_u524D_u6A21_u5757_u7684_u540D_u79F0" class="headerlink" title="当前模块的名称"></a>当前模块的名称</h1><p>LOCAL_MODULE = demo</p>
<h1 id="u5C06_u5F53_u524D_u6A21_u5757_u7F16_u8BD1_u6210_u4E00_u4E2A_u9759_u6001_u7684Java_u5E93"><a href="#u5C06_u5F53_u524D_u6A21_u5757_u7F16_u8BD1_u6210_u4E00_u4E2A_u9759_u6001_u7684Java_u5E93" class="headerlink" title="将当前模块编译成一个静态的Java库"></a>将当前模块编译成一个静态的Java库</h1><p>include BUILD_STATIC_JAVA_LIBRARY)</p>
</li>
</ul>
<p>如果觉得本文对您有所帮助，请关注我的微信公众号：gityuan， 微博：Gityuan。 或者点击这里查看更多关于gityuan个人信息</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>工欲善其事，必先利其器，对于想要深入学习Android源码，必须先掌握Android编译命令.</p>
<p>关于Android Build系统，这个话题很早就打算整理下，迟迟没有下笔，决定跟大家分享下。先看下面几条指令，相信编译过Android源码的人都再熟悉不过的。</p>
<p>source /opt/android1204_17.conf<br>source setenv.sh<br>lunch<br>make -j12<br>]]>
    
    </summary>
    
      <category term="编译" scheme="http://apanda.club/tags/%E7%BC%96%E8%AF%91/"/>
    
      <category term="技术" scheme="http://apanda.club/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Webview上传文件的那些坑]]></title>
    <link href="http://apanda.club/2016/02/22/Android%20Skills/Webview%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9D%91/"/>
    <id>http://apanda.club/2016/02/22/Android Skills/Webview上传文件的那些坑/</id>
    <published>2016-02-22T13:01:14.000Z</published>
    <updated>2016-02-22T05:35:13.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>要说Android中最厉害的组件莫过于Webview 了，夸张点说把这个组件放在屏幕上就可以算作一个简单地浏览器应用了。但你若认为这就万事大吉了，可太小看Webview这个磨人的妖精了，下面单就上传文件的这个坑来做展开。</p>
</blockquote>
<a id="more"></a>
<h3 id="u652F_u6301_u4E0A_u4F20_u6587_u4EF6"><a href="#u652F_u6301_u4E0A_u4F20_u6587_u4EF6" class="headerlink" title="支持上传文件"></a>支持上传文件</h3><p>Webview执行上传操作的逻辑是这样的：首先准备上传时会回调WebChromeClient类下的<code>openFileChooser</code>方法，在这个方法中给我们机会发起Intent来打开支持提供文件的第三方应用，最后在<code>onActivityResult</code>回调中将第三方应用提供的内容通过一个叫做<code>ValueCallback</code>的参数返回给<code>Webview</code>（详细点来说：ValueCallback是在openFileChooser 方法里由webview提供给我们的，里面包裹一个Uri，我们在<code>onActivityResult</code> 里将选中的Uri反馈给<code>ValueCallback</code>，这时候相当于Webview就知道我们选择了什么文件），因此，我们需要为<code>Webview</code>设置一个提供<code>openFileChooser</code>方法的<code>WebChromeClient</code>，这个方法在不同版本的<code>Android</code>中参数是不同的，为此我们一般需要写三个重载函数，大致像这个样子：</p>
<pre><code>private ValueCallback&lt;Uri&gt; mUploadMessage;
    //设置`WebChromeClient`:
webview.setWebChromeClient(new WebChromeClient(){
     public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg) {
            Log.d(TAG, &quot;openFileChoose(ValueCallback&lt;Uri&gt; uploadMsg)&quot;);
            mUploadMessage = uploadMsg;
            Intent i = new Intent(Intent.ACTION_GET_CONTENT);
            i.addCategory(Intent.CATEGORY_OPENABLE);
            i.setType(&quot;*/*&quot;);
            MainActivity.this.startActivityForResult(Intent.createChooser(i, &quot;File Chooser&quot;), FILECHOOSER_RESULTCODE);
      }
      public void openFileChooser( ValueCallback uploadMsg, String acceptType ) {
            Log.d(TAG, &quot;openFileChoose( ValueCallback uploadMsg, String acceptType )&quot;);
            mUploadMessage = uploadMsg;
            Intent i = new Intent(Intent.ACTION_GET_CONTENT);
            i.addCategory(Intent.CATEGORY_OPENABLE);
            i.setType(&quot;*/*&quot;);
            MainActivity.this.startActivityForResult(
                    Intent.createChooser(i, &quot;File Browser&quot;),
                    FILECHOOSER_RESULTCODE);
      }
      public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg, String acceptType, String capture){
            Log.d(TAG, &quot;openFileChoose(ValueCallback&lt;Uri&gt; uploadMsg, String acceptType, String capture)&quot;);
            mUploadMessage = uploadMsg;
            Intent i = new Intent(Intent.ACTION_GET_CONTENT);
            i.addCategory(Intent.CATEGORY_OPENABLE);
            i.setType(&quot;*/*&quot;);
            MainActivity.this.startActivityForResult( Intent.createChooser( i, &quot;File Browser&quot; ), MainActivity.FILECHOOSER_RESULTCODE );
        }
});

//onActivityResult回调   
@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        if(requestCode==FILECHOOSER_RESULTCODE)
         {
                if (null == mUploadMessage &amp;&amp; null == mUploadCallbackAboveL) return;
                 Uri result = data == null || resultCode != RESULT_OK ? null : data.getData();
                 if (mUploadMessage != null) {
                    mUploadMessage.onReceiveValue(result);
                    mUploadMessage = null;
               }
          }
       }
</code></pre><p>还有重要的一点：如果这个上传操作涉及到JS操作，别忘记对Webview开启对JS的支持：</p>
<pre><code>WebSettings settings = webview.getSettings();
settings.setJavaScriptEnabled(true);
</code></pre><h3 id="u4EE3_u7801_u6DF7_u6DC6"><a href="#u4EE3_u7801_u6DF7_u6DC6" class="headerlink" title="代码混淆"></a>代码混淆</h3><pre><code>-keepclassmembers class * extends android.webkit.WebChromeClient{
    public void openFileChooser(...);
}
</code></pre><h3 id="u517C_u5BB95-0"><a href="#u517C_u5BB95-0" class="headerlink" title="兼容5.0"></a>兼容5.0</h3><pre><code>webview.setWebChromeClient(new WebChromeClient(){
public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg) {
     ...
}
public void openFileChooser( ValueCallback uploadMsg, String acceptType ) {
       ...
}
public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg, String acceptType, String capture){
                ...
}

// For Android 5.0+
public boolean onShowFileChooser (WebView webView, ValueCallback&lt;Uri[]&gt; filePathCallback, WebChromeClient.FileChooserParams fileChooserParams) {
         mUploadCallbackAboveL = filePathCallback;
         Intent i = new Intent(Intent.ACTION_GET_CONTENT);
         i.addCategory(Intent.CATEGORY_OPENABLE);
         i.setType(&quot;*/*&quot;);
         MainActivity.this.startActivityForResult(
                    Intent.createChooser(i, &quot;File Browser&quot;),
                    FILECHOOSER_RESULTCODE);
         return true;
        }
});

@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {
    super.onActivityResult(requestCode, resultCode, data);
    if(requestCode==FILECHOOSER_RESULTCODE)
    {
        if (null == mUploadMessage &amp;&amp; null == mUploadCallbackAboveL) return;
        Uri result = data == null || resultCode != RESULT_OK ? null : data.getData();
        if (mUploadCallbackAboveL != null) {
            onActivityResultAboveL(requestCode, resultCode, data);
        }
        else  if (mUploadMessage != null) {
            mUploadMessage.onReceiveValue(result);
            mUploadMessage = null;
        }
    }
}
@TargetApi(Build.VERSION_CODES.LOLLIPOP)
private void onActivityResultAboveL(int requestCode, int resultCode, Intent data) {
    if (requestCode != FILECHOOSER_RESULTCODE
            || mUploadCallbackAboveL == null) {
        return;
    }
    Uri[] results = null;
    if (resultCode == Activity.RESULT_OK) {
        if (data == null) {
        } else {
            String dataString = data.getDataString();
            ClipData clipData = data.getClipData();
            if (clipData != null) {
                results = new Uri[clipData.getItemCount()];
                for (int i = 0; i &lt; clipData.getItemCount(); i++) {
                    ClipData.Item item = clipData.getItemAt(i);
                    results[i] = item.getUri();
                }
            }
            if (dataString != null)
                results = new Uri[]{Uri.parse(dataString)};
        }
    }
    mUploadCallbackAboveL.onReceiveValue(results);
    mUploadCallbackAboveL = null;
    return;
}
</code></pre><blockquote>
<p>代码转自: <a href="http://blog.saymagic.cn/2015/11/08/webview-upload.html" target="_blank" rel="external">http://blog.saymagic.cn/2015/11/08/webview-upload.html</a></p>
<p>源码地址: <a href="https://gitcafe.com/saymagic/Webviewdemo" target="_blank" rel="external">https://gitcafe.com/saymagic/Webviewdemo</a></p>
</blockquote>
<pre><code>* 说明:实际上我使用了该段代码只能够 完成5.0+的支持,对于5.0以下的机器支持的并不完美,比如说上传完成之后,并不能显示图片到目标位置.
</code></pre><ul>
<li>没办法继续爬文 终于发现了</li>
</ul>
<pre><code>package com.fuiou.webviewupload;
import java.io.File;
import android.app.Activity;
import android.app.AlertDialog;
import android.content.ContentValues;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.database.Cursor;
import android.graphics.Bitmap;
import android.net.Uri;
import android.os.Bundle;
import android.os.Environment;
import android.provider.MediaStore;
import android.util.Log;
import android.view.KeyEvent;
import android.webkit.ValueCallback;
import android.webkit.WebChromeClient;
import android.webkit.WebView;
import android.webkit.WebViewClient;
import android.widget.Toast;

public class MainActivity extends Activity {
    public static final String TAG = &quot;MainActivity&quot;;
    ValueCallback&lt;Uri&gt; mUploadMessage;
    private WebView mWebView;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        initView();
    }

    private void initView() {
        mWebView = (WebView) findViewById(R.id.web_view);
        mWebView.setWebChromeClient(new MyWebChromeClient());

        mWebView.setWebViewClient(new MyWebViewClient(this));
//        webView.loadUrl(&quot;file:///android_asset/upload_image.html&quot;);
        mWebView.loadUrl(&quot;http://192.168.72.62:8080/fileUpload&quot;);
    }


    private class MyWebViewClient extends WebViewClient{
        private Context mContext;
        public MyWebViewClient(Context context){
            super();
            mContext = context;
        }

        @Override
        public void onPageStarted(WebView view, String url, Bitmap favicon) {
            Log.d(TAG,&quot;URL地址:&quot; + url);
            super.onPageStarted(view, url, favicon);
        }

        @Override
        public void onPageFinished(WebView view, String url) {
            Log.i(TAG, &quot;onPageFinished&quot;);
            super.onPageFinished(view, url);
        }
    }

    public static final int FILECHOOSER_RESULTCODE = 1;
    private static final int REQ_CAMERA = FILECHOOSER_RESULTCODE+1;
    private static final int REQ_CHOOSE = REQ_CAMERA+1;

    private class MyWebChromeClient extends WebChromeClient {

        // For Android 3.0+
           public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg, String acceptType) {  
               if (mUploadMessage != null) return;
               mUploadMessage = uploadMsg;   
               selectImage();
//               Intent i = new Intent(Intent.ACTION_GET_CONTENT);
//               i.addCategory(Intent.CATEGORY_OPENABLE);
//               i.setType(&quot;*/*&quot;);
//                   startActivityForResult( Intent.createChooser( i, &quot;File Chooser&quot; ), FILECHOOSER_RESULTCODE );
           }
            // For Android &lt; 3.0
            public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg) {
                   openFileChooser( uploadMsg, &quot;&quot; );
            }
            // For Android  &gt; 4.1.1
          public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg, String acceptType, String capture) {
                  openFileChooser(uploadMsg, acceptType);
          }

    }

    /**
     * 检查SD卡是否存在
     *
     * @return
     */
    public final boolean checkSDcard() {
        boolean flag = Environment.getExternalStorageState().equals(
                Environment.MEDIA_MOUNTED);
        if (!flag) {
            Toast.makeText(this, &quot;请插入手机存储卡再使用本功能&quot;,Toast.LENGTH_SHORT).show();
        }
        return flag;
    }
    String compressPath = &quot;&quot;;

    protected final void selectImage() {
        if (!checkSDcard())
            return;
        String[] selectPicTypeStr = { &quot;camera&quot;,&quot;photo&quot; };
        new AlertDialog.Builder(this)
                .setItems(selectPicTypeStr,
                        new DialogInterface.OnClickListener() {
                            @Override
                            public void onClick(DialogInterface dialog,
                                    int which) {
                                switch (which) {
                                // 相机拍摄
                                case 0:
                                    openCarcme();
                                    break;
                                // 手机相册
                                case 1:
                                    chosePic();
                                    break;
                                default:
                                    break;
                                }
                                compressPath = Environment
                                        .getExternalStorageDirectory()
                                        .getPath()
                                        + &quot;/fuiou_wmp/temp&quot;;
                                new File(compressPath).mkdirs();
                                compressPath = compressPath + File.separator
                                        + &quot;compress.jpg&quot;;
                            }
                        }).show();
    }

    String imagePaths;
    Uri  cameraUri;
    /**
     * 打开照相机
     */
    private void openCarcme() {
        Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);

        imagePaths = Environment.getExternalStorageDirectory().getPath()
                + &quot;/fuiou_wmp/temp/&quot;
                + (System.currentTimeMillis() + &quot;.jpg&quot;);
        // 必须确保文件夹路径存在，否则拍照后无法完成回调
        File vFile = new File(imagePaths);
        if (!vFile.exists()) {
            File vDirPath = vFile.getParentFile();
            vDirPath.mkdirs();
        } else {
            if (vFile.exists()) {
                vFile.delete();
            }
        }
        cameraUri = Uri.fromFile(vFile);
        intent.putExtra(MediaStore.EXTRA_OUTPUT, cameraUri);
        startActivityForResult(intent, REQ_CAMERA);
    }

    /**
     * 拍照结束后
     */
    private void afterOpenCamera() {
        File f = new File(imagePaths);
        addImageGallery(f);
        File newFile = FileUtils.compressFile(f.getPath(), compressPath);
    }

    /** 解决拍照后在相册中找不到的问题 */
    private void addImageGallery(File file) {
        ContentValues values = new ContentValues();
        values.put(MediaStore.Images.Media.DATA, file.getAbsolutePath());
        values.put(MediaStore.Images.Media.MIME_TYPE, &quot;image/jpeg&quot;);
        getContentResolver().insert(
                MediaStore.Images.Media.EXTERNAL_CONTENT_URI, values);
    }

    /**
     * 本地相册选择图片
     */
    private void chosePic() {
        FileUtils.delFile(compressPath);
        Intent innerIntent = new Intent(Intent.ACTION_GET_CONTENT); // &quot;android.intent.action.GET_CONTENT&quot;
        String IMAGE_UNSPECIFIED = &quot;image/*&quot;;
        innerIntent.setType(IMAGE_UNSPECIFIED); // 查看类型
        Intent wrapperIntent = Intent.createChooser(innerIntent, null);
        startActivityForResult(wrapperIntent, REQ_CHOOSE);
    }

    /**
     * 选择照片后结束
     *
     * @param data
     */
    private Uri afterChosePic(Intent data) {

        // 获取图片的路径：
        String[] proj = { MediaStore.Images.Media.DATA };
        // 好像是android多媒体数据库的封装接口，具体的看Android文档
        Cursor cursor = managedQuery(data.getData(), proj, null, null, null);
        if(cursor == null ){
            Toast.makeText(this, &quot;上传的图片仅支持png或jpg格式&quot;,Toast.LENGTH_SHORT).show();
            return null;
        }
        // 按我个人理解 这个是获得用户选择的图片的索引值
        int column_index = cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DATA);
        // 将光标移至开头 ，这个很重要，不小心很容易引起越界
        cursor.moveToFirst();
        // 最后根据索引值获取图片路径
        String path = cursor.getString(column_index);
        if(path != null &amp;&amp; (path.endsWith(&quot;.png&quot;)||path.endsWith(&quot;.PNG&quot;)||path.endsWith(&quot;.jpg&quot;)||path.endsWith(&quot;.JPG&quot;))){
            File newFile = FileUtils.compressFile(path, compressPath);
            return Uri.fromFile(newFile);
        }else{
            Toast.makeText(this, &quot;上传的图片仅支持png或jpg格式&quot;,Toast.LENGTH_SHORT).show();
        }
        return null;
    }



    /**
     * 返回文件选择
     */
    @Override
    protected void onActivityResult(int requestCode, int resultCode,
            Intent intent) {
    //        if (requestCode == FILECHOOSER_RESULTCODE) {
    //            if (null == mUploadMessage)
    //                return;
    //            Uri result = intent == null || resultCode != RESULT_OK ? null
    //                    : intent.getData();
    //            mUploadMessage.onReceiveValue(result);
    //            mUploadMessage = null;
    //        }

        if (null == mUploadMessage)
            return;
        Uri uri = null;
        if(requestCode == REQ_CAMERA ){
            afterOpenCamera();
            uri = cameraUri;
        }else if(requestCode == REQ_CHOOSE){
            uri = afterChosePic(intent);
        }
        mUploadMessage.onReceiveValue(uri);
        mUploadMessage = null;
        super.onActivityResult(requestCode, resultCode, intent);
    }

    public boolean onKeyDown(int keyCode, KeyEvent event) {
        if ((keyCode == KeyEvent.KEYCODE_BACK) &amp;&amp; mWebView.canGoBack()) {  
            mWebView.goBack();  
            return true;  
        }else{
                finish();
        }
        return super.onKeyDown(keyCode, event);  
        }
}
</code></pre><p>根据这个哥们的代码进行精简,符合自己的需求,而且发现了这个代码的一个问题,没有能够进行判空操作,如果没有选择图片,直接返回APP会奔溃!</p>
<p>下面是我的开发源码:</p>
<pre><code>private class MyWebChromeClient extends WebChromeClient {


        // For Android 5.0+
        public boolean onShowFileChooser(WebView webView, ValueCallback&lt;Uri[]&gt; filePathCallback, WebChromeClient.FileChooserParams fileChooserParams) {
            mUploadCallbackAboveL = filePathCallback;
//            Intent i = new Intent(Intent.ACTION_GET_CONTENT);
//            i.addCategory(Intent.CATEGORY_OPENABLE);
//            i.setType(&quot;*/*&quot;);
//            HomePageViewActivity.this.startActivityForResult(
//                    Intent.createChooser(i, &quot;File Browser&quot;),
//                    FILECHOOSER_RESULTCODE);
            selectImage();
            return true;
        }


        //For Android 3.0+
        public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg, String acceptType) {
            if (mUploadMessage != null) return;
            mUploadMessage = uploadMsg;
            selectImage();
        }

        // For Android &lt; 3.0
        public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg) {
            if (mUploadMessage != null) return;
            mUploadMessage = uploadMsg;
            selectImage();
        }

        // For Android  &gt; 4.1.1
        public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg, String acceptType, String capture) {
            if (mUploadMessage != null) return;
            mUploadMessage = uploadMsg;
            selectImage();
        }


    }


    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        if (requestCode == FILECHOOSER_RESULTCODE) {
            if (null == mUploadMessage &amp;&amp; null == mUploadCallbackAboveL) return;
            Uri result = data == null || resultCode != RESULT_OK ? null : data.getData();
            if (mUploadCallbackAboveL != null) {
                onActivityResultAboveL(requestCode, resultCode, data);
            } else if (mUploadMessage != null) {
                mUploadMessage.onReceiveValue(result);
                mUploadMessage = null;
            }
        }


        if (null == mUploadMessage)
            return;
        Uri uri = null;
        if (requestCode == REQ_CHOOSE) {
            uri = afterChosePic(data);
        }
        mUploadMessage.onReceiveValue(uri);
        mUploadMessage = null;
        super.onActivityResult(requestCode, resultCode, data);
    }


    @TargetApi(Build.VERSION_CODES.LOLLIPOP)
    private void onActivityResultAboveL(int requestCode, int resultCode, Intent data) {
        if (requestCode != FILECHOOSER_RESULTCODE
                || mUploadCallbackAboveL == null) {
            return;
        }

        Uri[] results = null;
        if (resultCode == Activity.RESULT_OK) {
            if (data == null) {

            } else {
                String dataString = data.getDataString();
                ClipData clipData = data.getClipData();

                if (clipData != null) {
                    results = new Uri[clipData.getItemCount()];
                    for (int i = 0; i &lt; clipData.getItemCount(); i++) {
                        ClipData.Item item = clipData.getItemAt(i);
                        results[i] = item.getUri();
                    }
                }

                if (dataString != null)
                    results = new Uri[]{Uri.parse(dataString)};
            }
        }
        mUploadCallbackAboveL.onReceiveValue(results);
        mUploadCallbackAboveL = null;
        return;
    }


    /**
     * 检查SD卡是否存在
     *
     * @return
     */
    public final boolean checkSDcard() {
        boolean flag = Environment.getExternalStorageState().equals(
                Environment.MEDIA_MOUNTED);
        if (!flag) {
            Toast.makeText(this, &quot;请插入手机存储卡再使用本功能&quot;, Toast.LENGTH_SHORT).show();
        }
        return flag;
    }

    String compressPath = &quot;&quot;;

    protected final void selectImage() {
        if (!checkSDcard())
            return;

        chosePic();
        compressPath = Environment
                .getExternalStorageDirectory()
                .getPath()
                + &quot;/fuiou_wmp/temp&quot;;
        new File(compressPath).mkdirs();
        compressPath = compressPath + File.separator
                + &quot;compress.jpg&quot;;
    }


    /**
     * 本地相册选择图片
     */
    private void chosePic() {
        FileUtils.delFile(compressPath);
        Intent innerIntent = new Intent(Intent.ACTION_GET_CONTENT); // &quot;android.intent.action.GET_CONTENT&quot;
        String IMAGE_UNSPECIFIED = &quot;image/*&quot;;
        innerIntent.setType(IMAGE_UNSPECIFIED); // 查看类型
        Intent wrapperIntent = Intent.createChooser(innerIntent, null);
        startActivityForResult(wrapperIntent, REQ_CHOOSE);
    }

    /**
     * 选择照片后结束
     *
     * @param data
     */
    private Uri afterChosePic(Intent data) {

        if (data != null) {
            // 获取图片的路径：
            String[] proj = {MediaStore.Images.Media.DATA};
            // 好像是android多媒体数据库的封装接口，具体的看Android文档
            Cursor cursor = managedQuery(data.getData(), proj, null, null, null);
//        if (cursor == null) {
//            Toast.makeText(this, &quot;上传的图片仅支持png或jpg格式&quot;, Toast.LENGTH_SHORT).show();
//            return null;
//        }
            // 按我个人理解 这个是获得用户选择的图片的索引值
            int column_index = cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DATA);
            // 将光标移至开头 ，这个很重要，不小心很容易引起越界
            cursor.moveToFirst();
            // 最后根据索引值获取图片路径
            String path = cursor.getString(column_index);
//            if (path != null &amp;&amp; (path.endsWith(&quot;.png&quot;) || path.endsWith(&quot;.PNG&quot;) || path.endsWith(&quot;.jpg&quot;) || path.endsWith(&quot;.JPG&quot;))) {
//            } else {
//                Toast.makeText(this, &quot;上传的图片仅支持png或jpg格式&quot;, Toast.LENGTH_SHORT).show();
//            }
            File newFile = FileUtils.compressFile(path, compressPath);
            return Uri.fromFile(newFile);
        }
        return null;
    }
</code></pre><p>都目前位置 问题得到完美的解决!!</p>
<p>参考:<a href="http://blog.isming.me/2015/12/21/android-webview-upload-file/" target="_blank" rel="external">http://blog.isming.me/2015/12/21/android-webview-upload-file/</a><br><a href="http://www.huochai.mobi/p/d/900504/?share_tid=846ea82e2685&amp;fmid=0" target="_blank" rel="external">http://www.huochai.mobi/p/d/900504/?share_tid=846ea82e2685&amp;fmid=0</a><br><a href="http://www.lai18.com/content/1191983.html" target="_blank" rel="external">http://www.lai18.com/content/1191983.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>要说Android中最厉害的组件莫过于Webview 了，夸张点说把这个组件放在屏幕上就可以算作一个简单地浏览器应用了。但你若认为这就万事大吉了，可太小看Webview这个磨人的妖精了，下面单就上传文件的这个坑来做展开。</p>
</blockquote>]]>
    
    </summary>
    
      <category term="Webview" scheme="http://apanda.club/tags/Webview/"/>
    
      <category term="技术" scheme="http://apanda.club/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android源码编译和内核编译]]></title>
    <link href="http://apanda.club/2016/02/21/Android%20Skills/Android%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/"/>
    <id>http://apanda.club/2016/02/21/Android Skills/Android源码编译/</id>
    <published>2016-02-21T06:33:45.000Z</published>
    <updated>2016-02-26T07:27:49.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u6E90_u7801_u7F16_u8BD1"><a href="#u6E90_u7801_u7F16_u8BD1" class="headerlink" title="源码编译"></a>源码编译</h2><h4 id="1_u3001_u7CFB_u7EDF_uFF1A_Ubuntu14-04_u4EE5_u4E0A__u6216_u8005_Mac"><a href="#1_u3001_u7CFB_u7EDF_uFF1A_Ubuntu14-04_u4EE5_u4E0A__u6216_u8005_Mac" class="headerlink" title="1、系统： Ubuntu14.04以上 或者 Mac"></a>1、系统： Ubuntu14.04以上 或者 Mac</h4><blockquote>
<p>下面的介绍都是在ubuntu下进行的</p>
</blockquote>
<h4 id="2_u3001JdK_u5B89_u88C5"><a href="#2_u3001JdK_u5B89_u88C5" class="headerlink" title="2、JdK安装"></a>2、JdK安装</h4><pre><code>$ sudo add-apt-repository &quot;deb http://archive.canonical.com/ lucid partner&quot;
$ sudo apt-get update
$ sudo apt-get install sun-java8-jdk
</code></pre><a id="more"></a> 
<h4 id="3_u3001_u5FC5_u5907_u8F6F_u4EF6_u5305_u5B89_u88C5"><a href="#3_u3001_u5FC5_u5907_u8F6F_u4EF6_u5305_u5B89_u88C5" class="headerlink" title="3、必备软件包安装"></a>3、必备软件包安装</h4><pre><code>$ sudo apt-get install git-core gnupg flex bison gperf build-essential \
  zip curl zlib1g-dev libc6-dev lib32ncurses5-dev ia32-libs \
  x11proto-core-dev libx11-dev lib32readline5-dev lib32z-dev \
  libgl1-mesa-dev g++-multilib mingw32 tofrodos python-markdown \
  libxml2-utils
</code></pre><h4 id="uFF14__u4E0B_u8F7Drepo_u5DE5_u5177"><a href="#uFF14__u4E0B_u8F7Drepo_u5DE5_u5177" class="headerlink" title="４　下载repo工具"></a>４　下载repo工具</h4><pre><code>$ cd ~
$ mkdir ~/bin
$ PATH=~/bin:$PATH
$ curl https://dl-ssl.google.com/dl/googlesource/git-repo/repo &gt; ~/bin/repo
$ chmod a+x ~/bin/repo
</code></pre><h4 id="uFF15__u4E0B_u8F7D_u6E90_u7801"><a href="#uFF15__u4E0B_u8F7D_u6E90_u7801" class="headerlink" title="５　下载源码"></a>５　下载源码</h4><blockquote>
<p>注意，下面最后一条命令，-b 后面的 Gingerbread 可以替换成 IceCreamSandwich 或者是 Froyo 中的任何一个。当然，还有其它选择，这个名字，就是 Android 版本的英文名，<a href="http://source.android.com/source/build-numbers.html" target="_blank" rel="external">http://source.android.com/source/build-numbers.html</a> 里面有所有的名字</p>
</blockquote>
<pre><code>$ mkdir CMROM
$ cd CMROM
$ repo init -u git://github.com/CyanogenMod/android.git
</code></pre><blockquote>
<p>如果是使用Google官方的源码编译</p>
</blockquote>
<pre><code>$ repo init -u https://android.googlesource.com/platform/manifest -b [Gingerbread]

[?]部分是Android的版本名称--详见http://source.android.com/source/build-numbers.html
</code></pre><ul>
<li>注意事项</li>
</ul>
<blockquote>
<p>默认情况下，访问Android源码是匿名的，为了防止下载服务器压力过大，下载服务器对每个ip都有下载限制。如果和别人共享一个公网IP(和别人共享路由器时，便是如此),Android源码服务器便会阻止多人同时下载，容易报错。为了解决该问题，需要使用带授权的访问，源码服务器此时对用户进行限制，而不是对ip进行限制。方法如下：<br>先创建密码：<a href="https://android.googlesource.com/new-password" target="_blank" rel="external">https://android.googlesource.com/new-password</a><br>该地址也经常无法访问，需多次尝试(可相隔几分钟)，若使用代理，就没法获得有用的密钥<br>再将密码保存在~/.netrc里<br>然后强制使用带授权的访问：<br> $repo init -u <a href="https://android.googlesource.com/a/platform/manifest" target="_blank" rel="external">https://android.googlesource.com/a/platform/manifest</a><br>在国内用repo初始化时，会经常遇到101的错误，因为有墙的原因，重试多次，运气好时便可以完成，设置代理的话会更顺利一点</p>
</blockquote>
<ul>
<li><p>源代码的目录结构</p>
<p>  在讲述Android源码编译的三个步骤之前，将先介绍Android源码目录结构，以便读者理清Android编译系统核心代码在Android源代码的位置。<br>Android源代码顶层目录结构如下所示：</p>
<p>../CyanogenMod/</p>
<pre><code>├──abi#应用二进制接口，不同的操作系统，应用二进制接口不同，因此linux上的二进制可执行文件在windows上无法执行
├──android#存放了一些xml文件，用于描述工程路径及其对应的远程仓库地址，repo工具将使用这些信息同步代码
├──bionic#bionic C库,Android没有使用标准的glibc库，而是自己重新实现了一套c/C++库，包括libc libdl libm libstdc++ libthread_db
├──bootable# 包含两个工程，recovery和diskinstaller，刷机或者系统升级都是由recovery完成的，
├──build#Android编译系统核心代码都存放在该目录，我们也将对该目录下的文件做详细分析
├──cts#Android兼容性测试套件标准
├──dalvik#dalvik JAVA虚拟机，Android用的java虚拟机和pc上用的jvm不一样
├──development#应用程序开发工具 有eclipse开发用的formatter配置
├──device#设备相关配置文件，存放规则 device/$vendor/$product
├──docs#网站文档
├──external#用到的第三方库 象busybox bash openssl等工具都存放在该目录
├──filelist#使用godir命令生成的索引文件
├──frameworks#核心框架——java及C++语言，可生成framework.jar
├──gdk#glass开发Sdk
├──hardware#部分厂家开源的硬件适配层HAL代码
├──kernel#内核源码目录 存放规则kernel/$vendor/$product
├──libcore#一些有用的库 像xml Jason luni
├──libnativehelper#Support functions for Android’s class libraries
├──Makefile#在顶层目录编译，利用的默认Makefile，它只是简单包含了build/core/main.mk
├──ndk#ndk开发工具
├──packages#Android apk程序所在目录,象settings，gallery等程序
├──pdk#Platform Development Kit The goal of the PDK release is to help chipset vendors and OEMs to migrate to a new relelase
├──prebuilt#x86和arm架构下预编译的一些资源
├──prebuilts#有clang eclipse gcc misc ndk qemu-kernel sdk tools等子目录，交叉编译工具链所在目录
├──sdk#sdk及模拟器
├──system#核心代码，包含了最小化可启动的环境，还有底层调试及检查工具，adbd也在system/core目录
├──tools#有子目录build和motodev，可能跟摩托罗拉有关
├──vendor#设备制造商专用的配置存放目录，存放规则vendor/$vendor/$product，cm编写的apk也放在该目录
</code></pre><p>build子目录存放编译系统的核心代码，包含着138个makefile，15个shell脚本，19个python脚本，7个C文件，7个C++文件，16个头文件，因此如果想分析编译系统核心代码，使用的IDE需支持这些编程语言，推荐使用eclipse，安装一些插件就可以很方便地查看这些代码<br>build子文件夹的目录结构如下所示：<br>build/</p>
<pre><code>├── buildspec.mk.default#buildspec的模版文件，可定义一些变量比如TARGET_BUILD_VARIANT:=user，TARGET_BUILD_TYPE:=release
├── CleanSpec.mk#增量编译时，会执行该文件里的命令，这些命令一般用于清除中间文件
├── core#编译系统的核心文件放在该目录，主要是一些makefile
├── envsetup.sh#编译时需先用source envsetup.sh设置好环境变量，该脚本提供了许多有用的命令，比如cout,croot,cgrep,在详细介绍Android编译步骤时会列出来
├── libs#是一个C++模块，编译后可生成libhost.a静态库，里面的函数主要用于与编译主机交互
├── target#包含编译目标相关的makefile，它有两个子文件夹 board和product，产品都在该目录下定义，比如generic,full产品，定义设备产品时，会从这里继承产品
└── tools#各种工具，多数使用python编写，工具有用于签名的signpak, 用于下载device配置的roomservice.py等，后续将详细介绍
</code></pre><p>我们在阅读build核心代码时，可能最头疼的就是变量，编译系统里有成百上千的变量，我们常常不知道其含义，容易一头雾水，为此我做了一个编译系统的参考手册供大家查阅， 可以很方便地检索变量，查看变量的意义，并有示例值。链接：<a href="http://android.cloudchou.com/" target="_blank" rel="external">http://android.cloudchou.com/</a></p>
</li>
</ul>
<h4 id="uFF16__u540C_u6B65_u6E90_u7801"><a href="#uFF16__u540C_u6B65_u6E90_u7801" class="headerlink" title="６　同步源码"></a>６　同步源码</h4><blockquote>
<p>别看只有一条命令，但是，下载的时间，很长的，推荐这条命令，晚上的时候，挂机执行，第二天早上，差不多能下载完。毕竟是 3GB 多的东西呢。</p>
</blockquote>
<pre><code>$ repo sync -j 10
</code></pre><ul>
<li>注意事项<blockquote>
<p>在工作目录里使用repo sync同步代码，期间可能会多次卡死，需要ctrl+z，然后杀掉进程，然后再次使用repo sync，因为其支持断点续传，不需要担心会从头开始下载 还可以开启多个进程同时下载，使用repo sync -j4<br>j4代表开启4个线程,建议i5以上的开4,i7开8</p>
</blockquote>
</li>
</ul>
<h4 id="4-_u7F16_u8BD1_u6E90_u4EE3_u7801"><a href="#4-_u7F16_u8BD1_u6E90_u4EE3_u7801" class="headerlink" title="4.编译源代码"></a>4.编译源代码</h4><ul>
<li><p>初始化编译环境</p>
<pre><code>$source build/envsetup.sh
</code></pre></li>
</ul>
<ul>
<li><p>选择一个目标设备，以cm下编译htc one为例</p>
<pre><code>$lunch cm_m7ul-eng
</code></pre></li>
<li><p>此时会从网站下载m7ul的device配置以及内核源代码<br>所有目标设备的格式为BUILD-BUILDTYPE， BUILD是选择的目标设备，比如cm_m7,而BUILD_TYPE是eng，user或者userdebug</p>
<pre><code>user: 适合发布产品时使用，访问受限
userdebug: 和user类型类似，有root权限和调试能力，适合调试
eng: 开发配置，有额外的调试工具
</code></pre></li>
<li><p>编译源代码：</p>
<pre><code>$mka
</code></pre></li>
</ul>
<h2 id="u5185_u6838_u7F16_u8BD1"><a href="#u5185_u6838_u7F16_u8BD1" class="headerlink" title="内核编译"></a>内核编译</h2><h4 id="uFF11__u4E0B_u8F7D_u5185_u6838_u6E90_u7801"><a href="#uFF11__u4E0B_u8F7D_u5185_u6838_u6E90_u7801" class="headerlink" title="１　下载内核源码"></a>１　下载内核源码</h4><p>　　每一个 Android 手机厂商，都会在自己的网站上公布已经生产的手机的内核源码，大家去小米手机的官方网站下载即可。</p>
<h4 id="uFF12__u89E3_u538B_u5185_u6838_u6E90_u7801_u5305"><a href="#uFF12__u89E3_u538B_u5185_u6838_u6E90_u7801_u5305" class="headerlink" title="２　解压内核源码包"></a>２　解压内核源码包</h4><p>　　内核源码，一般是以压缩包的形式提供下载的。大家下载之后，在 Ubuntu 中解压即可，因为命令非常简单，这里不提供。</p>
<h4 id="uFF13__u914D_u7F6E_u4EA4_u53C9_u5DE5_u5177_u94FE_uFF08_u7F16_u8BD1_u5668_uFF09_u8DEF_u5F84"><a href="#uFF13__u914D_u7F6E_u4EA4_u53C9_u5DE5_u5177_u94FE_uFF08_u7F16_u8BD1_u5668_uFF09_u8DEF_u5F84" class="headerlink" title="３　配置交叉工具链（编译器）路径"></a>３　配置交叉工具链（编译器）路径</h4><p>　　学过编程的人都知道，源码要编译成程序，必须要用编译器编译。而且手机的 CPU 不同于 PC 机，所以，得用专用的工具，即“交叉工具链”。<br>　　打开内核源码目录下的 Makefile 文件，找到“CROSS_COMPILE”定义的地方，确保和下面一模一样。</p>
<pre><code>CROSS_COMPILE := $(shell if [ -f .cross_compile ]; then \
    cat .cross_compile; \
    fi)
</code></pre><p>　　接着，在内核源码目录下面，新建一个叫“.cross_compile”的文件，在文件中，输入以下分隔线中间的一行内容</p>
<pre><code>/（这前面，是 Android 源码的绝对路径，要求您有一点 Ubuntu 使用经验，否则不能完成）/ANDROID_SRC/prebuilt/linux-x86/toolchain/arm-eabi-4.4.0/bin/arm-eabi-
</code></pre><p>　　打开已经下载的 Android 源码（前面有提到如何下载）目录，在 ANDROID_SRC/prebuilt/linux-x86/toolchain 下面，你会发现有几个工具链文件夹，名字为别是 arm-eabi-4.2.1（4.3.1，4.4.0，4.4.3），如果，你是用 64位 系统，用哪个都可以。如果是 32位 系统，貌似用 4.4.3 会出错。建议用 4.4.0。<br>　注：ANDROID_SRC 是指您电脑上，Android 源码存储的目录，请根据实际情况，进行替换。</p>
<h4 id="uFF14__u201C-config_u201D_u914D_u7F6E_u6587_u4EF6"><a href="#uFF14__u201C-config_u201D_u914D_u7F6E_u6587_u4EF6" class="headerlink" title="４　“.config”配置文件"></a>４　“.config”配置文件</h4><p>　　在内核源码的目录下面，一定要有一个名字为“.config”的文件，这个文件，是小米手机的内核配置。如果内核源码的根目录下，没有发现这个文件，或者，发现的文件不是针对小米手机配置的，在 LINUX_SRC/arch/arm/configs 下面，找到针对小米手机的配置文件，复制到内核源码根目录，即可。<br>　注：LINUX_SRC 是指您电脑上，内核源码存储的目录，请根据实际情况，进行替换。</p>
<h4 id="uFF15__u9009_u62E9_u5185_u6838_u914D_u7F6E_u9009_u9879"><a href="#uFF15__u9009_u62E9_u5185_u6838_u914D_u7F6E_u9009_u9879" class="headerlink" title="５　选择内核配置选项"></a>５　选择内核配置选项</h4><pre><code>$ cd LINUX_SRC
$ make config
</code></pre><p>这里的config文件,是在内核源码根目录下的 config文件,如果没有直接名称为config文件的,看看是否有前缀,例如:menuconfig<br>　　输入上面的命令后，会出现一个怪怪的列表，通过按“空格键”，进行“选择”或“取消”某些选项。完成后，记得保存。<br>　注：在手机使用中，有的用户总抱怨不能使用“Wifi Tether”，不能“使用笔记本共享出来的宽带上网”，都是因为这一步，内核的选项没有被正确设置。读完这篇文章之后，大家可以自己动手了。</p>
<h4 id="uFF16__u201C_u6700_u540E_u4E00_u6B65_u201D"><a href="#uFF16__u201C_u6700_u540E_u4E00_u6B65_u201D" class="headerlink" title="６　“最后一步”"></a>６　“最后一步”</h4><pre><code>$ cd LINUX_SRC
$ make
</code></pre><p>　编译完成之后，会在“kernel/goldfish/arch/arm/boot/”目录下生成名为zImage的文件。 </p>
<h2 id="u7528_u5230_u7684_u547D_u4EE4"><a href="#u7528_u5230_u7684_u547D_u4EE4" class="headerlink" title="用到的命令"></a>用到的命令</h2><h4 id="u4E0B_u8F7DAndroid_u6E90_u7801_u7B80_u8981_u6D41_u7A0B"><a href="#u4E0B_u8F7DAndroid_u6E90_u7801_u7B80_u8981_u6D41_u7A0B" class="headerlink" title="下载Android源码简要流程"></a>下载Android源码简要流程</h4><pre><code>a. 获取repo文件: curl http://commondatastorage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo .注意执行该文件需要python2.5以上版本,如果是2.4.3的python版本就无法执行这个文件脚本;
b. 修改repo权限 : chmod a+x ~/bin/repo , 如果repo没有执行权限, 该脚本也无法执行;
c. 初始化repo文件 : repo init -u https://android.googlesource.com/platform/manifest -b android-2.3.3_r1 , 这里要下载2.3.3版本的源码;
d. 开始下载 :repo sync , 执行该命令就可以开始下载Android源码;
</code></pre><h4 id="u4E0B_u8F7DAndroid_u5185_u6838_u6E90_u7801_u7B80_u8981_u6D41_u7A0B"><a href="#u4E0B_u8F7DAndroid_u5185_u6838_u6E90_u7801_u7B80_u8981_u6D41_u7A0B" class="headerlink" title="下载Android内核源码简要流程"></a>下载Android内核源码简要流程</h4><pre><code>a. 使用git下载 : git clone https://android.googlesource.com/kernel/goldfish.git ;
b. 查看分支 : git branch -a ;
c. 检出版本 : git checkout remotes/origin/android-goldfish-2.6.29 ;
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u6E90_u7801_u7F16_u8BD1"><a href="#u6E90_u7801_u7F16_u8BD1" class="headerlink" title="源码编译"></a>源码编译</h2><h4 id="1_u3001_u7CFB_u7EDF_uFF1A_Ubuntu14-04_u4EE5_u4E0A__u6216_u8005_Mac"><a href="#1_u3001_u7CFB_u7EDF_uFF1A_Ubuntu14-04_u4EE5_u4E0A__u6216_u8005_Mac" class="headerlink" title="1、系统： Ubuntu14.04以上 或者 Mac"></a>1、系统： Ubuntu14.04以上 或者 Mac</h4><blockquote>
<p>下面的介绍都是在ubuntu下进行的</p>
</blockquote>
<h4 id="2_u3001JdK_u5B89_u88C5"><a href="#2_u3001JdK_u5B89_u88C5" class="headerlink" title="2、JdK安装"></a>2、JdK安装</h4><pre><code>$ sudo add-apt-repository &quot;deb http://archive.canonical.com/ lucid partner&quot;
$ sudo apt-get update
$ sudo apt-get install sun-java8-jdk
</code></pre>]]>
    
    </summary>
    
      <category term="源码" scheme="http://apanda.club/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="技术" scheme="http://apanda.club/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Kotlin 1.0 正式版发布啦]]></title>
    <link href="http://apanda.club/2016/02/18/New%20Lan/Kotlin1.0%E6%AD%A3%E5%BC%8F%E7%89%88%E5%8F%91%E5%B8%83/"/>
    <id>http://apanda.club/2016/02/18/New Lan/Kotlin1.0正式版发布/</id>
    <published>2016-02-18T15:01:14.000Z</published>
    <updated>2016-04-07T03:45:13.000Z</updated>
    <content type="html"><![CDATA[<p>就在昨天，Android领域的Swift–Kotlin 1.0发布了，详细的新版本发布介绍请「阅读原文」查看官方发行说明。</p>
<h3 id="u4F55_u4E3AKotlin_uFF1F"><a href="#u4F55_u4E3AKotlin_uFF1F" class="headerlink" title="何为Kotlin？"></a>何为Kotlin？</h3><p>Kotlin 是一门实用的编程语言，可用于 JVM 和 Android 程序开发，Kotlin 结合了面向对象和函数式特性，致力于互操作性，安全，简洁和工具支持。</p>
<p>Kotlin 是一门通用的语言，只要能用 Java 的地方就能用 Kotlin，包含：服务器程序开发，移动应用开发（Android），桌面客户端程序开发。 Kotlin 支持所有主要的开发工具以及服务，比如：</p>
<pre><code>IntelliJ IDEA，Android Studio 和 Eclipse
Maven, Gradle 和Ant
Spring Boot（Kotlin 支持今天正式发布！）
GitHub，Slack，甚至 Minecraft
</code></pre><a id="more"></a>
<p>Kotlin 的主要特点之一是Java+Kotlin 混合工程的互操作性以及无缝兼容，使引入Kotlin的过程简单容易，并达成更少的重复性代码(boilerplate code)和更佳的类型安全(type-safety)。<br>Kotlin 还有一个扩展标准库(extensive standard library)能让日常工作变得简单顺畅，它能帮助保持低内存占用 (bytecode footprint)。当然，Kotlin 中自然可以使用 Java 库，反之亦然。</p>
<h3 id="u4E3A_u4F55_u8BF4Kotlin_u975E_u5E38_u9002_u5408_u4E8EAndroid_uFF1F"><a href="#u4E3A_u4F55_u8BF4Kotlin_u975E_u5E38_u9002_u5408_u4E8EAndroid_uFF1F" class="headerlink" title="为何说Kotlin非常适合于Android？"></a>为何说Kotlin非常适合于Android？</h3><p>基本上，这是因为Kotlin的所有特性都非常适合于Android生态圈。Kotlin的库非常小，我们在开发过程中不会引入额外的成本。其大小 相当于support-v4库，我们在很多项目中所使用的库都比Kotlin大。除此之外，Android Studio（官方的Android IDE）是基于IntelliJ构建的。这意味着我们的IDE对该语言提供了非常棒的支持。我们可以很快就配置好项目，并且使用熟悉的IDE进行开发。我 们可以继续使用Gradle以及IDE所提供的各种运行与调试特性。这与使用Java开发应用别无二致。归功于互操作性，我们可以在Kotlin代码中使 用Android SDK而不会遇到任何问题。实际上，部分SDK使用起来会变得更加简单，这是因为互操作性是非常智能的，比如说它可以将getters与setters映 射到Kotlin属性上，我们也可以以闭包的形式编写监听器。</p>
<h3 id="u5982_u4F55_u5728Android_u5F00_u53D1_u4E2D_u4F7F_u7528Kotlin_uFF1F"><a href="#u5982_u4F55_u5728Android_u5F00_u53D1_u4E2D_u4F7F_u7528Kotlin_uFF1F" class="headerlink" title="如何在Android开发中使用Kotlin？"></a>如何在Android开发中使用Kotlin？</h3><p>过程非常简单，只需按照下面的步骤来即可：</p>
<blockquote>
<p>从IDE plugins中下载Kotlin插件<br>在模块中创建Kotlin类<br>使用“Configure Kotlin in Project…”<br>开始编码</p>
</blockquote>
<h3 id="Kotlin_u7684_u4E00_u4E9B_u7279_u6027"><a href="#Kotlin_u7684_u4E00_u4E9B_u7279_u6027" class="headerlink" title="Kotlin的一些特性"></a>Kotlin的一些特性</h3><p>Kotlin拥有大量非常打动人心的特性，这里无法一一进行介绍，不过我们来看一下其中最为重要的一些。</p>
<h4 id="Null_u5B89_u5168"><a href="#Null_u5B89_u5168" class="headerlink" title="Null安全"></a>Null安全</h4><p>如前所述，Kotlin是null安全的。如果一个类型可能为null，那么我们就需要在类型后面加上一个?。这样，每次在使用该类型的变量时，我们都需要进行null检查。比如说，如下代码将无法编译通过：</p>
<pre><code>var artist: Artist? = null?
artist.print()
</code></pre><p>第2行会显示一个错误，因为没有对变量进行null检查。我们可以这样做：</p>
<pre><code>if (artist != null) {
?    artist.print()?
}
</code></pre><p>这展示了Kotlin另一个出色的特性：智能类型转换。如果检查了变量的类型，那就无需在检查作用域中对其进行类型转换。这样，我们现在就可以在 if中将artist作为Artist类型的变量了。这对于其他检查也是适用的。还有一种更简单的方式来检查null，即在调用对象的函数前使用?。甚至 还可以通过Elvis运算符?提供另外一种做法：</p>
<pre><code>val name = artist?.name ?: &quot;&quot;
</code></pre><h4 id="u6570_u636E_u7C7B"><a href="#u6570_u636E_u7C7B" class="headerlink" title="数据类"></a>数据类</h4><p>在Java中，如果想要创建数据类或是POJO类（只保存了一些状态的类），我们需要创建一个拥有大量字段、getters与setters的类，也许还要提供toString与equals方法：</p>
<pre><code>public class Artist {
    private long id;
    private String name;
    private String url;
    private String mbid;

    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getUrl() {
        return url;
    }

    public void setUrl(String url) {
        this.url = url;
    }

    public String getMbid() {
        return mbid;
    }

    public void setMbid(String mbid) {
        this.mbid = mbid;
    }

    @Override
    public String toString() {
        return &quot;Artist{&quot; +
                &quot;id=&quot; + id +
                &quot;, name=&apos;&quot; + name + &apos;\&apos;&apos; +
                &quot;, url=&apos;&quot; + url + &apos;\&apos;&apos; +
                &quot;, mbid=&apos;&quot; + mbid + &apos;\&apos;&apos; +
                &apos;}&apos;;
    }
}
</code></pre><p>在Kotlin中，上述代码可以写成下面这样：</p>
<pre><code>data class Artist (?
    var id: Long,
    var name: String,
    var url: String,
    var mbid: String)
</code></pre><p>Kotlin使用属性而非字段。基本上，属性就是字段加上其getter与setter。</p>
<h4 id="u4E92_u64CD_u4F5C"><a href="#u4E92_u64CD_u4F5C" class="headerlink" title="互操作"></a>互操作</h4><p>Kotlin提供了一些非常棒的互操作特性，这对于Android开发帮助非常大。其中之一就是拥有单个方法的接口与lambda表达式之间的映射。这样，下面这个单击监听器：</p>
<pre><code>view.setOnClickListener(object : View.OnClickListener {
    override fun onClick(v: View) {
        toast(&quot;Click&quot;)?
    }
?})
</code></pre><p>可以写成这样：</p>
<pre><code>view.setOnClickListener { toast(&quot;Click&quot;) }
</code></pre><p>此外，getters与setters都会自动映射到属性上。这并不会造成性能上的损失，因为字节码实际上只是调用原来的getters与setters。如下代码所示：</p>
<pre><code>supportActionBar.title = title
textView.text = title
contactsList.adapter = ContactsAdapter()
</code></pre><p>####Lambda表达式</p>
<p>Lambda表达式会在极大程度上精简代码，不过重要的是借助于Lambda表达式，我们可以做到之前无法实现或是实现起来非常麻烦的事情。借助于 Lambda表达式，我们可以以一种更加函数式的方式来思考问题。Lambda表达式其实就是一种指定类型，并且该类型定义了一个函数的方式。比如说，我 们可以像下面这样定义一个变量：</p>
<pre><code>val listener: (View) -&gt; Boolean
</code></pre><p>该变量可以声明一个函数，它接收一个view并返回这个函数。我们需要通过闭包的方式来定义函数的行为：</p>
<pre><code>val listener = { view: View -&gt; view is TextView }
</code></pre><p>上面这个函数会接收一个View，如果该view是TextView的实例，那么它就会返回true。由于编译器可以推断出类型，因此我们无需指定。还可以更加明确一些：</p>
<pre><code>val listener: (View) -&gt; Boolean = { view -&gt; view is TextView }
</code></pre><p>借助于Lambda表达式，我们可以抛弃回调接口的使用。只需设置希望后面会被调用的函数即可：</p>
<pre><code>fun asyncOperation(value: Int, callback: (Boolean) -&gt; Unit) {
    ...
    callback(true)?
}

asyncOperation(5) { result -&gt; println(&quot;result: $result&quot;) }
</code></pre><p>还有一种更加简洁的方式，如果函数只接收一个参数，那就可以使用保留字it：</p>
<pre><code>asyncOperation(5) { println(&quot;result: $it&quot;) }
</code></pre><h4 id="Anko"><a href="#Anko" class="headerlink" title="Anko"></a>Anko</h4><p>Anko是Kotlin团队开发的一个库，旨在简化Android开发。其主要目标在于提供一个DSL，使用Kotlin代码来声明视图：</p>
<pre><code>verticalLayout {
    val name = editText()
    button(&quot;Say Hello&quot;) {
        onClick { toast(&quot;Hello, ${name.text}!&quot;) }
    }
}
</code></pre><p>它还提供了其他一些很有用的特性。比如说，导航到其他Activity：</p>
<pre><code>startActivity(&quot;id&quot; to res.id, &quot;name&quot; to res.name)
</code></pre><h3 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h3><p>如你所见，Kotlin在很多方面都简化了Android的开发工作。它会提升你的生产力，并且可以通过非常不同且更加简单的方式来解决一些常见的问题，你开始学习了么？</p>
<h3 id="u53C2_u8003_u8D44_u6599_uFF1A"><a href="#u53C2_u8003_u8D44_u6599_uFF1A" class="headerlink" title="参考资料："></a>参考资料：</h3><pre><code>1. http://www.infoq.com/cn/news/2016/01/kotlin-android?utm_campaign=infoq_content&amp;utm_source=infoq&amp;utm_medium=feed&amp;utm_term=global
2. http://www.oschina.net/news/70734/kotlin-1-0-final
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>就在昨天，Android领域的Swift–Kotlin 1.0发布了，详细的新版本发布介绍请「阅读原文」查看官方发行说明。</p>
<h3 id="u4F55_u4E3AKotlin_uFF1F"><a href="#u4F55_u4E3AKotlin_uFF1F" class="headerlink" title="何为Kotlin？"></a>何为Kotlin？</h3><p>Kotlin 是一门实用的编程语言，可用于 JVM 和 Android 程序开发，Kotlin 结合了面向对象和函数式特性，致力于互操作性，安全，简洁和工具支持。</p>
<p>Kotlin 是一门通用的语言，只要能用 Java 的地方就能用 Kotlin，包含：服务器程序开发，移动应用开发（Android），桌面客户端程序开发。 Kotlin 支持所有主要的开发工具以及服务，比如：</p>
<pre><code>IntelliJ IDEA，Android Studio 和 Eclipse
Maven, Gradle 和Ant
Spring Boot（Kotlin 支持今天正式发布！）
GitHub，Slack，甚至 Minecraft
</code></pre>]]>
    
    </summary>
    
      <category term="Kotlin" scheme="http://apanda.club/tags/Kotlin/"/>
    
      <category term="技术" scheme="http://apanda.club/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
</feed>
